<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最新stable diffusion3模型的服务器本地部署</title>
      <link href="/posts/2c428f3d.html"/>
      <url>/posts/2c428f3d.html</url>
      
        <content type="html"><![CDATA[<p>最新版的stable diffusion3据说不错，就测试了一下，还是比较好安装的，生成效果比之前用的模型好多了。我现在还不太会写prompt，后面再琢磨一下。</p><p>这是服务器配置：</p><table><thead><tr><th>项</th><th>说明</th></tr></thead><tbody><tr><td>系统</td><td>Ubuntu 20.04.1</td></tr><tr><td>存储</td><td>&gt;100GB</td></tr><tr><td>Python</td><td>3.10</td></tr><tr><td>CUDA Version</td><td>11.8</td></tr><tr><td>GPU Driver</td><td>520.61.05</td></tr><tr><td>GPU</td><td>NVIDIA 3090 1张</td></tr></tbody></table><h2 id="新建环境">新建环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n SD3 python=3.10</span><br><span class="line">conda activate SD3</span><br></pre></td></tr></table></figure><h2 id="下载ComfyUI">下载ComfyUI</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/comfyanonymous/ComfyUI</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</span><br><span class="line"><span class="comment"># 我的是CUDA11.8，你要是CUDA12要安装对应版本的</span></span><br><span class="line">pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure><p>进入SD3的<a href="https://huggingface.co/stabilityai/stable-diffusion-3-medium/tree/main">模型链接</a>下载最新的模型<code>sd3_medium.safetensors</code>。（下载模型需要登录账号验证一下。）</p><blockquote><p>浏览器下载容易中断的话，就用迅雷下载。</p></blockquote><p>再进入到<code>text_encoders</code>文件夹，把<code>clip_g.safetensors</code>、<code>clip_l.safetensors</code>、<code>t5xxl_fp16.safetensors</code>三个文件下载下来，这是CLIP模型，用于将文本与图片连接起来的模型（如果显存够，就不要下载<code>t5xxl_fp16.safetensors</code>文件，而是下载<code>t5xxl_fp8_e4m3fn.safetensors</code>文件，这是Int8的量化版本）。</p><p>下载完成之后，<code>sd3_medium.safetensors</code>文件放在<code>./models/checkpoints</code>文件夹下，其他3个文件放在<code>./models/clip</code>下。</p><blockquote><p>目前最新的文件夹中多了几个文件：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>sd3_medium.safetensors</td><td>不包含CLIP模型</td></tr><tr><td>sd3_medium_incl_clips.safetensors</td><td>也就是 sd3_medium.safetensors + clip_g.safetensors + clip_l.safetensors</td></tr><tr><td>sd3_medium_incl_clips_t5xxlfp16.safetensors</td><td>sd3_medium.safetensors + clip_g.safetensors + clip_l.safetensors + t5xxl_fp16.safetensors</td></tr><tr><td>sd3_medium_incl_clips_t5xxlfp8.safetensors</td><td>sd3_medium.safetensors + clip_g.safetensors + clip_l.safetensors + t5xxl_fp8_e4m3fn.safetensors</td></tr></tbody></table><p>也就是说你下载了下面那些模型文件一些CLIP的文件就不用再下载了。</p></blockquote><p>下载<code>ComfyUI</code>的SD3的工作流：</p><p>进入huggingface的<code>comfy_example_workflows</code>文件夹，下载里面的文件，可以都下载进来，比如下载<code>sd3_medium_example_workflow_basic.json</code>文件，这个文件就放在你自己的笔记本里面备用。</p><h2 id="运行">运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py --listen 0.0.0.0 --port 10000</span><br></pre></td></tr></table></figure><p>加载成功后命令行显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total VRAM 24268 MB, total RAM 257596 MB</span><br><span class="line">pytorch version: 2.3.1+cu118</span><br><span class="line">Set vram state to: NORMAL_VRAM</span><br><span class="line">Device: cuda:0 NVIDIA GeForce RTX 3090 : cudaMallocAsync</span><br><span class="line">VAE dtype: torch.bfloat16</span><br><span class="line">Using pytorch cross attention</span><br><span class="line"></span><br><span class="line">Import times for custom nodes:</span><br><span class="line">   0.0 seconds: /home/xxx/BigModel/ComfyUI/custom_nodes/websocket_image_save.py</span><br><span class="line"></span><br><span class="line">Starting server</span><br><span class="line"></span><br><span class="line">To see the GUI go to: http://0.0.0.0:10000</span><br></pre></td></tr></table></figure><p>在你的浏览器中输入：<code>http://服务器的IP地址:10000</code>来访问，这是界面：</p><p><img src="/posts/2c428f3d/ComfyUI.png" alt="ComfyUI的界面"></p><p>这与之前的WebUI完全不啊，是一个流程图的形式，感觉很高级，WebUI的界面我其实更加喜欢，但是好像还没有兼容<code>Stable diffusion3</code>，等后续更新吧。</p><p>这里是<code>ComfyUI</code>默认的工作流，不适合最新的<code>Stable diffusion3</code>。需要调整为<code>Stable diffusion3</code>的流程：将之前下载的<code>sd3_medium_example_workflow_basic.json</code>直接拖到界面里，流程就变了，之后你需要再次点击<code>Load CheckPoints</code>、<code>TripleCLIPLoader</code>里面的选项选择刚才下载的那些文件。</p><p><img src="/posts/2c428f3d/ComfyUI1.png" alt="ComfyUI的界面-SD3工作流"></p><p>这个时候点击右侧的<code>Queue Prompt</code>就可以生成了（第一次生成的时候需要先加载模型会慢一些，后续再生成就快了）。</p><h2 id="生成测试">生成测试</h2><p>这是我生成的结果：</p><p><img src="/posts/2c428f3d/ComfyUI_temp_tmjtt_00001_1.png" alt="第一张图"></p><p>因为种子被固定了，默认生成图片都是一样的。</p><p>我又试了一下之前的提示词的结果，效果好一些：</p><p><img src="/posts/2c428f3d/ComfyUI_temp_iycdq_00002_1.png" alt="第二张图"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A cyberpunk-inspired Chinese goddess with long, flowing locks, her hair interwoven with glowing strands of silk, standing atop a skyscraper overlooking a neon-drenched cityscape.</span><br></pre></td></tr></table></figure><p><img src="/posts/2c428f3d/ComfyUI_temp_rzeuj_0003_1.png" alt="第三张图"></p><p>好像特别会画赛博朋克风格的图片，这些风格的图片路边招牌好像都是日文。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A couple sharing a tender farewell kiss near a black hole, depicted in the ethereal style of Chinese ink wash painting, with the cosmic backdrop blending into a gradient of ink tones</span><br></pre></td></tr></table></figure><p><img src="/posts/2c428f3d/ComfyUI_temp_rzeuj_0004_1.png" alt="第四张图"></p><p>也许训练的图片中国画都有印章，我生成了几张竟然还像模像样的都有印章。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A molecular diagram of DNA replication, highlighting the intricate dance of base pairing and the replication machinery at work</span><br></pre></td></tr></table></figure><p><img src="/posts/2c428f3d/ComfyUI_temp_rzeuj_0005_1.png" alt="第五张图"></p><p>学术图片画的还有模有样的，像是拿一张图PS的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lin Daiyu, the delicate yet resolute heroine from the classic Chinese novel, in a moment of bold action, forcefully pulling out the trunk of a willow tree, symbolizing her inner bravery</span><br></pre></td></tr></table></figure><p><img src="/posts/2c428f3d/ComfyUI_temp_vayuy_0006_1.jpg" alt="第六张图"></p><p>想画个林黛玉倒拔垂杨柳，想象力还是不够，画了很多张都没有拔的，倒是直接给杨柳的腰拉下来了！</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A youthful and vibrant Chinese girl in her late teens, with clear skin, bright eyes, and a fashionable sense of style, embodying the spirit of modern Chinese youth</span><br></pre></td></tr></table></figure><p><img src="/posts/2c428f3d/ComfyUI_temp_vayuy_0009_1.png" alt="第七张图"></p><p>美女必须要画！</p><hr><p>在执行过程中，显存高峰大概占用<code>18G</code>。不知道为啥，生成了一两张图片之后再点击生成就没反应了，感觉像BUG。我又试了一下，需要变更参数，比如种子才会再次生成图片。</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Stable Diffusion </tag>
            
            <tag> ComfyUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion本地部署+controlNet插件</title>
      <link href="/posts/f89fb3f7.html"/>
      <url>/posts/f89fb3f7.html</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://cloud.tencent.com/developer/article/2265947">腾讯云GPU服务器部署Ai绘画Stable Diffusion 小白可用</a></p><h2 id="介绍">介绍</h2><p>Stable Diffusion是2022年发布的支持由文本生成图像的 AI 绘画工具，是一个开源的工具，其他的比如Midjourney、文心一格目前闭源。</p><p>现在Stable Diffusion的图形化界面主要用的是越南人<code>AUTOMATIC1111</code>的项目<code>stable-diffusion-webui</code>，里面的代码是尽可能方便的构建环境和下载模型文件，但是对于国内的来说就反而变得不方便了，封装的有点过头。我尝试运行<code>bash webui.sh</code>文件或者github仓库硬是下载不了，而且目前大部分的教程都是在教怎么一键运行，包括更改连接之类的，我这儿试了总是有一些文件下载不了，于是决定拆解代码自己取下载和拉取仓库，按照下面的步骤执行就可以知道哪些地方缺东西了：</p><h2 id="构建环境">构建环境</h2><p>构建conda环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n SD python=3.10</span><br><span class="line">conda activate SD</span><br></pre></td></tr></table></figure><h2 id="下载WebUI">下载WebUI</h2><p>下载常用的WebUI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用镜像</span></span><br><span class="line"><span class="comment"># 如果不行就去https://github.com/AUTOMATIC1111/stable-diffusion-webui下载zip文件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.moeyy.xyz/https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> stable-diffusion-webui</span><br></pre></td></tr></table></figure><p>调整代码，打开<code>launch.py</code>，将下面的代码注释掉（这段代码是建立虚拟环境，安装相应的包）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with launch_utils.startup_timer.subcategory(&quot;prepare environment&quot;):</span></span><br><span class="line">    <span class="comment"># if not args.skip_prepare_environment:</span></span><br><span class="line">        <span class="comment"># prepare_environment()</span></span><br></pre></td></tr></table></figure><p>拉取github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到repositories文件夹</span></span><br><span class="line"><span class="built_in">cd</span> repositories</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载不了就去github下载zip，然后放在repositories文件夹下再改名</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AUTOMATIC1111/stable-diffusion-webui-assets.git stable-diffusion-webui-assets</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Stability-AI/stablediffusion.git stable-diffusion-stability-ai</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Stability-AI/generative-models.git generative-models</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/crowsonkb/k-diffusion.git k-diffusion</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/salesforce/BLIP.git BLIP</span><br></pre></td></tr></table></figure><p>安装包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回到文件夹</span></span><br><span class="line">cd ../stable-diffusion-webui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装torch2.3.0为了契合xformers</span></span><br><span class="line"><span class="comment"># WebUI中安装的是2.1.2版本，这里用新版我运行没问题</span></span><br><span class="line">pip install torch==<span class="number">2.3</span><span class="number">.0</span> torchvision==<span class="number">0.18</span><span class="number">.0</span> torchaudio==<span class="number">2.3</span><span class="number">.0</span> --index-url https://download.pytorch.org/whl/cu118</span><br><span class="line"><span class="comment"># pip install -U -I --no-deps xformers==0.0.23.post1</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple ngrok</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pytorch-lightning==<span class="number">1.6</span><span class="number">.5</span></span><br><span class="line">pip install -U xformers --index-url https://download.pytorch.org/whl/cu118</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple dctorch timm</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple fastapi==<span class="number">0.90</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h2 id="下载模型">下载模型</h2><p>下载用来生成图片的模型，现在模型有很多，这里先测试能不能用，就先下载这些模型，每一个模型大概有<code>4G</code>的占用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># =================== 下载用来生成图片的模型 ===========</span></span><br><span class="line"><span class="comment"># 下载v1-5-pruned-emaonly.safetensors</span></span><br><span class="line"><span class="comment"># https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.safetensors</span></span><br><span class="line"><span class="built_in">mkdir</span> -p models/Stable-diffusion/</span><br><span class="line"><span class="built_in">mv</span> v1-5-pruned-emaonly.safetensors models/Stable-diffusion/</span><br><span class="line"><span class="comment"># 下载sd-v1-4.ckpt（可选）</span></span><br><span class="line"><span class="comment"># https://huggingface.co/CompVis/stable-diffusion-v-1-4-original/blob/main/sd-v1-4.ckpt</span></span><br><span class="line"><span class="built_in">mv</span> sd-v1-4.ckpt models/Stable-diffusion/</span><br></pre></td></tr></table></figure><blockquote><p>其他模型，这些模型可以在<a href="https://civitai.com">civitai</a>找到：</p><ol><li>chilloutmix：网上看到比较火的模型，包含有18+的内容！</li><li>Korean-doll：可以绘制韩风美女。</li><li>Lora：现在好像找不到了，包含有18+的内容！</li><li>WAI-REAL_CN：中国风美女！</li></ol><p>下载了之后把模型文件放在<code>models/Stable-diffusion</code>下面，就可以选择这个模型了。</p></blockquote><p>下载clip模型，这个给图片和提示词建立关联用的东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入https://huggingface.co/openai/clip-vit-large-patch14/tree/main</span></span><br><span class="line"><span class="comment"># 把所有的文件下载下来，放到下面这个文件夹里面</span></span><br><span class="line"><span class="built_in">mkdir</span> -p openai/clip-vit-large-patch14</span><br></pre></td></tr></table></figure><p>脸部优化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/TencentARC/GFPGAN/releases/download/v1.3.0/GFPGANv1.4.pth</span></span><br><span class="line"><span class="comment"># 文件下载之后放在stable-diffusion-webui下面，也就是根目录</span></span><br></pre></td></tr></table></figure><h2 id="开始运行">开始运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --listen  以0.0.0.0侦听</span></span><br><span class="line"><span class="comment"># --no-half 不要将模型切换到16位浮点数</span></span><br><span class="line"><span class="comment"># --xformers 使用xformers加速</span></span><br><span class="line"><span class="comment"># --port 10000 设置端口为 10000</span></span><br><span class="line"><span class="comment"># --skip-torch-cuda-test 退出torch cuda测试</span></span><br><span class="line">python launch.py --listen --no-half --skip-torch-cuda-test --xformers --port 10000</span><br></pre></td></tr></table></figure><p>运行成功后显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Loading weights [6ce0161689] from /home/xxx/stable-diffusion-webui/models/Stable-diffusion/v1-5-pruned-emaonly.safetensors</span><br><span class="line">Running on local URL:  http://0.0.0.0:10000</span><br><span class="line"></span><br><span class="line">To create a public link, set `share=True` in `launch()`.</span><br><span class="line">/home/xxx/stable-diffusion-webui/repositories/stable-diffusion-webui-assets</span><br><span class="line">Startup time: 7.3s (import torch: 2.3s, import gradio: 0.6s, setup paths: 1.8s, initialize shared: 1.3s, other imports: 0.4s, load scripts: 0.3s, create ui: 0.4s, gradio launch: 0.1s).</span><br><span class="line">Creating model from config: /home/xxx/stable-diffusion-webui/configs/v1-inference.yaml</span><br><span class="line">Applying attention optimization: xformers... done.</span><br><span class="line">Model loaded in 2.5s (load weights from disk: 0.5s, create model: 0.6s, apply weights to model: 0.6s, calculate empty prompt: 0.7s).</span><br></pre></td></tr></table></figure><p><img src="/posts/f89fb3f7/SD.jpg" alt="WebUI"></p><p>WebUI的界面，左上角可以选择模型，中间可以选择模式，右下角是模型参数，右侧是显示生成的图片。</p><blockquote><p>如果运出现下面两种错误：</p><ol><li><code>AttributeError: __config__</code></li><li><code>AttributeError: 'NoneType' object has no attribute '_id'</code></li></ol><p>解决办法<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/11642">[Bug]: AttributeError: config</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall </span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple fastapi==0.90.1</span><br></pre></td></tr></table></figure></blockquote><p>写的prompt：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A mouse floating in outer space, sitting on Tom&#x27;s head and hugging a piece of cheese.</span><br></pre></td></tr></table></figure><p>生成的图：</p><p><img src="/posts/f89fb3f7/1.png" alt></p><p>试了一下，原本下载的模型<code>v1-5-pruned-emaonly.safetensors</code>生成的结果惨不忍睹。prompt这么短都给我省略内容是吧！我的汤姆猫呢！</p><p>运行过程中，显存大概占用<code>6G</code>左右。3090完全够用！</p><h2 id="ControlNet">ControlNet</h2><p>controlNet的插件安装和使用后续再补充。</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Stable Diffusion </tag>
            
            <tag> controlNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物画图大作战之基础篇</title>
      <link href="/posts/f2633fba.html"/>
      <url>/posts/f2633fba.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>在一些网站上可以看到这种类型的图形，比如GATK官网上面的这张图。</p><p><img src="/posts/f2633fba/gatk_pipeline_overview.png" alt="gatk_pipeline_overview"></p><p>这张流程图其实大家可能经常看到，在生物的一些论坛或者网站里面。</p><p>首先问大家一个问题，<strong>你觉得这个图片可以拿什么画呢？</strong></p><p>PhotoShop？Illustrator？CorelDraw？</p><p>上面的工具的确都可以画出来，甚至用windows的画图都能画出来，但是这里我想说用PPT！</p><ul><li><p>用ppt不是为了装逼，而是画这种图就够用而且还好用，因为它里面自带了很多的图形，其实在绘制上面类型的简图的时候还是比较好用的。</p></li><li><p>PPT是很常用的然后也是汇报常用的软件。</p></li><li><p>另外可以将这种图形保存到ppt的格式中，下次还可以重复编辑和使用，而不至于像<code>.png</code>或者<code>.jpg</code>的图片那样没办法重新编辑了</p></li><li><p>然后ppt的文件也是比较轻量的，不会像PS的<code>.psd</code>格式那样比较大而打开较慢。</p></li></ul><p>在画这张图之前，我们需要来看看这种图的特点。</p><p><strong>提醒</strong>：建议把这张图片<code>右键</code> -&gt; <code>另存为</code>，用图片浏览器打开。</p><p>另外文中的名词与图片中元素的对应关系</p><table><thead><tr><th>名称</th><th>具体的元素位置</th></tr></thead><tbody><tr><td>离心管</td><td>第一个元素</td></tr><tr><td>测序仪</td><td>第二个元素</td></tr><tr><td>read信息记录</td><td>第三个元素</td></tr><tr><td>gatk工具箱</td><td>第四个元素</td></tr><tr><td>变异位点信息</td><td>第五个元素</td></tr></tbody></table><h2 id="磨刀霍霍">磨刀霍霍</h2><p>在临摹这个图的时候不要想着“一口吃个胖子”，既然是重复这幅图，自然需要观察这幅图的特点，这样我们在画的才能得心应手。</p><ul><li><strong>色彩</strong></li></ul><p><img src="/posts/f2633fba/gatk_pipeline_overview.png" alt="gatk_pipeline_overview"></p><p>首先我们观察色彩部分，其实这个颜色很明显了，就是“蓝”、“绿”、“黄”、“红”，“灰”，“黑”。</p><p>你有没有这种感觉，刚看到这张图的时候，下面这三个元素是直接吸引你的。我们来看看为什么它们就像<strong>万人迷</strong>一样在人海之中一下子就抓住了我们的眼球！</p><p><img src="/posts/f2633fba/%E5%90%8C%E8%89%B2%E5%85%83%E7%B4%A0.png" alt="同色元素"></p><p>这三个元素有啥特别的？也就是“五颜六色”一些！很刺激！诶！你甭说，就是“五颜六色”让你觉得它们就算在人海之中你也能一眼找到它对吧！这个问题的答案就是因为它们的颜色。这里说到了色彩的第一个作用——<strong>强调</strong>元素。</p><p>另外还没完，你应该也看到了它们之间的颜色组是一样的。都包含“蓝”、“绿”、“黄”、“红”，并且都是一样的颜色。</p><p>第二个问题来了，色彩为什么这样设置呢？它们的颜色组一致，那之间肯定有联系，其实这里很明显啦！就是“不同的样品经过测序之后得到每一个样品的测序数据，之后使用GATK对综合四个样本生成综合的变异位点的信息“。这里说到了色彩的第二个功能——<strong>关联</strong>元素。</p><p>继续，那这张图为什么会用这些颜色呢？</p><p><img src="/posts/f2633fba/%E5%8D%81%E4%BA%8C%E8%89%B2%E7%9B%98.PNG" alt="十二色盘"></p><p>我们来看一下这个十二色盘，“蓝”、“绿”、“黄”、“红”，这四种有颜色的色彩可以说在这个圆盘上大致的均匀分布，在这种情况下，这种分布的颜色显得对比性很强。使用这四种颜色给四只离心管上色可能是为了说明样品之间是独立的，另外也可能说明了测序样品的多样性。这里说到了色彩的第三个功能——<strong>区分</strong>元素或者增加多样性。</p><p>其实到这里这张图的颜色主题部分就是这里，分析了大部分了，如果我们忽视上面那四种颜色的话，似乎就剩下了陪衬颜色与字体颜色呢——灰色或者黑色。</p><p>为什么其他元素不再使用有色彩的颜色呢？</p><p>之前说过，颜色是为了“强调”一些绘画中的元素，但是没有色彩难道就不强调了吗？文字描述有点单调，我们直接让我们的眼睛来看一下。</p><p><img src="/posts/f2633fba/gatk_pipeline_overview%E5%8F%98%E8%89%B2.png" alt="gatk_pipeline_overview变色"></p><p>这张图是我为了显示与之前的流程图的差别，下了狠手，这下能感觉出来与原版本的差别了吗？</p><p>这里我们把之前用来填充的白色以及灰色改成了有色彩的颜色，就变成上面图中的情况，整体的造型没有任何改变，单就改变了色彩似乎这种前后的层次感以及元素的结构都给人感觉发生了变化。较多的不同色相的色彩让图没有重心点，没有线索，因为一眼看过去，无法注意某个东西，视线一直飘忽不定。说到这里其实就是想说颜色的四个作用——<strong>引导</strong>作用。</p><p>有色彩的颜色会让我们眼睛一眼望过去便会注意到它，另外眼睛的视线还会在这种相同的颜色上面来回的转移，这个期间眼睛会忽视那些色彩暗淡或者没有色彩的元素，比如上面的测序仪图标，其实这样恰巧将三种前后串起来，形成一个结果流程，在从左到右扫视之后就会回头查看那些陪衬元素，比如测序仪和gatk工具箱，这个时候实际上已经有了导向作用，但是流程的具体方向感还没出来，这个时候箭头派上了用场，首先将元素前后排列起来，使用灰色的箭头作为进一步的引导，于是上面的强烈流程感就出来啦，这个箭头的作用其实该在后面的结构里面说明的，但是为了一口气连贯一点，这里先说明一下。</p><p>另外，为什么箭头不用“黑色”，而是用的淡灰色呢？这里我们这个时候把先不看那些有色彩的颜色，我们再来感受一下“白色”，“灰色”，“黑色”之间的美。</p><p><img src="/posts/f2633fba/gatk_pipeline_overview%E9%BB%91%E7%99%BD.png" alt="gatk_pipeline_overview黑白"></p><p>额，脑补黑白画面有点难，我把图片黑白化了一下，这个时候已经没有色彩了，先感受下。当然是与之前的有色彩的情况不一样的，但你有没有发现是不是你这个时候眼睛的注视位置和之前的有色彩的情况不一样了啊。这个时候<strong>测序仪</strong>和<strong>gatk工具箱</strong>成了我们眼睛的首先关注元素了。为什么会这样？其实一眼就看出来了，它们更“<strong>黑</strong>”一些，哈哈！黑色在这种情况下的确是重心，就是说原图除了离心管、测序数据、变异位点这三个图标优先级最高，剩下的就是这个测序仪和gatk工具箱了，它在这种程度下也别强调了。下面给出了我们注意到的一个程度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1级关注度：离心管、READ数据、变异位置信息</span><br><span class="line">+------+</span><br><span class="line">|      | 2级关注度：测序仪、gatk工具箱</span><br><span class="line">|      +-----+</span><br><span class="line">|            | 3级关注度：灰色箭头、背景圆角方块</span><br><span class="line">|            +------+</span><br><span class="line">|                   |</span><br><span class="line">--------------------+</span><br></pre></td></tr></table></figure><p>另外不同情况下白色也会成为重心，比如下面这张照片。</p><p><img src="/posts/f2633fba/%E8%8D%B7%E8%8A%B1.png" alt="荷花"></p><p>这幅黑白的强烈对比让我们一下子就注意到了白色的荷花。在黑色背景的衬托下，荷花变得格外的显眼。</p><p>黑色可以是主体，白色也可以是主体，那怎么看呢，就是说周围的环境不同，就会导致主客的关系发生变化，这两者都是比较极端的颜色，所以显得突出出来了。另外在黑白灰的里面，灰色变成了过渡的、衬托的颜色，一般都是我们在看完主体部分之后眼睛才会移向客体部分，比如上面的荷花图中的荷叶（灰色）部分。</p><p>当然，如果有了颜色之后，情况可能就不一样了。</p><p><img src="/posts/f2633fba/%E5%A5%A5%E9%BB%9B%E4%B8%BD%E8%B5%AB%E6%9C%AC%E5%AF%B9%E6%AF%94.jpg" alt="奥黛丽赫本对比"></p><p>这是奥黛丽赫本[^picture]，啊，我的女神！精致的面容！</p><p>首先看左边这张黑白照片，你们首先看到的是哪里？之后哪里？</p><p><code>眼珠</code>-&gt; <code>眼部</code> -&gt; <code>嘴唇</code> -&gt; <code>面部</code></p><p>有没有感觉到是不是有这样的一个发散的过程呢？在这种黑白反差极其明显的情况下，白色的眼眸格外明显，之后视线才会逐步往脸部的其他地方看去。</p><p>然后看右边这幅彩色图片，你们首先看到的是哪里？之后哪里？</p><p>可能性1 ： <code>嘴唇</code> -&gt; <code>眼睛</code> -&gt; <code>眼部</code> -&gt; <code>面部</code></p><p>可能性2 ： <code>眼睛</code> -&gt;<code>嘴唇</code> -&gt;  <code>眼部</code> -&gt; <code>面部</code></p><p>到这里嘴唇的优先级提高了，因为那一抹口红，哈哈，是吧！眼睛可能还是优先级最高的，但是实际上它的色彩是黑白色的，这个与我们之前说的可能有点差别。凡事不是绝对，这里我觉得是人类的天性！就是说人第一眼会自然的朝对方的眼睛看去。</p><p>别看美女了！我们再回过头来看箭头的灰色，它的目的是为了指引整个过程，但是应该是作为陪衬而不是主体，那自然不能“喧宾夺主”，所以这里使用淡灰色即能被我们眼睛所看到起到指引作用，也不会太显眼。</p><p>小结一下，有色彩的颜色具有<code>强调</code>、<code>关联</code>、<code>区分</code>、<code>引导</code>的作用。</p><ul><li><strong>结构</strong></li></ul><p><img src="/posts/f2633fba/gatk_pipeline_overview.png" alt="gatk_pipeline_overview"></p><p>为了查看方便，把图再放一遍</p><p>图中可以看到有五个元素——<code>离心管</code>、<code>测序仪</code>、<code>read信息</code>、<code>gatk工具箱</code>、<code>结构变异信息</code>。从左到右是一个流程，在上面说颜色的时候其实部分已经叙述了。</p><p>结构说实话就是这些什么各种形状啊什么的，这里来从结构上要重点说一下文中常说的“偷懒”是个怎么偷懒法！</p><p>首先最能引起你的注意的肯定就是那四种颜色啦！你有没有发现这四个颜色对应的东西都是矩形？也就是说它们虽然在不同的元素上的大小长短不一样，但是都属于矩形？那么最后归根结底，我们只需要画出一个方块来就OK了！这是一个“偷懒”点。具体怎么做，别着急，在后面自会揭晓。</p><p>然后你再仔细看<code>read数据</code>和<code>结构变异记录</code>，也就是第三个和第五个元素，能发现其中的规律吗？除了颜色相关之外是不是还有相同的地方？好了，我不卖关子了，其实这里的纸张形状都是一样的，只不过<code>read数据</code>元素的纸张上面多了一点边线装饰，实际上还是一个模子里出来的。所以只需要画一个纸张就可以了！这里又是一个可以“偷懒”点。</p><p>我们再来看第一个元素离心管，这个元素与之前一样，四个之间除了那抹颜色不一样，其他都是一样的啦！所以这里又是一个偷懒点。</p><p>上面这三个元素——<code>离心管</code>、<code>read数据</code>、<code>变异位点记录</code>，归根结底我们实际上只需要画三个基本组成部分就可以了，其他的装饰什么的再分别对待。</p><ul><li>[x] 四个颜色方块</li><li>[x] 单张纸</li><li>[x] 单个离心管</li></ul><p>最后要说的就是在最下层，有一个圆角方块，其实按照流程来看这个方块是可有可无的，那么画在这里的用意是什么呢？</p><p><img src="/posts/f2633fba/gatk_pipeline_overview%E5%8E%BB%E5%BA%95%E6%9D%BF.png" alt="gatk_pipeline_overview去底板"></p><p>去除了后面那个大的圆角方块感觉看起来还行，并没有什么太大影响。再看看下面这个，我随便加上这个黑色的渐变椭圆，感觉咋样，是不是就像这些元素都像“悬浮”起来了，就简单的加了一个椭圆（其中的后面四个都是我“偷懒”！复制前面那个椭圆）。</p><p><img src="/posts/f2633fba/gatk_pipeline_overview%E6%82%AC%E7%A9%BA.png" alt="gatk_pipeline_overview悬空"></p><p>为了对比，我把原版图再放一遍，可以对比看看。</p><p><img src="/posts/f2633fba/gatk_pipeline_overview.png" alt="gatk_pipeline_overview"></p><p>就是说这个方块其实在功能上与上面那个椭圆有点类似，就是说让元素<strong>落到实处</strong>，什么意思，上面的是悬浮的啊，也不是落在地上的啊！在加了椭圆之后，就会感知到地面或者桌面或者其他东西在这些元素的下面，是有参考的位置的，而不是像最上面的那个一样，感觉是存在于<strong>虚空</strong>之中，但是这个方块应该说是<strong>锦上添花</strong>的作用，没有它我觉得也可以。</p><hr><p>从上面的图你可以看到是由这些元素哪些基本形状组成的？线？方块？圆角方块？圆锥？箭头？扳手？</p><p>其实我这里说的基本形状并不是指图中的确就存在的那个，而是将基本形状通过简单的变换就能得到的图中元素的那些基本形状。</p><p>其实这里可以说就用了三种 —— 直线、方块、圆圈。</p><p><img src="/posts/f2633fba/%E6%B1%9F%E5%B1%B1%E4%B8%89%E4%BE%A0.png" alt="江山三侠"></p><p>为什么这么说，因为整个过程你使用这三种元素的确就能绘制成这幅图。说到这里，就想起之前比较早的一本书《江山三侠》[^book]，作者是刘宇老师——北方之驴，驴哥啦！在这本书中作者开篇就亮出了他的绘图所用的三板斧，这个三板斧的招式有哪些呢？来看一看。作者使用了拟人化的手法来叙述这些方法。</p><table><thead><tr><th>大侠</th><th>符号</th><th>特点</th></tr></thead><tbody><tr><td><img src="/posts/f2633fba/%E7%9B%B4%E7%BA%BF%E6%9D%80%E6%89%8B.png" alt="直线杀手"></td><td>-</td><td><strong>绰号</strong>：直线杀手 <strong>性别</strong>：男  <strong>脾气</strong>：冷酷无情  <strong>特长</strong>：使得一手夺命直线拳，传说没有他搞不定的轮廓线！  <strong>三板斧招式</strong>：<code>夺命直线拳</code></td></tr><tr><td><img src="/posts/f2633fba/%E6%96%B9%E5%9D%97%E5%A4%A7%E5%B8%88.png" alt="方块大师"></td><td>□</td><td><strong>绰号</strong>：方块大师  <strong>性别</strong>：男  <strong>脾气</strong>：外刚内柔  <strong>特长</strong>：练得一手无敌方块掌功力，用方块拼凑图形的武功出神入化！ <strong>三板斧招式</strong>：<code>无敌方块掌</code></td></tr><tr><td><img src="/posts/f2633fba/%E5%9C%86%E5%9C%88%E5%A5%B3%E4%BE%A0.png" alt="圆圈女侠"></td><td>○</td><td><strong>绰号</strong>：圆圈女侠  <strong>性别</strong>：女  <strong>脾气</strong>：爱唠叨  <strong>特长</strong>：一手玉女圆圈指练得已经是炉火纯青，传说没有她用圆圈拼凑不了的东西！  <strong>三板斧招式</strong>：<code>玉女圆圈指</code></td></tr></tbody></table><p>这是一个江山三侠的故事，每一个大侠掌握一门三板斧招式，刚开始都是虾兵蟹将，但是随着故事的进行，三侠所耍的三板斧招式越来越熟练，而且变化越来越多，最终打下了整个江山。在落幕的时候，作者刷刷点点写下了这些：</p><blockquote><p>整整一本书，我始终就以“简单观察，简单理解”为原则。以“方块、圆圈、直线”为工具，以“能偷懒处且偷懒”为指导，以“三板斧耍熟了就是大侠！”为信念，以“不抛弃、不放弃，坚持到底就是有意义！”为支撑力，以“学以致用”为终极目标，一步步的就讲下来了。仔细想想，这本书的几百页内容其实也就是这么几句话！</p><p>如果你能捏着鼻子坚持看到这里，那么上面的几句话就是这本书的真正武功秘籍！十有八九你也该得到真传了！只要能领悟到我那几句话，别说学Flash了，我保证你学什么会什么，做什么成什么！</p><p>最后我祝愿各位：耍熟三板斧，纵横天下路！</p><p>好了各位，下山去吧！</p><p>2009年11月30日<br>北方之驴</p></blockquote><p>我们能做点什么呢？我们回头来看看文首的GATK图能不能通过这种“<strong>夺命直线拳</strong>”+“<strong>无敌方块掌</strong>”+“<strong>玉女圆圈指</strong>”三板斧招法来绘制呢？下面进入我们的实战演练环节了。</p><h2 id="📑-📖">📑 📖</h2><p><img src="/posts/f2633fba/%E5%A6%82%E6%9D%A5%E7%A5%9E%E6%8E%8C.jpg" alt="如来神掌"></p><p><strong>在所有所有之前有一本📑 如来神掌要交给你，此书可保你过程中的平安！书中的内容就是📖</strong></p><blockquote><p><strong><code>ctrl+z</code>，后悔如此简单！</strong></p></blockquote><p>天机不可泄露！好了，去吧！</p><h2 id="小试牛刀">小试牛刀</h2><p>我们打开PPT，这里建议使用<strong>office 2007以上</strong>的版本或者<strong>wps</strong>（高版本的软件在工具栏布局以及功能上都优化啦！用起来的时候会舒服一些）。</p><p>使用<strong>无敌方块掌</strong>绘制四个颜色方块。就像下面这样</p><ol><li>首先点击<code>插入</code> -&gt;<code>形状</code> -&gt; <code>方块</code> -&gt; <code>按住shift拖动鼠标得到一个方块</code></li></ol><p><img src="/posts/f2633fba/%E7%94%BB%E4%B8%80%E4%B8%AA%E6%96%B9%E5%9D%97.PNG" alt="画一个方块"></p><ol start="2"><li>然后<code>按住ctrl + shift</code>复制这个方块得到四个方块。（<code>ctrl</code>是对指定的东西拖动时候复制，<code>shift</code>是按照当前垂直或者水平方向进行移动）</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E5%87%BA%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%9D%97.PNG" alt="复制出四个方块"></p><ol start="3"><li>将填充颜色改为上面的四种颜色——“蓝”、“绿”、“黄”、“红”，另外边框线改为黑色。（更改的方法是：对着方块<code>右键</code> -&gt; <code>设置形状格式</code> -&gt; <code>填充</code> -&gt; <code>选择预设的颜色</code>）</li></ol><p><img src="/posts/f2633fba/%E6%96%B9%E5%9D%97%E4%B8%8A%E8%89%B2.PNG" alt="方块上色"></p><p><strong>注</strong>：<em>这里我没有完全与上面的流程图中的颜色一致，而是使用的office中调色板的默认标准颜色。这样是为了大家能方便的点选颜色，而不需要去麻烦的设置那些RGB值。最后如果你自己想尽可能还原的话，可以尝试在GATK那个流程图中取色，然后记住颜色值，将这些方块的颜色改为对应的颜色也是可以的。</em></p><p><img src="/posts/f2633fba/%E9%BB%98%E8%AE%A4%E8%89%B2%E6%9D%BF.PNG" alt="默认色板"></p><ol start="4"><li>然后将这些色块都框选中之后按住<code>shift</code>拖动缩放框缩小之后放在一边。</li></ol><p><img src="/posts/f2633fba/%E7%BC%A9%E5%B0%8F%E6%96%B9%E5%9D%97.PNG" alt="缩小方块"></p><p>到这里其实已经完成了主要的操作了，是的，你没有搞错，这个看起来最简单的部分就是我们这个画图流程中最常用到的东西。到这里小试牛刀就完成啦！</p><h2 id="再接再励">再接再励</h2><p>上面的小试牛刀已经得到一些方块，但是都是些最基本的元素，并没有什么特别的东西，但是别着急，到这一步我们不能止步于简单元素的绘制，我们要尝试绘制稍微复杂一点的元素。这里我们继续使用<strong>无敌方块掌</strong>来做方块，另外直线杀手的<strong>夺命直线拳</strong>也会助助兴哦！这次的<strong>无敌方块掌</strong>威力更加大！</p><p><img src="/posts/f2633fba/%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82.PNG" alt="结构变异"></p><p>这个图中，五个元素里面最好画的是它了，我们可以先试着画一下。在画之前分析一下这个元素的组成，<code>三角形</code> + <code>方块</code> + <code>文字</code>，文字都好说，所以也就是只有<code>三角形</code> + <code>方块</code>，但是<code>三角形</code>呢？它就是缺了一个<code>心眼</code>（角）的方块。所以说最后简化为 <code>方块</code>。之前的结构分析里面说过了，这里其实我们画一张折角的纸后面的东西都还做了，然后这张纸还可以用作另外的元素的绘制。额，说起来简单，我们来实战操作一下。</p><ol><li>首先画一个长方形，然后把填充色改为白色，边框改为黑色：</li></ol><p><img src="/posts/f2633fba/%E7%94%BB%E4%B8%AA%E6%96%B9%E5%9D%97.png" alt="画个方块"></p><ol start="2"><li>然后画一条辅助线，然后按住<code>ctrl</code>将当前的白色方块复制一份，将它的左上角拖动到原始的方块的左上角对齐，之后缩放成如图的情况。（<strong>可以适当的将当前的画面放大（右下角的缩放条），这样进行微调的时候就会精确一些，这个其实为了增加自己画图时候的舒适程度，在后面的讲解不会再说这个事情，你自己觉得需要放大就放大，需要缩小就缩小</strong>）。</li></ol><p><img src="/posts/f2633fba/%E7%94%BB%E6%9D%A1%E8%BE%85%E5%8A%A9%E7%BA%BF.png" alt="画条辅助线"></p><ol start="3"><li>然后<code>单击</code>小白色方块，点击菜单栏的<code>格式</code> -&gt; <code>编辑形状</code> -&gt; <code>编辑顶点</code>。然后对着右下角的点<code>右击</code> -&gt; <code>删除顶点</code>。</li></ol><p><img src="/posts/f2633fba/%E5%88%A0%E9%99%A4%E5%8F%B3%E4%B8%8B%E8%A7%92%E7%9A%84%E7%82%B9.PNG" alt="删除右下角的点"></p><ol start="4"><li>然后单击一下空白处，之后再单击三角形，点击菜单栏的<code>格式</code> -&gt; <code>旋转</code> -&gt; <code>垂直翻转</code>。然后对着绿色的旋转棒将三角形旋转，然后微调一下。</li></ol><p><img src="/posts/f2633fba/%E6%97%8B%E8%BD%AC%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="旋转三角形"></p><ol start="5"><li>然后点击下面那个大的方块，然后同样的点击菜单栏的<code>格式</code> -&gt; <code>编辑形状</code> -&gt; <code>编辑顶点</code>。对着和三角形的右上角的那个位置<code>右键</code> -&gt; <code>添加顶点</code>，然后对着左上角的点单击，然后拖动它到与三角形左边点相交的位置。</li></ol><p><img src="/posts/f2633fba/%E7%A7%BB%E5%8A%A8%E9%A1%B6%E7%82%B9.png" alt="移动顶点"></p><ol start="6"><li>删除参考线，然后，对着三角形<code>单击</code> -&gt; <code>ctrl+c</code>复制 -&gt; <code>ctrl+v</code>粘贴。得到两个三角形。</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.PNG" alt="复制三角形"></p><ol start="7"><li>单击最上层的三角形，<code>右键</code> -&gt; <code>编辑顶点</code>。向下拖动直角顶点， 将其填充色改为淡灰色，线条颜色选择无线条。</li></ol><p><img src="/posts/f2633fba/%E9%98%B4%E5%BD%B1%E4%B8%89%E8%A7%92%E5%BD%A2.PNG" alt="阴影三角形"></p><ol start="8"><li>对着灰色三角形下面的三角形<code>右键</code> -&gt; <code>置于顶层</code> -&gt; <code>置于顶层</code> 。然后移动灰色三角形的位置，期间还可以调整三角形的顶点的位置。</li></ol><p><img src="/posts/f2633fba/%E9%98%B4%E5%BD%B1%E4%B8%89%E8%A7%92%E5%BD%A22.PNG" alt="阴影三角形2"></p><ol start="8"><li>然后将左边的四个色块一起选中，<code>右键</code> -&gt; <code>置于顶层</code> -&gt; <code>置于顶层</code> -&gt;  按住<code>ctrl</code>拖动复制到方块上。</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E8%89%B2%E5%9D%97.PNG" alt="复制色块"></p><ol start="7"><li>对着其中一个方块的右边的缩放点将方块变为竖着的长方形，之后再次对着其中一个方块的右下角按住<code>shift</code>进行缩放。然后调整位置变成下面的样子。这里有一个好习惯，就是选中这四个方块<code>右键</code> -&gt; <code>组合</code> -&gt; <code>组合</code>成为一个整体。</li></ol><p><img src="/posts/f2633fba/%E8%B0%83%E6%95%B4%E8%89%B2%E5%9D%97%E5%A4%A7%E5%B0%8F.PNG" alt="调整色块大小"></p><p><strong>注</strong>：在把方块移动到一行的时候可能会对不齐，这里就需要对齐功能。为了讲解连贯，这里把对齐的方法放到了文末的<code>附录：对齐技巧</code>里面。需要的可以查看。但是这里我建议可以先不管对得齐不齐，我们先往下走，保持连贯性。后面再调整也不迟。</p><ol start="8"><li>按住<code>ctrl+shift</code>复制三份出来（如果取消了对四个方块的选择，可以按住<code>shift</code>加选四个方块），然后复制其中一个到左边，将填充色和边框色改为黑色。</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E5%A4%9A%E4%B8%AA%E8%89%B2%E5%9D%97.PNG" alt="复制多个色块"></p><ol start="9"><li>然后加上英文字就OK啦，<code>插入</code> -&gt; <code>文本框</code> -&gt; <code>横排文本框</code>。这里字体可以用<code>Arial</code>。</li></ol><p><img src="/posts/f2633fba/%E5%8A%A0%E4%B8%8Avariants%E6%96%87%E5%AD%97.PNG" alt="加上variants文字"></p><p>到这里这张纸就完成了。</p><p><img src="/posts/f2633fba/%E7%BB%84%E5%90%88%E8%B5%B7%E6%9D%A5.PNG" alt="组合起来"></p><p>但是之前我们分析了结构的，很多元素是可以重复利用了，也就说后面可以“偷下懒”哦！看出来没，这张纸是不是前面的read数据元素也是这个。我们来把这一步的收尾工作完成。按住<code>shift</code>加选三角形和三角形阴影和方块，<code>右键</code> -&gt; <code>组合</code> -&gt; <code>组合</code>。</p><h2 id="更进一步">更进一步</h2><p>上面的步骤已经得到第一个元素了，虽然相对于其他元素来说很简单，但是已经用到了后面需要用到的方法的十之七八了，我相信到这里你已经会了一些基本操作了，所后面我也不会过多的叙述这些操作的具体过程，如果你要是忘记了回过头去查看一下，次数多了自然就熟悉了。我们再来更进一步把另外两个带颜色的元素——<strong>read数据信息</strong>和<strong>离心管</strong>，绘制完成。</p><ul><li><strong>read数据信息</strong></li></ul><ol><li>将刚才组合得到的纸张按住<code>ctrl</code>复制出四份，然后全选变异信息元素<code>组合起来</code>，放在一旁。</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E7%99%BD%E7%BA%B8.PNG" alt="复制白纸"></p><ol start="2"><li>然后按住<code>ctrl</code>点选左边的蓝色方块到右边的一个白纸。然后调整长宽，之后按住<code>ctrl</code>再复制一个调整好的色块，之后旋转与三角形折角的短边相贴。</li></ol><p><img src="/posts/f2633fba/%E8%BE%B9%E7%BA%BF%E8%89%B2%E5%9D%97.PNG" alt="边线色块"></p><ol start="3"><li>之后调整位置大小以及顶点变成这样。</li></ol><p><img src="/posts/f2633fba/%E8%BE%B9%E7%BA%BF%E8%89%B2%E5%9D%97%E8%B0%83%E6%95%B4.PNG" alt="边线色块调整"></p><ol start="4"><li>画三条直线，调整颜色和宽度，增加文字。</li></ol><p><img src="/posts/f2633fba/%E5%8A%A0%E4%B8%8A%E6%96%87%E5%AD%97%E4%B8%8E%E7%9B%B4%E7%BA%BF.PNG" alt="加上文字与直线"></p><ol start="5"><li>框选整个图形，然后<code>组合起来</code>，之后拖动复制出来四个，然后调整侧边的颜色（因为之前组合了，所以在需要调整颜色的时候要双击进入已经组合的对象才能单独对侧边的方框进行编辑）。</li></ol><p><img src="/posts/f2633fba/%E5%9B%9B%E4%B8%AA%E8%BE%B9%E7%BA%BF%E8%89%B2%E5%9D%97%E7%BA%B8%E5%BC%A0.PNG" alt="四个边线色块纸张"></p><ol start="6"><li>按照顺序将四个纸张叠起来，之后选中四个然后<code>组合</code>。</li></ol><p><img src="/posts/f2633fba/%E5%8F%A0%E8%B5%B7%E6%9D%A5.PNG" alt="叠起来"></p><ol start="7"><li>拖到一边，准备绘制另外一个元素——离心管。</li></ol><p><img src="/posts/f2633fba/%E6%8B%96%E5%88%B0%E4%B8%80%E8%BE%B9.PNG" alt="拖到一边"></p><ul><li>离心管</li></ul><p>离心管之前说过了，我们只需要画一个离心管，其他的复制就OK了！但是离心管与之前不同，它具有曲面的底部，这里部分细节我会详述。</p><p><img src="/posts/f2633fba/EP.PNG" alt="EP"></p><p>我们来观察一下这个离心管的特点，怎么灵活的使用三板斧解决它。</p><p><strong>盖子部分</strong>：盖子明显可以看到它就是两个长方形平放在一起，没什么好说的。</p><p><strong>贴画部分</strong>：贴画说白了就是“花一些”的长方形，没什么好说的。</p><p><strong>阴影部分</strong>：为了呈现立体感，在左侧有一条灰色的阴影，注意这里我们需要用到“透明度”这个概念，之前我们都是用的不透明的颜色进行的填充，这里的阴影其实也就是方块通过变换之后调整透明度就可以了。</p><p><strong>管身部分</strong>：管身部分这这一节里面的重点，也是难点，它其实就是通过<strong>无敌方块掌</strong>完成的，也就是通过方块的变换达到的效果。怎么做的，往下看。</p><ol><li><p>首先我们来画管身，是的，这次我们要“敢于直面惨淡的人生，敢于正视淋漓的鲜血”。与之前的由浅入深不同，我们上来就是要画难画的部分。</p><p>在开始之前我们来看一张图，常见的前后的对比图啦！左边的脸庞比较圆润，右边的脸庞轮廓分明。我不多说，你自己悟一下吧啊！</p></li></ol><p><img src="/posts/f2633fba/%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94.jpg" alt="前后对比"></p><ol start="2"><li>好了，不费话了，我们来画离心管的管身。先画三个方块，然后在画四根线，具体在下面。</li></ol><p><img src="/posts/f2633fba/%E4%B8%89%E4%B8%AA%E6%9F%B1%E5%AD%90.PNG" alt="三个柱子"></p><ol start="3"><li><p>然后对着中间的方块编辑它的顶点。变成下面这个样子。</p><p><strong>注意</strong>：这里的方块已经变成五个点。</p><p><strong>提示</strong>：在进入顶点编辑状态的时候再次对着图形的想要加点的地方右键可以<code>添加顶点</code>。另外，这个点的位置有的时候有点歪，可以放大现在的场景，然后细调。</p></li></ol><p><img src="/posts/f2633fba/%E7%BC%96%E8%BE%91%E9%A1%B6%E7%82%B9.PNG" alt="编辑顶点"></p><ol start="4"><li>然后，在右边的方块上重复第二个方块上的操作。之后注意了，开始要使用<strong>无敌方块掌</strong>中那闪亮的一掌了哦！你有没有发现，在每一个点的位置有两个控制（一边一个）的棒子，这个一般说<code>控制手柄</code>，不是小霸王的那个手柄🎮 啊。你可以把每一个棒子想象为一块“磁铁”，“磁铁&quot;越长，对小球的吸引时间越长，那小球跑的路线就比较贴近&quot;磁铁”，下坠得也越晚。就是说把手柄想象为一块&quot;磁铁&quot;吸引着那条线，几乎每一个顶点周围都有两条&quot;磁铁&quot;吸引着这条线，&quot;磁铁&quot;越长，线就越靠近它那边，当&quot;磁铁&quot;很短或者没有或者方向与线的方向相同的时候，就变成了上面我们看到的<code>尖点</code>了。</li></ol><p><img src="/posts/f2633fba/%E7%A3%81%E9%93%81%E4%B8%8E%E5%B0%8F%E7%90%83.PNG" alt="磁铁与小球"></p><blockquote><p>如果感兴趣的话，搜索一下<code>贝塞尔曲线</code>，Adobe的产品里面的钢笔工具就是这种曲线绘制的代表，ppt的这个曲线绘制体验感不行，但是对于日常我们这个绘制离心管是够用了</p></blockquote><p>这个光说没有那个感觉， 我们来操作一下，首先是调管底的那一道曲线。对着管底的那个点单击，之后会出现两个控制手柄，首先我们拖动手柄的末端变成水平，之后另外一个同样也拖动到水平上，于是出现了下面最右边的形状。</p><p><img src="/posts/f2633fba/%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="变换过程"></p><p>管底完成之后，之后是管身的腰部的手柄需要调整</p><p><img src="/posts/f2633fba/%E8%85%B0%E9%83%A8%E6%89%8B%E6%9F%84%E8%B0%83%E6%95%B4.png" alt="腰部手柄调整"></p><p>这里我们来缩小一些视野，看一下我们做了什么</p><p><img src="/posts/f2633fba/%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B.PNG" alt="变化过程"></p><ul><li>[x] 画一个方块</li><li>[x] 增加一个顶点，得到离心管管身的基本的骨架</li><li>[x] 将顶点变得圆滑一些</li></ul><p>OK，管身到这里差不多啦！我们只需要管身，其他的东西可以删除了（选中按<code>delete</code>）。后面的那些加方块的细节我就不会多说了，接着来吧</p><ol start="5"><li>增加瓶盖、贴画（复制最左边的颜色方块）。</li></ol><p><img src="/posts/f2633fba/%E7%A6%BB%E5%BF%83%E7%AE%A1%E5%AE%8C%E6%88%90%E5%89%8D.PNG" alt="离心管完成前"></p><ol start="6"><li>差不多了，接下来画阴影（这里需要调节透明度，具体做法是<code>右键</code> -&gt; <code>设置形状格式</code> -&gt; <code>填充</code> -&gt; <code>透明度</code> -&gt; <code>左右调整推子来调整透明度</code>）。这一步需要点耐心，最后别忘了瓶盖上还有点阴影。（如果阴影不会画，可以暂时不画，以后补起来）</li></ol><p><img src="/posts/f2633fba/%E9%98%B4%E5%BD%B1%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt="阴影绘制过程"></p><ol start="7"><li>OK，之前说的我们只需要画一支离心管就够了，这里我们直接复制几个出来（复制之前记得<code>组合</code>哦），将贴画的颜色改一下就可以了。</li></ol><p><img src="/posts/f2633fba/%E5%9B%9B%E5%8F%AA%E7%A6%BB%E5%BF%83%E7%AE%A1%E5%B0%B1%E5%AE%8C%E6%88%90%E4%BA%86.PNG" alt="四只离心管就完成了"></p><h2 id="大显身手">大显身手</h2><p>其实到这里你已经具备独立完成这幅图的能力了。但是“帮人帮到底，送佛送到西”，我还是还是继续将另外两个元素绘制完成吧！</p><ul><li>测序仪</li></ul><p><img src="/posts/f2633fba/%E6%B5%8B%E5%BA%8F%E4%BB%AA.png" alt="测序仪"></p><p>测序仪这里使用的方块是圆角方块，在PPT里面有对应的形状，不需要我们单从尖角方块来进行变换。但是这里的测序仪与之前的元素有点不一样，这个测序仪在一定程度上具有立体感。这里PPT能不能完成呢？</p><ol><li>首先要得到半边是圆角的半边是尖角的方块。画一个圆角方块（在<code>插入</code> -&gt; <code>形状</code>里面找）。然后调整圆角的程度，那个黄色的点就是调整圆角的程度的。</li></ol><p><img src="/posts/f2633fba/%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2.PNG" alt="圆角矩形"></p><ol start="2"><li>然后按照下面的过程得到半边圆角半边尖角的方块。<code>右键</code> -&gt;  <code>编辑顶点</code>，将最左侧的两个顶点删除掉，删除之后左边的两个顶点的位置是曲线，这是因为磁铁的方向与线有角度。可以这样将曲度去除，对着左边的两个角点<code>右键</code> -&gt; <code>角部顶点</code>，两个点都要做，有时候需要点击两次。</li></ol><p><img src="/posts/f2633fba/%E5%8D%8A%E8%BE%B9%E5%9C%86%E8%A7%92%E5%8D%8A%E8%BE%B9%E5%B0%96%E8%A7%92%E8%BF%87%E7%A8%8B.png" alt="半边圆角半边尖角过程"></p><blockquote><p><strong>话外篇</strong>：这里你可以注意一下圆角方块的实现原理是什么，就是在四个角的地方，原来普通方块每一个角就只有一个点控制，现在是由两个点控制，当每个角的点之间的距离变短的时候，你会看到方块的圆角化很明显，到最后之间没有距离的时候，那会变成什么形状呢？你应该猜到了吧</p></blockquote><p>那接下来怎么得到立体的图形呢？这里有一个技巧哦！要注意看啊，</p><ol start="3"><li>把之前的半边圆角方块按住<code>ctrl</code>复制一下。</li></ol><p><img src="/posts/f2633fba/%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%8B%E5%8D%8A%E8%BE%B9%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2.PNG" alt="复制一下半边圆角矩形"></p><ol start="4"><li>然后搞两个盖子给他盖上。上面一块白色的盖子，侧面一块深灰色的盖子，顶点的样子已经在后面展示出来了。感觉有点像小时候用过的火柴，哈哈！</li></ol><p><img src="/posts/f2633fba/%E7%9B%96%E4%B8%8A%E7%9B%96%E5%AD%90.PNG" alt="盖上盖子"></p><p><img src="/posts/f2633fba/%E7%9B%96%E5%AD%90%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="盖子的结构"></p><ol start="5"><li>加上装饰。</li></ol><p><img src="/posts/f2633fba/%E6%88%91%E7%94%BB%E7%9A%84%E6%B5%8B%E5%BA%8F%E4%BB%AA.PNG" alt="我画的测序仪"></p><ol start="6"><li>继续，把左半边画出来。同样，这里有偷懒的地方，我不告诉你。</li></ol><p><img src="/posts/f2633fba/%E7%94%BB%E4%B8%A4%E5%9D%97%E6%9D%BF%E5%AD%90.PNG" alt="画两块板子"></p><ol start="8"><li>其他没什么好说的，继续。</li></ol><p><img src="/posts/f2633fba/%E8%BE%85%E5%8A%A9%E7%BA%BF%E8%BF%98%E6%98%AF%E8%A6%81%E7%9A%84.PNG" alt="辅助线还是要的"></p><ol start="9"><li>好了，直接画出来吧！</li></ol><p><img src="/posts/f2633fba/%E5%AE%8C%E6%88%90%E7%9A%84%E6%B5%8B%E5%BA%8F%E4%BB%AA.PNG" alt="完成的测序仪"></p><p>画完啦！最后一个偷懒点，在左边这个测序仪上面有一块盖板，不需要画的太好。只需要遮住右边的箱子的侧边就ok啦！</p><p><img src="/posts/f2633fba/%E9%9A%8F%E4%BE%BF%E7%9A%84%E7%9B%96%E6%9D%BF.PNG" alt="随便的盖板"></p><p>说实话，我总觉得我这个测序仪怎么画的矮胖矮胖的。</p><ul><li>gatk工具箱</li></ul><p>最后这个其实是最容易画的，除了那个扳手~。到这里<strong>玉女圆圈指</strong>我们要使一使了！你可别想着拿<strong>无敌方块掌</strong>来练习📘 玉女心经，小心走火入魔。</p><p><img src="/posts/f2633fba/gatk%E5%B7%A5%E5%85%B7%E7%AE%B1.png" alt="gatk工具箱"></p><ol><li>测序仪先丢一边，我们的绘画的地方不要太杂乱，不然可能会互相干扰。我们三下五除二，尽快搞定。首先画一个圆角矩形，复制改填充色。</li></ol><p><img src="/posts/f2633fba/%E7%94%BB%E4%B8%80%E4%B8%AA%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2.PNG" alt="画一个圆角矩形"></p><ol start="2"><li><p>画一个大圆，黑色，复制一下，蓝色，变小，然后叠到一起，移动到黑色圆角方块的右上角。</p><p><strong>提醒</strong>：在画圆的时候按住<code>shift</code>是画一个正圆。</p></li></ol><p><img src="/posts/f2633fba/%E4%B8%A4%E4%B8%AA%E5%9C%86%E5%9C%88.PNG" alt="两个圆圈"></p><ol start="3"><li>加上文字。不知道图片里面的字体，这里我随便选的，<code>Arial black</code>。<code>TM</code>商标不需要调什么上标什么的，ppt里面好像没有，这里直接新建一个文本框写就可以了，字小一点。</li></ol><p><img src="/posts/f2633fba/gatk%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%8A%A0%E4%B8%8A%E6%96%87%E5%AD%97.PNG" alt="gatk工具箱加上文字"></p><ol start="4"><li><p>还有个扳手，你要是不想画就在网上搜一个<a href="http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E6%89%B3%E6%89%8B%E5%9B%BE%E6%A0%87">扳手图标</a>。然后用ps或者ppt裁剪一下放进去。这里还是说一下怎么画。</p><p>**【选做】**这里扳手稍微麻烦一点，可以放一个扳手图标在ppt里面作为参考。这个扳手可以用一个方块就可以变出来，但是不方便，这里比较好的是用两个方块变化。</p></li></ol><p><img src="/posts/f2633fba/%E4%B8%B4%E6%91%B9%E6%89%B3%E6%89%8B.PNG" alt="临摹扳手"></p><ol start="5"><li>添加一些顶点，便于变形</li></ol><p><img src="/posts/f2633fba/%E6%B7%BB%E5%8A%A0%E5%BF%85%E8%A6%81%E7%9A%84%E9%A1%B6%E7%82%B9.PNG" alt="添加必要的顶点"></p><ol start="6"><li>移动顶点，得到基本的骨架</li></ol><p><img src="/posts/f2633fba/%E7%A7%BB%E5%8A%A8%E9%A1%B6%E7%82%B9%E5%BE%97%E5%88%B0%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6.PNG" alt="移动顶点得到基本骨架"></p><ol start="7"><li>扳手外形得到</li></ol><p><img src="/posts/f2633fba/%E6%89%B3%E6%89%8B%E5%A4%96%E5%BD%A2%E5%BE%97%E5%88%B0.PNG" alt="扳手外形得到"></p><ol start="8"><li>调节把手部分</li></ol><p><img src="/posts/f2633fba/%E6%89%B3%E6%89%8B%E5%AE%8C%E5%96%84.PNG" alt="扳手完善"></p><ol start="9"><li>完成</li></ol><p><img src="/posts/f2633fba/gatk%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%AE%8C%E6%88%90.PNG" alt="gatk工具箱完成"></p><ul><li>组合起来</li></ul><p>到了最后的激动人心的时刻。将它们喊到一起打麻将啦！那些箭头和背景圆角方块我就不说了，到了这里那就不是问题了！</p><p><img src="/posts/f2633fba/%E5%93%8E%E5%91%80%E5%A6%88%E5%91%80%E9%83%BD%E4%B9%B1%E4%BA%86.PNG" alt="哎呀妈呀都乱了"></p><p>到最后一步竟然变成这样了！难道功亏一篑？说实话这一点我之前真没有意识到。那又能怎样呢？难道自己还真的放弃了？改一下不就行了！</p><blockquote><p><strong>提醒</strong>：这一点我是觉得ppt画图的短板，就是<code>边框线</code>和<code>文字</code>不能随着元素的放大缩小而变化，它一直就是那么大。</p></blockquote><p>取消组合改一下文字大小，之后再组合！（不取消组合也可以，双击进入到组合内部进行编辑，对着文字<code>ctrl+a</code>可以选择整个文字）调好之后OK啦！</p><p><img src="/posts/f2633fba/%E6%94%B9%E5%8F%98%E5%AD%97%E4%BD%93.PNG" alt="改变字体"></p><p>接下来画背景的东西。有现成的箭头，别老想着用<strong>方块掌</strong>，能偷懒就偷懒！因为我为了截图的时候中心突出，而没有使用ppt的最大化显示，这里为了让图标可见，之间的距离拉得比较近，不然按照原本的比例，那图标就需要放得很小，截图后看不清。</p><p><img src="/posts/f2633fba/%E5%AE%8C%E6%88%90%EF%BC%81.PNG" alt="完成！"></p><h2 id="细水长流">细水长流</h2><p>说实话，这次并不是100%的还原，其实还有一些细节我们有说到或者注意到，这里可以再继续修改一下。然后以后如果有些绘制什么流程图或者其他的简单的图可以尝试使用ppt来绘制一下，多试几次那个贝塞尔曲线就会变得熟悉起来，之后就喜欢用它了。</p><p>在最开始我说了一些什么颜色啊结构啊！其实我自己还是个门外汉，色彩搭配很复杂，不是三言两语可以说的好的，这些狠多是看点书然后凭着我自己的感觉说的，每一个人的感觉不同，那你可能对于我说的就有一些不一样的见解，我觉得是好事。但是如果你是刚开始的话，下面的一些简单说法可能是有用的，也可能是错的：</p><ul><li>在自己的功力等级不高的时候，画图中的颜色的种类不要用得太多，太多容易迷人眼，不是说不能用，而是太多会让图的重点难以把握。</li><li>为了<strong>突出</strong>你的重点，使用颜色。如果是黑白的图片，那就使用更黑的或者更白的颜色。</li><li>那些装饰最好不使用有色彩的颜色（可以少用一点，比如图中的测序仪中间的圆角矩形），但是如果和其他元素有关联，最好使用和元素一样的颜色，同时需要调低颜色的鲜艳度，不可<strong>喧宾夺主</strong>。</li><li>颜色不是随便用，如果不同元素之间有相同的颜色或者颜色组，需要考虑它们之间是否有<strong>相关性</strong>。</li><li>ppt中的中文字体尽量使用<code>黑体</code>或者<code>微软雅黑</code>，英文使用<code>Arial</code>，也就是所谓的<strong>非衬线体</strong>。</li><li>ppt中自带很多形状，这些形状很多有编辑功能，我们在绘画的时候要善于使用这些来<strong>偷懒</strong>。</li><li>工具是用来帮助我们的，而不能让工具成为我们的负担。</li><li>尽量让自己尝试一下Photoshop进行简单的图片拼接和裁剪，那样会让工作更方便快捷。</li><li>软件的会与不会不是取决于掌握的程度。如果你用它完成了事情，那你就会。</li></ul><p>另外推荐一本书<a href="https://www.baidu.com/link?url=nzAs5ZHtoUxfTXDZ9EsQbvb-aH2UrOhF75cNSR8y1_agqf5xVDp8nGQRAEKL_K3Te474cqbWlLF_jMs1H-HseK&amp;ck=6760.1.75.337.332.341.324.201&amp;shh=www.baidu.com&amp;sht=50000022_hao_pg&amp;wd=&amp;eqid=c49b31de00014dba000000035c852561">《写给大家看的设计书》</a></p><h2 id="后记">后记</h2><p>其实我觉得这个画图和编程其实是有点相似的地方的，编程一个几百行的代码，由多个模块，多个函数组成。这里拿ppt绘图也是一样，每一个元素由基本单元组成。于是就说到了那句话</p><blockquote><p>万丈高楼从地起，归根结底就是砖</p></blockquote><p>其实在看到这类文章的时候可能会着急想知道怎么能画出来这张图，按照什么路子，一路走下来就可以画出来。每个房子虽然用的砖一样，但是结构不一样，同样的房子就需要不同的图纸，不同的建筑过程。自己了解了每一个步骤的作用就可以自己去组合去完成不一样的流程之后可以自己新创建流程。</p><h3 id="为什么要偷懒？">为什么要偷懒？</h3><p>你应该注意到了，我在文中会常提到“偷懒”这个词语，额，有人可能会说，哼！什么玩意啊！教人学坏！这难道不是与我们现在的社会主义核心价值观不符啊！你这个傻逼玩意！&amp;#！&amp;%！&amp;#&amp;！</p><p>后面的话我不说了。咳！为什么说“偷懒“？我想说的是个人的精力有限，你要是孙猴子拔毛就来这么多哥们，那你当我没说。偷懒在本文中其实大部分就是复制，这有两点好处，一使可以保证相似的元素之间大小形状一致，二是可以快速的画出一组图形来。在平常做ppt的时候常常需要偷一下懒。</p><blockquote><p>比如有人做PPT汇报工作，想把PPT做的很完美，在汇报头天晚上还在努力绘图，结果快天亮的时候，发现还有几页PPT的说话没有整理清楚呢？光记得画图了，忘了汇报怎么说啦！第二天汇报的时候满屏幕的高端大气的元素，刚开始给人感觉很好，但是随着汇报的深入那些精美的图形似乎成了主角，你成了配角，大家都去看那些图形了，没有人注意你的存在…到后来，PPT汇报结束之后，大家可能会说你的PPT做的真好！但是一问哪里好，可能就是说，哇，你的那副画，那个流程图好棒啊！能教我吗！</p></blockquote><p>当然这可能是个和妹子交流的好机会，但是没有人会说你的PPT“讲”得好，个人认为 讲得好 &gt; 做得好。PPT做出来狠多是演示用的，所以还是需要讲述。</p><h3 id="为什么自己画啊，模板、插件那么多？">为什么自己画啊，模板、插件那么多？</h3><p>现在网上有很多高手设计的ppt模板，更多都很漂亮高端大气，但是我觉得有些我自己hold不住，自己把控不了，也就是说我和它不合适，所以自己尝试画一些简单的图标，这样一来可以理清自己脑子的思路，二来可以使得部分东西更加直观可视，第三，增加自己的绘图熟练度。</p><p>现在有一些优秀的PPT插件，比如<code>slide</code>，等等，那个图片库里面很多类似于这种的图形，有些很漂亮，很多我现在根本画不出来，但是这也不妨碍我画这些简单的东西啊！别人活得比我好，难道我要去屎？</p><p>说到这里我又想起之前看到的一个问题</p><blockquote><p>谷歌、百度上什么都有，还学那么多干嘛！</p></blockquote><h2 id="参考">参考</h2><p>[^book]: <a href="https://baike.baidu.com/item/%E6%B1%9F%E5%B1%B1%E4%B8%89%E4%BE%A0%EF%BC%9AFlash%E7%9F%AD%E7%89%87%E8%BD%BB%E6%9D%BE%E5%AD%A6/15166747">《江山三侠：Flash短片轻松学》 作者：刘宇 出版：社电子工业出版社 出版时间： 2010年4月1日 </a></p><p>[^picture]: <a href="https://www.zcool.com.cn/work/ZMjM0NjMzNzY=.html?switchPage=on">奥黛丽赫本 - 黑白照片补色 - 站酷</a></p><ul><li><a href="https://book.douban.com/subject/26348041/">梁景红谈色彩设计法则</a></li></ul><p><strong>目前还在学习中，如果有什么错误望能告知，如需转载，请注明出处。</strong></p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perl 命令行实战2 - fastq文件的相关操作</title>
      <link href="/posts/67fa7a61.html"/>
      <url>/posts/67fa7a61.html</url>
      
        <content type="html"><![CDATA[<h2 id="fastq文件的介绍">fastq文件的介绍</h2><p>详细介绍：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFASTQ_format">fastq格式</a></p><p>fastq是一种除了fasta文件之外，做生信另外一个最为常见的文件类型。</p><p>fastq文件主要是用来存储测序的序列信息的。它以4行为一个单位，是严格按照行限定的格式，不像之前的fasta文件那样比较灵活的形式。<br>虽然网上有很多关于fastq文件的介绍，这里我还是想啰嗦几句，因为这样到后面写perl程序的时候可以前后对应着看会稍微方便一点</p><h3 id="示例">示例</h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATCA</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9???FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br><span class="line">@SRR2177462.2 FCC600JACXX:2:1101:1661:2085/1</span><br><span class="line">NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">+</span><br><span class="line">#4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br></pre></td></tr></tbody></table></figure><p>现在我们从头开始，每4行为一组，在每一组之内的：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>第一行</strong>：以<code>@</code>字符开头，表示这条序列的测序信息，来自于哪台测序仪、第几个run、第几个lane、第几个tail、以及在这个tail的X轴与Y轴的位置。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATCA</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>第二行</strong>：测序得到的序列。也可以说是read</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>第三行</strong>：以<code>+</code>字符开头，后面跟着ID序列标识符，如果<code>+</code>后面有东西那么必须与第一行一致，一般都是没有的，为了节省内存。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9???FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>第四行</strong>：是第二行序列每个碱基的质量编码值，包含与第二行字符数量相同的符号。经过转换之后可以得到这个碱基的质量数值，以及这个碱基的错误率。</li></ul><h2 id="前期准备">前期准备</h2><p>因为一般的fastq文件都是经过压缩的，如果你想拿fastq的实际文件来做这次的测试，那样可能比较耗时间，特别是在<code>gzip</code>或者<code>pigz</code>的解压时间上面。所以这里如果你想快速进行实战演练的话，我建议先把本文末尾的<code>测试数据</code>这一步做了，得到<code>123.fastq.gz</code>进行测试会快一些。</p><h2 id="注意">注意!!</h2><blockquote><p>由于我演示是使用的windows系统，在文件的一行结束的位置除了一个<code>\n</code>换行符之外，还有<code>\r</code>回车符这样的字符存在，而使用perl中的<code>chomp</code>方法不能除去<code>\r</code>回车符，所以下面代码中，在Mac或者Linux中可以直接写为<code>chomp</code>我换成了<code>s/\r?\n//</code>。在后面生成<code>123.fastq.gz</code>文件的时候粘贴复制到文本里面去的时候也可能带上回车符<code>\r</code>，这里使用<code>windows</code>进行测试要注意了。</p></blockquote><h2 id="获取fastq文件的信息">获取fastq文件的信息</h2><h3 id="1-序列条数">1. 序列条数</h3><p><strong>思路</strong> ： 利用fastq的四个为一个单位的特征</p><ul><li><strong>方法1</strong><br>比较丑陋</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  # 因为四个为一组，没必要将所有的行都加起来再除以4</span></span><br><span class="line"><span class="string">  # 消耗掉其他三行</span></span><br><span class="line"><span class="string">  &lt;&gt;;&lt;&gt;;&lt;&gt;;</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>方法1.0<br>也可以这么写</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if($. % 4 == 1){</span></span><br><span class="line"><span class="string">    $n++;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>或者使用<code>pigz</code>，<code>pigz</code>要比<code>gzip</code>解压快一些，但是<code>git for windows</code>上没有这个东西，另外使用<code>zcat</code>进行查看文件我发现比直接解压文件要快，所以后面测试还是使用<code>zcat</code>。不过也展示一下<code>pigz</code>的使用方式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d : 解压模式</span></span><br><span class="line"><span class="comment"># -c : 将解压的得到的数据输出到标准输出中</span></span><br><span class="line">pigz -d -c 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  &lt;&gt;;&lt;&gt;;&lt;&gt;;</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>方法2</strong><br>使用linux命令</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc -l 计算行数</span></span><br><span class="line">line=`zcat 123.fastq.gz | <span class="built_in">wc</span> -l`</span><br><span class="line"><span class="built_in">let</span> seq_num=<span class="variable">$line</span>/4</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$seq_num</span></span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></tbody></table></figure><h3 id="2-质量值的类型">2. 质量值的类型</h3><h4 id="有关质量值的编码方式">有关质量值的编码方式</h4><p>现在一般都是采用的<code>Phred+33</code>类型的，那为什么还要说这一小节呢？</p><p>通过介绍这些质量值类型可以帮助理解fastq中质量值与序列的关联性以及在这种利用文本传达信息的过程中，人们所展现出来的智慧！</p><h5 id="测序的错误来源">测序的错误来源</h5><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+==============+       +==============+</span><br><span class="line">| .   .   .   .|       | *   *   *   *|</span><br><span class="line">|   .   .   .  |  ==&gt;  |   *   *   *  |</span><br><span class="line">| .   .   .   .|       | *   *   *   *|</span><br><span class="line">|   .   .   .  |       |   *   *   *  |</span><br><span class="line">+==============+       +==============+</span><br><span class="line"></span><br><span class="line"> 测序芯片中测序点          激发之后产生荧光</span><br></pre></td></tr></tbody></table></figure><p>在测序的时候，是通过对应位置发出来的对应颜色的荧光的强度来得到这个位置测定出。</p><p><img src="/posts/67fa7a61/chromatogram.jpg" alt="chromatogram样图"></p><p>那测序的错误是从何而来呢？</p><blockquote><p>在荧光染料测序中，每次发生碱基合成时会释放出荧光信号，该信号被CCD图像传感器捕获。记录下荧光信号的峰值，生成一个实时的轨迹数据（chromatogram）（如上图所示）。因为不同的碱基用不用的颜色标记，检测这些峰值即可判断出对应的碱基。但由于这些信号的波峰、密度、形状和位置等是不连续或模糊的，有时很难根据波峰判断出正确的碱基。通过对每一个点对不同颜色的曲线参与的程度进行计算，计算许多与波峰大小和分辨率相关的参数，根据这些参数，从一个巨大的查询表中找出碱基质量得分。这个查询表是根据对已知序列的测序数据分析得到的（应该是分析得到波峰参数与碱基错误率的关系，再通过公式把错误率转换成质量得分，得到波峰参数与质量得分的直接对应表）。</p></blockquote><table><thead><tr><th></th><th>波长1</th><th>波长2</th><th>波长3</th><th>波长4</th></tr></thead><tbody><tr><td>A</td><td>0.65</td><td>0.14</td><td>0.01</td><td>0.02</td></tr><tr><td>B</td><td>0.81</td><td>1.03</td><td>0.02</td><td>0.03</td></tr><tr><td>C</td><td>0.02</td><td>0.02</td><td>0.95</td><td>0.04</td></tr><tr><td>D</td><td>0.03</td><td>0.03</td><td>1.10</td><td>1.56</td></tr></tbody></table><p>表2.2.0.1 例如一个测序位点不同碱基所带的荧光基团在这个点发出的荧光的贡献</p><p>那么也就是说，一个点ATGC四个碱基上经过激发之后得到不同的波长，如果这个位点不同颜色占据的量越多，那么出错的可能性就越大，如果某种颜色占据的越多那么越有可能是这个碱基。那么如何描述这种碱基的纯粹程度呢？</p><h5 id="错误的评判标准">错误的评判标准</h5><p><code>Quality Score</code> —— 评判一个碱基判读可靠性指标</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q = -10 lg P</span><br></pre></td></tr></tbody></table></figure><ul><li>Q是质量值</li><li>P是错误率</li></ul><table><thead><tr><th>准确度</th><th>P值(错误率)</th><th>Q值（质量值）</th></tr></thead><tbody><tr><td>90%</td><td>10%</td><td>10</td></tr><tr><td>99%</td><td>1%</td><td>20</td></tr><tr><td>99.9%</td><td>0.1%</td><td>30</td></tr><tr><td>99.99%</td><td>0.01%</td><td>40</td></tr><tr><td>99.999%</td><td>0.001%</td><td>50</td></tr></tbody></table><p>平常常常说<code>Q30</code>，就是说碱基准确度达到99.9%的程度，就是说出错的可能性为0.1%。这里别人推荐了一种记忆方法，10是一个9，20两个9，40是4个9。</p><p>这里有关的测序步骤以及质量值可以参看陈老师的视频</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav23077195%3Ffrom%3Dsearch%26seid%3D15283415322892062157">陈巍学基因</a></p><p>有关P值更加详细的计算说明见这篇文章<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F22595128">P值与基因组学（1）：从fastq文件的分析的分析谈起</a></p><p>那么就需要对每次每个测得的碱基的质量进行记录，怎么来记录呢？可是质量值从个位数到十位数会发生什么呢？</p><h5 id="质量值的记录方式">质量值的记录方式</h5><p>使用数值的序列与质量值得对应关系</p><p>本来对应关系是这样的</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N 2</span><br><span class="line">A 19</span><br><span class="line">A 28</span><br><span class="line">T 35</span><br><span class="line">G 35</span><br><span class="line">A 37</span><br><span class="line">A 37</span><br><span class="line">A 37</span><br><span class="line">T 39</span><br><span class="line">T 39</span><br><span class="line">A 37</span><br><span class="line">A 39</span><br><span class="line">A 37</span><br><span class="line">G 40</span><br><span class="line">A 38</span><br><span class="line">. .</span><br><span class="line">. .</span><br><span class="line">. .</span><br></pre></td></tr></tbody></table></figure><p>写到一行上（其实没有这种数值类型的表示方式）</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 </span><br><span class="line">21928353537373739393739374038403940404041363839403840323940413740363939394040404040364039404040413437403941403940403239403737384040413937394040414041373137363938403539393230333134</span><br></pre></td></tr></tbody></table></figure><p>就单单只看两个碱基，碱基与质量值之间的对应关系有多种</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">N =&gt; 2</span><br><span class="line">A =&gt; 1</span><br><span class="line">或者</span><br><span class="line">N =&gt; 21</span><br><span class="line">A =&gt; 9</span><br><span class="line">或者</span><br><span class="line">N =&gt; 2</span><br><span class="line">A =&gt; 19</span><br><span class="line">或者</span><br><span class="line">N =&gt; 21</span><br><span class="line">A =&gt; 92</span><br></pre></td></tr></tbody></table></figure><p>如果这么写的话，第一个碱基质量值为个位数，其他的为十位数，这样记录之后，后续程序怎么来分析它呢？一个碱基对应的质量值到底是个位数还是十位数呢？这个样子质量值与碱基之间怎么对应啊？这是个问题…</p><p>那如果用空格将数值间隔开呢？</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 2 19 28 35 35 37 37 37 39 39 37 39 37 40 38 40 39 40 40 40 41 36 38 39 40 38 40 32 39 40 41 37 40 36 39 39 39 40 40 40 40 40 36 40 39 40 40 40 41 34 37 40 39 41 40 39 40 40 32 39 40 37 37 38 40 40 41 39 37 39 40 40 41 40 41 37 31 37 36 39 38 40 35 39 39 32 30 33 31 34</span><br></pre></td></tr></tbody></table></figure><p>有没有感觉到瞬间多了好多字符一样的，这样带来的后果就是占用的内存急剧增加。</p><p>于是乎人们就想到了一个好办法</p><p><img src="/posts/67fa7a61/ASCII%E7%A0%81%E8%A1%A8.jpg" alt="ASCII码表"></p><p>使用ASCII码的序列与质量值得对应关系</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 #4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br></pre></td></tr></tbody></table></figure><p>可以看到一个碱基对应一个表示质量值的字符，这样既减少了文件所占据的内存，也让碱基质量值与碱基的对应关系更加清晰。</p><p>那么将使用ASCII码进行记录的质量值与直接使用数字进行记录的质量进行比较，使用数字表示法：</p><ul><li><strong>文件占据内存增加</strong>：在fastq文件中，占内存的大头是序列以及质量值的文字，如果质量值用两个数字表示那内存占据会增加很多</li><li><strong>碱基与质量值对应的关系</strong>：如果是以数字的形式对应碱基的话，如果一直是1个碱基对应2个数字那都好说，可是保不齐某些碱基测序质量极差，质量值为个位数，那么既有1对2、也有1对1，怎么才能确定碱基与质量值之间的对应关系呢？</li></ul><p>既然采用ASCII码来记录碱基质量，那么为什么还要分什么<strong>Phred+33</strong>、<strong>Phred+64</strong>之类的？</p><h5 id="质量值的编码方式">质量值的编码方式</h5><p>现有的常见的测序质量值编码方式</p><ul><li><strong>Phred+33</strong></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJ</span><br><span class="line">                  |         |         |         |         ||</span><br><span class="line">   Quality score: 0........10........20........30........4041</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Phred+64</strong></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |         |         |         |         |</span><br><span class="line">   Quality score: 0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Solexa+64</strong></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: ;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |    |         |         |         |         |</span><br><span class="line">   Quality score:-5....0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure><p>话说<strong>Phred</strong>和<strong>solexa</strong>是什么意思呢？百度<strong>Phred</strong>之后发现有一个很古老的<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.phrap.com%2Fphred%2F">网站</a>，网页比较简洁，里面写着</p><blockquote><p>Phred is a base-calling program for DNA sequence traces. Phred reads DNA sequence chromatogram files and analyzes the peaks to call bases, assigning quality scores (“Phred scores”) to each base call.</p></blockquote><p>就是说<strong>Phred</strong>这个原来是一个工具，用来对测序得到的<code>chromatogram</code>文件分析（可以见上面的有四条曲线的图）。这个软件通过对四种不同的荧光的强度来分析得到该碱基位点的质量值。</p><p>当时是1998年发现核酸研究上的一篇文章《 Base-calling of automated sequencer traces using phred. I. Accuracy assessment》然后同年又发了文章《Base-calling of automated sequencer traces using phred. II. Error probabilities》。</p><blockquote><p>最初开发时，Phred在所检查的数据集中产生的错误明显少于其他方法，平均减少40-50％的错误。Phred质量评分已被广泛接受用于表征DNA序列的质量，并且可用于比较不同测序方法的功效 。Phred在人类基因组计划中发挥了重要作用，自动脚本处理大量序列数据。它当时是学术和商业DNA测序实验室最广泛使用的碱基调用软件程序，因为它具有很高的碱基调用准确性。 ——wikipedia</p></blockquote><p>而<strong>solexa</strong>是一种基于边合成边测序的技术。通过单分子阵列实现小型阵列上的桥式PCR反应。新的阻断技术能够每次只合成一个碱基，经过激光激发之后得到激发光，对激发光进行分析得到碱基信息。</p><blockquote><p>早些年，人们在谈到新一代测序仪时，经常会提起Solexa，而不是Illumina。这是一家低调的公司，规模也不大，但是测序技术却非常新颖。它开发出的测序仪，在通量上领先于其他竞争产品。收购Solexa，也成为Illumina的转折点，从此踏上高速发展的道路。 ——生物通</p></blockquote><p><img src="/posts/67fa7a61/%E4%B8%8D%E5%90%8C%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B.jpg" alt="不同编码类型.jpg"></p><p>现在大部分都是用的Illumina 1.8+的<code>Phred+33</code>方式，也就是将质量值加上<code>33</code>，得到一个数值，再将这个数值按照上面的<code>ASCII</code>码表对应到特定的字符上去。</p><p>比如</p><table><thead><tr><th>Q值（质量值）</th><th>+33之后的值</th><th>对应的字符</th></tr></thead><tbody><tr><td>0</td><td>33</td><td>!</td></tr><tr><td>1</td><td>34</td><td>"</td></tr><tr><td>10</td><td>43</td><td>+</td></tr><tr><td>20</td><td>53</td><td>5</td></tr><tr><td>30</td><td>63</td><td>?</td></tr><tr><td>40</td><td>73</td><td>I</td></tr><tr><td>41</td><td>74</td><td>J</td></tr></tbody></table><p>为什么偏要<code>+33</code>，而不是<code>+11</code>啊！<code>+22</code>啊之类的？</p><p>你可以看看上面的<code>ASCII</code>码表，因为在<code>0~32</code>这个范围之内有很多奇形怪状的字符，同时还包含什么制表符、换行符、回车符、空格、响铃、退格等这类的看不见的字符。而很多时候质量值需要一是肉眼能方便查看；二是要方便程序读取。显然在<code>0-32</code>这个范围内不适合取。而从<code>33</code>开始直到<code>127</code>均为可见的字符。那从33开始取值不就的了，怎么又来个什么+64之类的？</p><p>谷歌了一下，暂时没有找到究竟+64的原因，但是在一篇博客《质量值体系 Phred33 和 Phred 64 的由来 及其在质量控制中的实际影响 - Part 1》中作者自己脑补的两者之间的关联。我觉得下面这句话可能可以说明一下作者脑补的内容：</p><blockquote><p>一流的企业做标准，二流的企业做品牌，三流的企业做产品</p></blockquote><p>就是当时测序公司有多家，互相之间相互竞争，各家公司是竞争对手，怎么可能你用什么我也用什么。所以我也要想出一定的标准，哈哈！后来的Solexa就不采用+33的方式（这个方式就是<code>Phred+33</code>的编码方式当时Sanger公司所采用的），而使用<strong>Solexa+64</strong>，其实+64也不是就是随便来的，可以再看一下上面的ASCII码对照表。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |         |         |         |         |</span><br><span class="line">   Quality score: 0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure><p><em>在质量值<code>0</code>对应的<code>@</code>之后，就是从英文大写字母<code>A</code>开始了，也就是质量值<code>1-26</code>对应编码字符<code>A-Z</code>了。这样人肉眼看的话其实质量值是相当直观了。不过在质量值到达<code>33</code>之后，又出现了小写字母…这个个人感觉就不如Phred+33那样的呢。</em></p><p>到后来2006年Solexa公司被Illumina公式收购，于是又有了Illumina 1.3+ Phred+64（这里是我自己脑补的- . -）。于是就有了Sanger公司的Phred+33的方式以及Illumina的Phred+64的方式。于是两家公司互相不让着谁。这可苦了当时编写生信数据分析的人，后来没办法只有在程序中加上自动判断的程序。</p><p>可是墨菲他老人家不高兴了（这里我不太了解墨菲和这个事件之间的联系），所以在 2011 年, Illumina 公司表示他们又要改成 Phred33 体系了 (<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fseqanswers.com%2Fforums%2Fshowthread.php%3Ft%3D8895%26page%3D4">Upcoming changes in CASAVA</a>)。这样来来回回还是回到了Phred+33的体系。</p><p>期间有意思的是，当时三巨头的另一家测序仪公司 454 Life Sciences (后被 Roche 收购) 就更绝, 人家从碱基开始就不用 ACTG 表示, 直接整了个 ColorSpace 体系出来, 根本不和你们玩，当然后来大家也不跟 454 玩了, 最后他也就没得玩了 。</p><p>这个是在网上别人得到的 ColorSpace数据：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SRR2967009.1 100_1000_1168_F3</span><br><span class="line">T10011023211201220121202030102221012302121010131001</span><br><span class="line">+</span><br><span class="line">2@@@@&gt;@?@@@@&lt;@@//;@@/@9?@8@=@@@6;6@66;&lt;@6@67?2?;/@</span><br><span class="line">@SRR2967009.2 100_1000_1211_F3</span><br><span class="line">T20132312201120021312220200023110220113100012321011</span><br><span class="line">+</span><br><span class="line">@@@@@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@?@@@@/?@@@@@@@@&lt;?@</span><br></pre></td></tr></tbody></table></figure><p>序列是用<code>double-encoded data</code>或者称<code>colorspace</code>的模式表示的。</p><p>按照手册的说明：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA, CC, GG, TT : 0</span><br><span class="line">AC, CA, GT, TG : 1</span><br><span class="line">AG, CT, GA, TC : 2</span><br><span class="line">AT, CG, GC, TA : 3</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Therefore five base long sequence <code>AACTA</code> will be represented as <code>0123</code>. The encoding is <code>AA=0</code>, <code>AC=1</code>, <code>CT=2</code>, and <code>TA=3</code>.</p></blockquote><p>额，感觉有些诡异。不过这样做应该有他的考虑，只是现在我不清楚。</p><h5 id="质量值的区别方法">质量值的区别方法</h5><ol><li><strong>肉眼查看</strong><br>通过Phred+33与Phred+64的区别，可以知道，<code>[0~9]</code>的为Phred33特有的质量字符，小写字母<code>[a~z]</code>的为Phred64特有的质量字符。</li><li><strong>程序判断</strong></li></ol><p>这个shell代码不知道出处是哪里，反正放在这里吧，如果有侵权，那我就删除了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fqtype</span></span> () {</span><br><span class="line">        less <span class="variable">$1</span> | <span class="built_in">head</span> -n 999 | awk <span class="string">'{if(NR%4==0) printf("%s",$0);}'</span> \</span><br><span class="line">        | <span class="built_in">od</span> -A n -t u1 -v \</span><br><span class="line">        | awk <span class="string">'BEGIN{min=100;max=0;}\</span></span><br><span class="line"><span class="string">        {for(i=1;i&lt;=NF;i++) {if($i&gt;max) max=$i; if($i&lt;min) min=$i;}}END\</span></span><br><span class="line"><span class="string">        {if(max&lt;=74 &amp;&amp; min&lt;59) print "Phred+33"; \</span></span><br><span class="line"><span class="string">        else if(max&gt;73 &amp;&amp; min&gt;=64) print "Phred+64"; \</span></span><br><span class="line"><span class="string">        else if(min&gt;=59 &amp;&amp; min&lt;64 &amp;&amp; max&gt;73) print "Solexa+64"; \</span></span><br><span class="line"><span class="string">        else print "Unknown score encoding"; \</span></span><br><span class="line"><span class="string">        print "( " min ", " max, ")";}'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>仿照上面的shell代码，我改成了Perl One-liners的版本。一般只需要取一部分序列进行计算就可以了，计算这个值还是挺快的。使用真实的fastq数据同样也很快，只需要接近0.05秒的时间。（😒你可能会说你看上面的<code>bash</code>脚本就这么几行就完事了，怎么用perl要写这么多！你之前应该也听说过perl有一句名言<code>事实的真相不止一个！</code>，如果把perl写成很<strong>单行</strong>的形式，估计不好看懂，这里是为了展示代码的转换时是个什么原理，而且代码如果是自己用，<strong>不要装逼到吓到自己</strong>！）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里实际上只取20行不够，真正的最好取上千条比较好(4000行)</span></span><br><span class="line"><span class="comment"># 因为有的时候测序质量很高，采样太少根本无法得到真正的上下限的值</span></span><br><span class="line"><span class="comment"># 这里是因为123.fastq.gz文件本身只有80行，所以只取了80行</span></span><br><span class="line"><span class="comment"># 为了方便使用，这里可以提前赋值一个变量，以后改行数的时候会比较方便</span></span><br><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 首先初始化两个用来判断质量值上下限的两个变量</span></span><br><span class="line"><span class="string">    $max = 0;    # 将最大值设置得精良小</span></span><br><span class="line"><span class="string">    $min = 1000; # 将最小值设置得尽量大</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 质量行在4的倍数行</span></span><br><span class="line"><span class="string">  if($. % 4 == 0){</span></span><br><span class="line"><span class="string">    # 去除回车符换行符</span></span><br><span class="line"><span class="string">    s/\r?\n$//;</span></span><br><span class="line"><span class="string">    my $word;</span></span><br><span class="line"><span class="string">    # 每次“吞”一个字符进行ASCII码值转换</span></span><br><span class="line"><span class="string">    while($word = chop($_)){</span></span><br><span class="line"><span class="string">      my $ascll_num = ord($word);</span></span><br><span class="line"><span class="string">      # 不断扩大min与max的范围，得到更加真实的上下限值</span></span><br><span class="line"><span class="string">      if($ascll_num &gt; $max){$max = $ascll_num;}</span></span><br><span class="line"><span class="string">      if($ascll_num &lt; $min){$min = $ascll_num;}</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 如果质量最大值低于75，最小值小于59，那么认为就是Phred+33类型</span></span><br><span class="line"><span class="string">    if($max &lt; 75 and $min &lt; 59){</span></span><br><span class="line"><span class="string">      print "Phred+33!\n";</span></span><br><span class="line"><span class="string">    }elsif($max &gt; 73 and $min &gt; 63){</span></span><br><span class="line"><span class="string">    # 如果质量最大值高于73，最小值高于63，那么认为就是Phred+64类型</span></span><br><span class="line"><span class="string">      print "Phred+64!\n";</span></span><br><span class="line"><span class="string">    }elsif($min &gt; 53 and $min &lt; 64 and $max &gt; 73){</span></span><br><span class="line"><span class="string">    # 如果最小值在58和64之间，最大值大于73，那就是Solexa+64类型</span></span><br><span class="line"><span class="string">      print "Solexa+64!\n";</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">    # 否则不知道类型</span></span><br><span class="line"><span class="string">      print "unkown!\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 打印出上下限信息</span></span><br><span class="line"><span class="string">    print "Max:$max\n";</span></span><br><span class="line"><span class="string">    print "Min:$min\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Phred+33!</span><br><span class="line">Max:74</span><br><span class="line">Min:35</span><br></pre></td></tr></tbody></table></figure><p>但是这里你觉得这样的步骤可不可以分解呢？</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [说明]：</span></span><br><span class="line"><span class="comment"># 这里不是炫技之类的，就是多使用其他linux工具进行搭配</span></span><br><span class="line"><span class="comment"># 减少perl中的那些判断的代码，让单行程序更加“单行”一些</span></span><br><span class="line"><span class="comment"># 让功能更加专一，便于代码重用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat 负责解压</span></span><br><span class="line"><span class="comment"># head 负责提取前面几行</span></span><br><span class="line"><span class="comment"># awk  负责排除其他行</span></span><br><span class="line"><span class="comment"># perl 负责得到上下限的值</span></span><br><span class="line"><span class="comment"># perl 负责对这个值进行判断并且得到质量类型</span></span><br><span class="line"></span><br><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 首先初始化两个用来判断质量值上下限的两个变量</span></span><br><span class="line"><span class="string">    $max = 0;    # 将最大值设置得尽量小</span></span><br><span class="line"><span class="string">    $min = 1000; # 将最小值设置得尽量大</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 去除回车符换行符</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  # 每次“吞”一个字符进行ASCII码值转换</span></span><br><span class="line"><span class="string">  while($word = chop($_)){</span></span><br><span class="line"><span class="string">    my $ascll_num = ord($word);</span></span><br><span class="line"><span class="string">    # 将上下限的值赋值给刚才的两个变量</span></span><br><span class="line"><span class="string">    if($ascll_num &gt; $max){$max = $ascll_num;}</span></span><br><span class="line"><span class="string">    if($ascll_num &lt; $min){$min = $ascll_num;}</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    print "$max:$min\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> | perl -n -a -F: -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    sub print_type {</span></span><br><span class="line"><span class="string">      my ($max,$min)=@_;</span></span><br><span class="line"><span class="string">      if($max &lt; 75 and $min &lt; 59){</span></span><br><span class="line"><span class="string">        return "Phred+33!\n";</span></span><br><span class="line"><span class="string">      }elsif($max &gt; 73 and $min &gt; 63){</span></span><br><span class="line"><span class="string">        return "Phred+64!\n";</span></span><br><span class="line"><span class="string">      }elsif($min &gt; 53 and $min &lt; 64 and $max &gt; 73){</span></span><br><span class="line"><span class="string">        return "Solexa+64!\n";</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        return "unkown!\n";</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  my ($max,$min) = @F;</span></span><br><span class="line"><span class="string">  print "Max:$max\n";</span></span><br><span class="line"><span class="string">  print "Min:$min\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-fastqc相关统计量">3. fastqc相关统计量</h3><h4 id="序列长度的分布">序列长度的分布</h4><p>这个统计序列长度就比统计fasta序列的长度简单一些啦！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先使用awk排除其他行</span></span><br><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $seq_len = length($_);</span></span><br><span class="line"><span class="string">  # 把序列长度以及为此长度的信息存入哈希中</span></span><br><span class="line"><span class="string">  $hash{$seq_len}++;</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "length\tcount\n";</span></span><br><span class="line"><span class="string">    for my $len (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$len\t$hash{$len}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length  count</span><br><span class="line">89      1</span><br><span class="line">90      18</span><br><span class="line">91      1</span><br></pre></td></tr></tbody></table></figure><p>也可以重定向到文件中，拿这个文件可以使用R来画图。</p><p>同样的你也可以写成：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if($. % 4 == 2){</span></span><br><span class="line"><span class="string">    s/\r?\n$//;</span></span><br><span class="line"><span class="string">    my $seq_len = length($_);</span></span><br><span class="line"><span class="string">    # 把序列长度以及为此长度的信息存入哈希中</span></span><br><span class="line"><span class="string">    $hash{$seq_len}++;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "length\tcount\n";</span></span><br><span class="line"><span class="string">    # 按照长度进行排序</span></span><br><span class="line"><span class="string">    for my $len (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$len\t$hash{$len}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>实际上上面的方法比下面的要慢一些，但是上面的程序将perl所承担的任务量减少了，所以代码量看起来少了一些。有的时候不能兼得，每项需要均衡一下。</p><hr><blockquote><p><strong>放松时间</strong></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|_・) |ω・） |･ω･｀) (╯ε╰) ^.^ (๑￫ܫ￩) ←_← (╯ε╰) ^.^ (๑￫ܫ￩) ←_← (╯ε╰) ^.^ (๑￫ܫ￩) ←_← ﾍ(･_|</span><br></pre></td></tr></tbody></table></figure><p>最近听了一下<code>重阳世界观-狂点技能树(1)</code>，和大家分享一下，里面说到：</p><blockquote><p>在兵马俑坑，出土最多的青铜兵器是箭头，考古人员发现了4万多支箭头，是三棱型的。制作的非常规范，箭头底部宽度的误差为0.83毫米，而且金属配比基本上是相同的。</p><p><strong>为什么选择这种三棱形状的箭头呢？</strong></p><p>三棱箭头拥有三个锋利的棱角，在击中目标的瞬间，棱的锋刃处就会形成切割力，箭头就能够穿透铠甲，直达人体。同时这三个面是呈流线型的，据说这个流线型的轮廓和子弹的外形都一致。按照现在话来说，有一个好的空气动力学的特性。除了三棱型的箭矢，还有什么狼牙箭——带倒钩和翼面的。但翼面容易受风的影响，使箭头偏离目标。</p><p>武器有很多个维度，如果只追求单一的维度，那么这个武器不会太好，就说这样一个小小的箭头啊！制作工艺简单，标准化，那样才能大量生产；如果太复杂，成本太高，不能大量装备；另外如果只盲目追求杀伤力，打不准那也不行。</p></blockquote><p><img src="/posts/67fa7a61/%E4%B8%89%E6%A3%B1%E7%AE%AD%E5%A4%B4.jpg" alt="三棱箭头"></p><p>三棱箭头.jpg</p><p><img src="/posts/67fa7a61/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E7%AE%AD%E5%A4%B4.jpg" alt="各种各样的箭头"></p><p>各种各样的箭头.jpg</p></blockquote><hr><h4 id="每个位置上质量值的分布">每个位置上质量值的分布</h4><p>其实在fastQC软件之中就对这个做了一个很好的诠释，这里我用<code>Perl</code>代码+<code>R</code>代码尝试实现这种每个位置上的碱基质量分布：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 先声明一个质量值转换的子程序</span></span><br><span class="line"><span class="string">    sub convert_quality_to_score{</span></span><br><span class="line"><span class="string">      my $ascll = shift;</span></span><br><span class="line"><span class="string">      # 这里我默认使用Phred+33</span></span><br><span class="line"><span class="string">      return ord($ascll) - 33;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 只需要每个单位的第四行</span></span><br><span class="line"><span class="string">  if($. % 4 == 0){</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    my $n = 0;</span></span><br><span class="line"><span class="string">    while($_){</span></span><br><span class="line"><span class="string">      $n++;</span></span><br><span class="line"><span class="string">      my $quality_score = substr($_,0,1,"");</span></span><br><span class="line"><span class="string">      # 将碱基推到对应的位置的哈西中</span></span><br><span class="line"><span class="string">      push @{$hash{$n}},convert_quality_to_score($quality_score);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    my @list;</span></span><br><span class="line"><span class="string">    # 设置列表内插之后打印元素的分隔符</span></span><br><span class="line"><span class="string">    $" = ",";</span></span><br><span class="line"><span class="string">    for my $base_site (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      # 按照R语言的方式写入信息</span></span><br><span class="line"><span class="string">      print "c_${base_site} &lt;- c(@{$hash{$base_site}})\n";</span></span><br><span class="line"><span class="string">      push @list,"c_${base_site}";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 写入执行箱线图的boxplot</span></span><br><span class="line"><span class="string">    print "boxplot(@list)\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> &gt; statistic_base_quality.R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开命令行的R</span></span><br><span class="line"><span class="comment"># 这一步windows需要安装一下R，并且设置环境变量</span></span><br><span class="line">R</span><br><span class="line"><span class="comment"># 执行R脚本</span></span><br><span class="line"><span class="built_in">source</span>(<span class="string">"statistic_base_quality.R"</span>)</span><br></pre></td></tr></tbody></table></figure><p>就会得到如下的类似的箱线图，比较简陋啊，但是也算是有一种实现方式了，但是fastQC内部的实现机制是什么我现在还不知道。不过我感觉按照我这么写测序文件小可以用，大了估计不一定好使。</p><p><img src="/posts/67fa7a61/%E7%A2%B1%E5%9F%BA%E8%B4%A8%E9%87%8F%E7%9A%84%E7%AE%B1%E7%BA%BF%E5%9B%BE.jpg" alt="碱基质量的箱线图"></p><p>刚才在服务器上试了一下，发现这个运行的时间有点长…到时候运行估计会把R给卡死。算了！就当我这个例子没有举过v_v。</p><h4 id="N值的统计">N值的统计</h4><p>其实这个统计与之前的统计序列长度类似：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $n = 0;</span></span><br><span class="line"><span class="string">  while($word = substr($_,0,1,"")){</span></span><br><span class="line"><span class="string">    $n++;</span></span><br><span class="line"><span class="string">    $hash{$n}++ if uc($word) eq "N";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "site\tcount\n";</span></span><br><span class="line"><span class="string">    for my $site (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$site\t$hash{$site}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>这个文件也可以重定向生成tsv文件，之后可以用R语言读取画图</p><h2 id="格式转换">格式转换</h2><h3 id="1-fastq转换为fasta">1. fastq转换为fasta</h3><p>网上一般使用的是<code>perl</code>的<code>Bio::Perl</code>模块来进行处理，其实这里不使用模块也可以进行转换。</p><h4 id="普通转换">普通转换</h4><p>将第一行作为titie，第二行作为序列组成fasta文件，如果想要将序列分割，那么请看我之前的文章<code>perl 命令行实战1 - fasta文件的相关操作</code>，只需要用一个管道操作符将不同perl的小的单行程序连起来就可以了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==1{print};NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $title =~ tr/@: /&gt;_-/;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="也可以把质量值保留下来">也可以把质量值保留下来</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4!=3{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $title =~ tr/@: /&gt;_-/;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">  # 将质量值信息追加到文件中</span></span><br><span class="line"><span class="string">  open FILE,"&gt;&gt;","123.fasta.quality" or die $!;</span></span><br><span class="line"><span class="string">  print FILE "$title\n$quality\n";</span></span><br><span class="line"><span class="string">  close FILE;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>而这个fasta序列你可以用重定向的方式输出到文件中去或者进入管道继续处理</p><h4 id="特殊转换">特殊转换</h4><p>有的时候有些软件需要fasta的文件名比较特殊，比如<code>&gt;infile_0/1/0_1234</code>，这样的之类的，<br>一般后面的1234是按照当前顺序第几条序列。这样其实也好办</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我就不保存质量值了。</span></span><br><span class="line"><span class="comment"># title可以直接不要</span></span><br><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  # 变量内插一下就完事儿了</span></span><br><span class="line"><span class="string">  my $title = "&gt;infile_0/1/0_$n";</span></span><br><span class="line"><span class="string">  (my $sequence = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="质量编码标准的转换">质量编码标准的转换</h2><h3 id="0-首先要确定质量值编码方式">0. 首先要确定质量值编码方式</h3><p>如果不知道质量值的编码方式胡乱的转可能会出问题！或者要么写一个脚本先自动判断质量值类型，然后再转换。</p><p>可以先按照<code>2.2 质量值的类型</code>这一步进行测试，或者已知质量值，然后再进行转换。</p><p>现在手头上没有相应的文件，只能说在这里写一下代码吧</p><h3 id="1-Phred-64转换为Phred-33">1. Phred+64转换为Phred+33</h3><p><strong>思路</strong>：+64变成+33，怎么办呢？减去32？试一下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    sub convert_64_to_33 {</span></span><br><span class="line"><span class="string">      my $word = shift;</span></span><br><span class="line"><span class="string">      return chr(ord($word) - 32);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print $_;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $title2   = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $quality_new;</span></span><br><span class="line"><span class="string">  while($word = chop($quality)){</span></span><br><span class="line"><span class="string">    $quality_new = convert_64_to_33($word) . $quality_new;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print "$sequence\n";</span></span><br><span class="line"><span class="string">  print "$title2\n";</span></span><br><span class="line"><span class="string">  print "$quality_new\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>你也可以把<code>chr(ord($word) - 32);</code>这一句话改为<code>chr(ord($word) + 32);</code>，你觉得应该变成什么功能呢？</p><h3 id="2-Solexa-64转换为Phred-33">2. Solexa+64转换为Phred+33</h3><p><strong>思路</strong>：由于Solexa的质量值计算方式与Phred方式不同，所以需要对质量值计算标准做一个转换。这里参考了<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fclub.topsage.com%2Fthread-2229946-1-1.html">Perl中FastQ与FastA格式的相互转换</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 下面的算法参考自博文《Perl中FastQ与FastA格式的相互转换》，在这里还是说明一下</span></span><br><span class="line"><span class="string">    my @conv_table;</span></span><br><span class="line"><span class="string">    for (-64..64) {</span></span><br><span class="line"><span class="string">      $conv_table[$_+64] = chr(int(33 + 10*log(1+10**($_/10.0))/log(10)+0.499));</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub convert_Solexa64_to_Phred33{</span></span><br><span class="line"><span class="string">      my $word = shift;</span></span><br><span class="line"><span class="string">      return $conv_table[ord($word)];</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print $_;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $title2   = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $quality_new;</span></span><br><span class="line"><span class="string">  while($word = chop($quality)){</span></span><br><span class="line"><span class="string">    $quality_new = convert_Solexa64_to_Phred33($word) . $quality_new;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print "$sequence\n";</span></span><br><span class="line"><span class="string">  print "$title2\n";</span></span><br><span class="line"><span class="string">  print "$quality_new\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="筛选fastq文件的序列">筛选fastq文件的序列</h2><h3 id="1-按照长度进行筛选">1. 按照长度进行筛选</h3><p>长度筛选类似于fasta文件的长度筛选，而且还简单一些</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上限</span></span><br><span class="line"><span class="built_in">export</span> upper_limit=89</span><br><span class="line"><span class="comment"># 下限</span></span><br><span class="line"><span class="built_in">export</span> lower_limit=89</span><br><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 将每一行末尾的回车符换行符去掉</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # %ENV是用来存周围环境中的变量</span></span><br><span class="line"><span class="string">  if(length($sequence)&gt;=$ENV{lower_limit} &amp;&amp; length($sequence)&lt;=$ENV{upper_limit}){</span></span><br><span class="line"><span class="string">    print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATC</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9??FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br></pre></td></tr></tbody></table></figure><h3 id="2-按照GC含量进行筛选">2. 按照GC含量进行筛选</h3><p>按照GC含量的筛选可以按照之前的fasta文件的筛选形式来，而且这个更加简单</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">      # 首先可以定义一个求序列GC含量的子程序</span></span><br><span class="line"><span class="string">      # 这个子程序在之前的fasta文件操作中就已经写过一次了</span></span><br><span class="line"><span class="string">      sub statistic_GC_base{ # 统计序列的GC含量和数量</span></span><br><span class="line"><span class="string">          my $sequence = shift;</span></span><br><span class="line"><span class="string">          my $len      = length($sequence);</span></span><br><span class="line"><span class="string">          my $num      = ($sequence =~ tr/GCgc/GCgc/);</span></span><br><span class="line"><span class="string">          my $GC       = sprintf("%.2f",$num * 100 / $len); # 返回的是百分数（不带百分号）</span></span><br><span class="line"><span class="string">          return $GC;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      # 先定义一个GC含量的限制</span></span><br><span class="line"><span class="string">      $GC_upper_limit = 50;</span></span><br><span class="line"><span class="string">      $GC_lower_limit = 40;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # 比如我这里限制GC含量为50%，小于这个值才能通过</span></span><br><span class="line"><span class="string">  my $GC_percent = statistic_GC_base($sequence);</span></span><br><span class="line"><span class="string">  if($GC_percent &lt;=  $GC_upper_limit and $GC_percent &gt;= $GC_lower_limit){</span></span><br><span class="line"><span class="string">      print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> </span><br></pre></td></tr></tbody></table></figure><p>说实话可能对于fastq文件进行GC含量的筛选可能意义不大，因为本来序列准确度不一定。有些看起来含量在合适的范围内但是很可能因为测序错误导致的，这里只是说提供了一种思路。</p><h3 id="3-按照质量值筛选">3. 按照质量值筛选</h3><h4 id="截断">截断</h4><p>把read的两端的序列按照一定原则进行截断得到质量高的序列</p><h5 id="截断两端一定的长度">截断两端一定的长度</h5><p>我觉得这种截取的方式太过于笼统，容易丢失一些信息，然后也可能容纳一些错误信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> left_len=10</span><br><span class="line"><span class="built_in">export</span> right_len=20</span><br><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  substr($sequence,0,$ENV{left_len},"");</span></span><br><span class="line"><span class="string">  substr($quality,0,$ENV{left_len},"");</span></span><br><span class="line"><span class="string">  substr($sequence,0-$ENV{right_len},$ENV{right_len},"");</span></span><br><span class="line"><span class="string">  substr($quality,0-$ENV{right_len},$ENV{right_len},"");</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>再加上上面的长度分布统计的代码之后</p><p>输出为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length  count</span><br><span class="line">59      1</span><br><span class="line">60      18</span><br><span class="line">61      1</span><br></pre></td></tr></tbody></table></figure><h5 id="根据质量值进行截断">根据质量值进行截断</h5><p>如果从右往左边数，碱基错误率低于20，那么截断它，即使在错误与错误之间有单个质量值高的碱基：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 新建一个子程序来判断质量值</span></span><br><span class="line"><span class="string">    sub whether_bloew_20 {</span></span><br><span class="line"><span class="string">      my $word =shift;</span></span><br><span class="line"><span class="string">      # 这里我默认是Phred+33的模式</span></span><br><span class="line"><span class="string">      if(ord($word)-33&lt;20){</span></span><br><span class="line"><span class="string">        return undef;</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 新建检查两端需要截断长度的子程序</span></span><br><span class="line"><span class="string">    sub side_cut_off {</span></span><br><span class="line"><span class="string">      my $sequence = shift;</span></span><br><span class="line"><span class="string">      my $direction = shift; # 查看的方向</span></span><br><span class="line"><span class="string">      my $increase_num;</span></span><br><span class="line"><span class="string">      if($direction eq "left"){</span></span><br><span class="line"><span class="string">        $increase_num = 1;</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        $increase_num = -1;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      my $num = int(- 0.5 + $increase_num); # 记录目前查看碱基的位置</span></span><br><span class="line"><span class="string">      my $error_base; # 统计不达标碱基的数量</span></span><br><span class="line"><span class="string">      my $right_base; # 统计达标碱基的数量</span></span><br><span class="line"><span class="string">      my $word;</span></span><br><span class="line"><span class="string">      while($word = substr($sequence,$num,1)){</span></span><br><span class="line"><span class="string">        # 如果达标的碱基连续达到5个，那么就结束检测</span></span><br><span class="line"><span class="string">        if($right_base &gt;= 5){</span></span><br><span class="line"><span class="string">          return $num;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        $num += $increase_num;</span></span><br><span class="line"><span class="string">        if(whether_bloew_20($word)){</span></span><br><span class="line"><span class="string">          $right_base++;</span></span><br><span class="line"><span class="string">        }else{</span></span><br><span class="line"><span class="string">          $right_base = 0;</span></span><br><span class="line"><span class="string">          $error_base++;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      # 说明这条read没救了</span></span><br><span class="line"><span class="string">      return undef;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # 检查左边</span></span><br><span class="line"><span class="string">  my $left_trim = side_cut_off($sequence,"left");</span></span><br><span class="line"><span class="string">  # 然后检查右边</span></span><br><span class="line"><span class="string">  my $right_trim = abs(side_cut_off($sequence,"right") + 1);</span></span><br><span class="line"><span class="string">  # 如果序列没救了就直接跳过</span></span><br><span class="line"><span class="string">  unless($left_trim){</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 去掉低质量</span></span><br><span class="line"><span class="string">  substr($sequence,-$right_trim,$right_trim,"");</span></span><br><span class="line"><span class="string">  substr($quality,-$right_trim,$right_trim,"");</span></span><br><span class="line"><span class="string">  substr($sequence,0,$left_trim,"");</span></span><br><span class="line"><span class="string">  substr($quality,0,$left_trim,"");</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">'</span> </span><br></pre></td></tr></tbody></table></figure><p>性能怎么样现在还不知道，只是说这里提供了一种思路。</p><h4 id="直接丢弃">直接丢弃</h4><p>如果read的质量值或者长度不符合条件那么直接将其舍弃。</p><p>参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.drive5.com%2Fusearch%2Fmanual%2Fexp_errs.html">Expected errors predicted by Phred (Q) scores</a></p><p>也就说这里我们用E值来对read进行筛选：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 将Q值转换为P值</span></span><br><span class="line"><span class="string">    sub Q_to_P {</span></span><br><span class="line"><span class="string">      my $q_value = shift;</span></span><br><span class="line"><span class="string">      my $p_value = 1/(10**($q_value/10));</span></span><br><span class="line"><span class="string">      return $p_value;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub convert_quality_to_score{</span></span><br><span class="line"><span class="string">      my $ascll = shift;</span></span><br><span class="line"><span class="string">      # 这里我默认使用Phred+33</span></span><br><span class="line"><span class="string">      return ord($ascll) - 33;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $total = 0;</span></span><br><span class="line"><span class="string">  my $site = 0;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  while($word = substr($quality,$site,1)){</span></span><br><span class="line"><span class="string">    $site++;</span></span><br><span class="line"><span class="string">    $total += Q_to_P(convert_quality_to_score($word));</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  $total = int($total);</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 如果有10以上的碱基可能错误，那么就丢弃这个read</span></span><br><span class="line"><span class="string">  if($total &lt;= 10){</span></span><br><span class="line"><span class="string">    print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-按照相关性筛选">4. 按照相关性筛选</h3><h4 id="含有某段特定的序列">含有某段特定的序列</h4><p>这里可以使用<code>grep</code>或者<code>perl</code>的正则表达式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | grep <span class="string">"ATGG"</span></span><br></pre></td></tr></tbody></table></figure><p>这个是简单的写法，也可以利用正则表达式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/ATG\w+T(AA|AG|GA)/){</span></span><br><span class="line"><span class="string">    print;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>也可以着色：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/ATG\w+T(AA|AG|GA)/){</span></span><br><span class="line"><span class="string">    print;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> | grep <span class="string">'ATG'</span> --color=always</span><br></pre></td></tr></tbody></table></figure><h4 id="与某些序列能比对上的">与某些序列能比对上的</h4><p>这里实际上不能只使用perl语言，还需要搭配其他工具，这里先不写，占个位。以后补起来。</p><p>其实除了筛选这些序列以及质量值之外，还有第一行有很多信息也可供筛选，比如将哪些tail的序列筛选出来，去除哪个tail中的对应位置的序列等等。</p><h2 id="检查">检查</h2><h3 id="1-检查fastq文件">1. 检查fastq文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pigz -d -c 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    chomp(my $title = $_);</span></span><br><span class="line"><span class="string">    chomp(my $seq = &lt;&gt;);</span></span><br><span class="line"><span class="string">    &lt;&gt;;</span></span><br><span class="line"><span class="string">    chomp(my $quality = &lt;&gt;);</span></span><br><span class="line"><span class="string">    if(length($seq) != length($quality)){</span></span><br><span class="line"><span class="string">        print $. - 3 . "lines &lt;$title&gt; is error.\n";</span></span><br><span class="line"><span class="string">        print "You can use\n\n    cat *.fastq | head -n " . $. - 4 . "\n\n get the available reads!";</span></span><br><span class="line"><span class="string">        exit;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-修复">2. 修复</h3><p>后续添加进来</p><h2 id="组合起来！">组合起来！</h2><p>上面的每一步单独的步骤前后用管道连接起来就可以连续完成多个工作啦！</p><p>例如</p><ul><li>想得到一部分质量稍高的几条read</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> | 按照长度筛选 | 按照质量值筛选 | 将序列转换为fasta序列</span><br></pre></td></tr></tbody></table></figure><ul><li>大致统计一下20000条read的长度分布</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> -n 80000 | 将序列转换为fasta序列 | 统计每一条序列的长度</span><br></pre></td></tr></tbody></table></figure><ul><li>统计20000条质量稍高的read的GC含量</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> -n 80000 | 按照质量值筛选 | 将序列转换为fasta序列 | 统计GC含量分布</span><br></pre></td></tr></tbody></table></figure><p>除此之外还有别的组合，按照自己的需要来，上面的步骤中部分用到了之前的fasta文件的相关操作。</p><h2 id="有意思的">有意思的</h2><p>参考自<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnblogs.com%2Fyahengwang%2Fp%2F8973948.html">青蛙快飞</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $quality =~ tr{!"#$%&amp;'</span>()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKL}{▁▁▁▁▁▁▁▁▂▂▂▂▂▃▃▃▃▃▄▄▄▄▄▅▅▅▅▅▆▆▆▆▆▇▇▇▇▇██████};</span><br><span class="line">  <span class="built_in">print</span> <span class="string">"<span class="variable">$title</span>\n<span class="variable">$sequence</span>\n<span class="variable">$comment</span>\n<span class="variable">$quality</span>\n"</span>;</span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="测试数据">测试数据</h2><p>因为数据量太大，对于本次的实战演练耗时较长，所以我取了80行的fastq的信息来作为测试用。</p><ol><li><p>新建文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq</span><br></pre></td></tr></tbody></table></figure><ul><li>在windows下新建方法，<code>右键</code> - <code>新建</code> - <code>文本文档</code> - 改名为<code>123.fastq</code></li><li>在linux、mac等命令行中新建的方法，打开<code>shell</code> - 输入<code>echo -n 123.fastq</code></li></ul></li><li><p>加入数据，将下面的测序数据拷贝到</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq</span><br></pre></td></tr></tbody></table></figure><p>文件中</p><ul><li>在windows下，用<code>记事本</code>打开，拷贝下面的数据然后保存。</li><li>在命令行中，那就先<code>vim 123.fastq</code>，打开文件，然后按<code>a</code>进入编辑模式，将下面的数据拷贝到里面。然后按下<code>Esc</code>，输入<code>:wq</code>，按下<code>Enter</code>保存。</li></ul></li><li><p>压缩为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq.gz</span><br></pre></td></tr></tbody></table></figure><ul><li>打开<code>git for windows</code>或者<code>shell</code>，输入<code>gzip 123.fastq</code>。</li></ul></li></ol><p>将下面的数据拷贝到<br>数据：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATC</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9??FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br><span class="line">@SRR2177462.2 FCC600JACXX:2:1101:1661:2085/1</span><br><span class="line">NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">+</span><br><span class="line">#4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br><span class="line">@SRR2177462.3 FCC600JACXX:2:1101:1683:2113/1</span><br><span class="line">GCGACCTCGCGGGCGAAGCCCATCTCGTGGGTGACGCAGATCATCGTCATGCCCTCGGCGGCGAGGCCTTTCCTGACGGCGGGGACCTCC</span><br><span class="line">+</span><br><span class="line">@@@BDDDDFHDDA:DDBHH@F6=DCEHHHFE6&gt;;;?86?BC:ACCC@98?########################################</span><br><span class="line">@SRR2177462.4 FCC600JACXX:2:1101:1730:2127/1</span><br><span class="line">TTTGTCCACTTCCTCCACTTCGTCAACTTCGTCCACTTCGTCCACTTCCTCAACTTCGTCAACTTCGTCCACTTCGTCAACTTCGTCCAC</span><br><span class="line">+</span><br><span class="line">BBCFFFFFHHHHHHJJJJIJIIJJEIHHHGIJHIJJIIGGIGGIJGHDFHC4BBCGC@G;(;CEGEEH??@DCFD?CC=&gt;CDDDDDD??D</span><br><span class="line">@SRR2177462.5 FCC600JACXX:2:1101:1663:2160/1</span><br><span class="line">ACAAAAAGCACAGAGAAGCATTGAGAATGGGGGATTTTGGAGAGCTCCAGGGGGACCTTCATCTTCACTGGATCATCATCCATTGCCAAG</span><br><span class="line">+</span><br><span class="line">@BCFFFFFFHHFHGHIJJHGHIIFHGCHIJJJJBHGIJHGHGGGIHFHFHCGIHBCDECCCDDDDCDCCDBCDCB&gt;CC@CCDDEDDCCDD</span><br><span class="line">@SRR2177462.6 FCC600JACXX:2:1101:1555:2174/1</span><br><span class="line">CACAATTGGTGAGTTCTAACGTTAGCATTATTGGTTTGAAAGTATATATGGAACACTTATACCTAGAACTATCGTTTTTGTCATTATTAA</span><br><span class="line">+</span><br><span class="line">@@@FFFFDHAFFFFBEGGIIIFHDGHEDHIII&gt;FFHHIGGGGBFHGIIIGHECBGDGHGGCAG@G==FCF=FAC=@ACE/6?BEFDCCB@</span><br><span class="line">@SRR2177462.7 FCC600JACXX:2:1101:1561:2201/1</span><br><span class="line">TCTCCTTTAGCATCAAACCCTCCGTTGGAATAACCCAACAACCATACATACATTCATAGAGAAAACCCAACACAAATATTACATAAACCT</span><br><span class="line">+</span><br><span class="line">@@@BDDDA&lt;?ADF@DHGGCD9:A@AGE??EC?9:???BFHI)8BFEFIIG8=CHG)=FA@4@GEGII;AABDEB;;@CDC&gt;CCDCCCC5?</span><br><span class="line">@SRR2177462.8 FCC600JACXX:2:1101:1676:2217/1</span><br><span class="line">GCTAGTTCCTAACAGAACTCGAGGTAACAGTCCAAGGGATTGAAAAAACACAAGCTGATGTTCGTCGAAGTAATACAACAAGAAGGAGAC</span><br><span class="line">+</span><br><span class="line">@CCFFFFFFHHDDBHIIGI?E@GHCGHGGGHIB&gt;DECEBBFCABEDGGEECHIGGGACHG;@AEE?DBBB5&gt;CADA&gt;(;99&lt;CCCB9?A@</span><br><span class="line">@SRR2177462.9 FCC600JACXX:2:1101:1700:2228/1</span><br><span class="line">CAAAACACTTCAATAGCATGTTCTAAAAGGACTGCTTTAAAAATCTTCTACAAATCTCACATGTTTCAAACTAGATTTTGAAGCAATAAA</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHFFIIJIIGIIIDHJJJIHJEHIIHIIIFHHIEHIIIIJGGHEHFGIJIIJIJHIJJBFHJIJJIHIJJJEEEEFFFFFF</span><br><span class="line">@SRR2177462.10 FCC600JACXX:2:1101:1962:2055/1</span><br><span class="line">NTTATGTGATGTGAATGATTATGTATAATTGTATGAAACTTAGTAAATTAATATATGATTAATCTTGTTTAAACTAGCTTATCCTATTGT</span><br><span class="line">+</span><br><span class="line">#4=BDFDFFHHHHGIIJHJJGJJJIIIHHJJIIIIHIJJIJGHHGIJIJHIJJJIJJJJJIIIJJJJIJJHHGIIJIJJJIIGJJHJJJJ</span><br><span class="line">@SRR2177462.11 FCC600JACXX:2:1101:1774:2118/1</span><br><span class="line">CACCAAGACGCTACCTAAGGATAGATTTTTTGAGCTTAGAAGAGAGTTAGGAGTATTAGACATGTCTTAGGATCAACGATTATGAAAATTT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIGIGGGHEHEHHIJJJJJJ?GGHIGIIJGGIHIGIIJDFH7@EHIIGHHGHAHHFDEFFCEE&gt;CC=ABDDDCDDDDCD</span><br><span class="line">@SRR2177462.12 FCC600JACXX:2:1101:1931:2123/1</span><br><span class="line">CAGCTTTTTGTGGTTTGCAAGGAAACTGAGCAGAAATATGAACCACATGTGACAACAAAAAAATTAGGAAGCTGTCTGTGAATTATTATT</span><br><span class="line">+</span><br><span class="line">@@@DFFFFHHFFHGIJIGGEHIBGHIJIDHHJJFIEIIJJJGHIIGIIFGHGIIJJIIJIJIHFDF=D&gt;CEDEECCACCC&gt;AFDDEACDD</span><br><span class="line">@SRR2177462.13 FCC600JACXX:2:1101:1759:2210/1</span><br><span class="line">AATAAATGTGAAAATGGCAATAATAACAAACCTGCTGCAATTATACTTGTTATCTTTATCCAAGATTTCAGGTGCAGTAAATTGTCCCAG</span><br><span class="line">+</span><br><span class="line">@CCFFFFFHHGGHIJJJJJJJIEIJJIIJJJJJJJJJJIJJJJJJJJJJIIIIIJJJIJJGJIJIJJIJGJJHIJHIIJIGHHHHHGEEF</span><br><span class="line">@SRR2177462.14 FCC600JACXX:2:1101:1922:2245/1</span><br><span class="line">TATCATTAAACAAACATGCACATTGCTTAAGAAACATAAAACTTCCACTGAAACAATTTATAAGATTGCACCAGATTTATTCCTTTTTGT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHGHIJJJJJJJJJJJJJJIIJJJJJJJJJJJJIIJHIJIJHJIJJJJJJGIJJJJJJJJIJIJJADHIHHHHHHHFFFFE</span><br><span class="line">@SRR2177462.15 FCC600JACXX:2:1101:2088:2085/1</span><br><span class="line">NATGACGTATATTAAGTGTTGAAGATGAAGACATATGTGGTTGGTTTGTTTATGTGTATTTCTCTCTCTGTGCTTCGTTTATGCTTCATT</span><br><span class="line">+</span><br><span class="line">#1=DDFFDHHHHHIIJGHJJJIIHIGIHGHHHIJIIIHIIFHIJ?GHIGHIBHGICBAHEIHIIJJIJJIJJIIJJHHFFFFFFFEDDEE</span><br><span class="line">@SRR2177462.16 FCC600JACXX:2:1101:2166:2127/1</span><br><span class="line">TGGAGGAAGTGGAGGAAGTGGAGGAAGTTGACGAAGTGGACGAAGTGGAGGAAGTGGACGAAGTGGAAGAAGTGGACGAAGTGGAGGAAG</span><br><span class="line">+</span><br><span class="line">@CCFFFDFHDFHHHJGGIEEHBHIIJJIAGGHIEHI8DHDHGGFH;CGAEE;DGECHC)99&gt;A###########################</span><br><span class="line">@SRR2177462.17 FCC600JACXX:2:1101:2243:2189/1</span><br><span class="line">CTTGTCAGAACCCATTCAAAACCACTAAAAACCCCTGCATAGTGGAAGCCAAATGTTAAGGAAGAGAGCTGGAAATCAGAGAGTGGAAAA</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIJJGIJJJIJJIJJJJJJJJIJJJJJJJJIJJDHHHIGIIIJIII@GIIJIJJIHFHHFFFF@EDEEEEDACD@@AC</span><br><span class="line">@SRR2177462.18 FCC600JACXX:2:1101:2145:2249/1</span><br><span class="line">AATATTTGATCAATAGATTTTATGATAAATATAAACATACAGTAGAATTTTAAAAAACAAGGAATTTAGCTACCAAAAACAAGCTATGAG</span><br><span class="line">+</span><br><span class="line">&lt;&lt;@AABDD&gt;HHFBFH@EHIHIADHIEGEHIHDAEHH&lt;FFGBFEGDFHIIHGA&gt;BGB@FFFEDCGGHIGIIEG@DECCHHGFDC?C@EEEE</span><br><span class="line">@SRR2177462.19 FCC600JACXX:2:1101:2366:2232/1</span><br><span class="line">TACTGAACTTCTTCAAGAATTTGATCAACCCAGGAACCTATTGCAATGTCTCAATCATAGGAACTTTAATCTCCAATTTCTTGAAGATTT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIJJJJJJJJJJJJJJJJJJJJIJJJJJJJJJJGHJIJJJJHIJDHIJJGIJJJJIHIGIIIIGIGHGHHHEEFDFFF</span><br><span class="line">@SRR2177462.20 FCC600JACXX:2:1101:2455:2241/1</span><br><span class="line">CACGGATCTGCAGAATAGCACCAAAGCTGGAGCTATCACTTTACTTCGTCAACTTCGTCCACTTCCTCCATTTCTTCCACTTCCTCCACT</span><br><span class="line">+</span><br><span class="line">@@CFFDFFHHGGGIJJJJJJJJJJJJIJJJHIJIJJJJJIJJGJJJGGHIIJIIEEHGHEIIIJIHHHEEHFDEFBDBCE&gt;&gt;ACCDCCDC</span><br></pre></td></tr></tbody></table></figure><h2 id="后记">后记</h2><p>其实现在有很多软件可以处理fastq文件，比如<code>FASTX-Toolkit</code>、<code>seqkit</code>、<code>FaQCs</code>、<code>fastqc</code>、<code>fastp</code>、<code>Reseqtools</code>等等，也不需要perl写几行脚本来处理。那这个还有什么意思呢？</p><p>你要是读了之后，你会发现在文中我提到了有关代码重用的问题，实际上在处理这类文件的时候有些东西是相通的，你可以在这个文本里面中会看到之前我在操作fasta文件的时候用到的代码。而把这些代码拿到这里来用照样可以达到目的。这个过程就有点像搭积木，积木的基本形状也就那几种，什么正方体、长方体、直角等腰三角形、圆柱等灯，可是不同的搭配、不同布局搭起来的东西就不一样了。当我们把这种单一的，完成某种独立功能的代码组合起来之后就会由一块一块的积木搭建起整个城堡，迎接你的公主！</p><p>除了代码之外，在文中也说明了有关质量值编码的问题，话说现在都是采用的Phred+33的编码方式了，那还提那些陈年旧事有什么意思了？有的时候我也在想在课本中提到的那些年代久远的故事究竟有什么作用呢？比如生化书上面的那些经典的比如三羧酸循环，那些都是几十年前就已经搞很清楚的事情为什么还要提呢？ 我觉得仁者见仁智者见智吧！可能我有点怀旧吧！</p><h2 id="参考">参考</h2><ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fyahengwang%2Fp%2F8973948.html">FASTQ文件格式</a> - 说明fastq的格式</li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fluo617%2Farticle%2Fdetails%2F81220829">fastq fasta 序列数快速统计</a> - pigz的使用</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.biotrainee.com%2Fthread-2072-1-1.html">一行脚本判断你的fastq测序数据的质量编码方式-ydchen</a> - 质量值的类型判断</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.sciencenet.cn%2Fblog-630246-813262.html">Fastq 格式说明 &amp; (Phred33 or Phred64) - 揭文才</a> - 编码类型的说明</li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav23077195%3Ffrom%3Dsearch%26seid%3D15283415322892062157">陈巍学基因 - Hiseq测序仪工作原理</a> - 测序原理与质量值</li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPhred_base_calling">Phred base calling</a> - phred</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.phrap.com%2Fphred%2F">phred</a> - phred</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ebiotrade.com%2Fnewsf%2F2015-11%2F2015116173109897.htm">新一代测序十年记：Solexa闪亮登场</a> - Solexa与Illumina</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fnot.farbox.com%2Fpost%2Fphred_p1%23toc_1">质量值体系 Phred33 和 Phred 64 的由来 及其在质量控制中的实际影响 - Part 1</a> - Phred33 和 Phred 64 的由来</li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjasonjwilliamsny.github.io%2Fwrangling-genomics%2F00-readQC.html">QC of Read Data</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcolyfu.com%2FQC%2Ffastq-phred-trans.html">判断fastq文件质量编码格式及Phred64转Phred33方法</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bio-info-trainee.com%2F1850.html">终于碰到color space的测序数据啦！</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.biostars.org%2Fp%2F43855%2F">Tutorial: Transforming And Manipulating Color Space Reads</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fclub.topsage.com%2Fthread-2229946-1-1.html">Perl中FastQ与FastA格式的相互转换</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.biostack.org%2F%3Fp%3D558">NGS数据质量过滤：Usearch fastq-filter、seqtk trimfq和seqtk_filter</a> - read的筛选原则</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.drive5.com%2Fusearch%2Fmanual%2Fexp_errs.html">Expected errors predicted by Phred (Q) scores</a> - 序列的质量值的E值</li></ul><h2 id="链接">链接</h2><ul><li><a href="https://www.jianshu.com/p/63e2abb1b788">perl One-Liners | perl命令行学习3 -a和-F参数</a> - 介绍<code>BEGIN{}</code>块 和 <code>END{}</code>块</li><li><a href="https://www.jianshu.com/p/10da73890ef0">perl 命令行实战1 - fasta文件的相关操作</a> - 介绍fasta文件的操作</li></ul><h2 id="引用">引用</h2><ul><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.qingting.fm%2Fchannels%2F207522">重阳的世界观-第1期：狂点科技树（1）</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftieba.baidu.com%2Fp%2F2709117638%3Fred_tag%3D1385790551">百度贴吧-秦国吧-秦国特有的三棱箭头</a></li></ul><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl 命令行实战1 - fasta文件的相关操作</title>
      <link href="/posts/8aac1538.html"/>
      <url>/posts/8aac1538.html</url>
      
        <content type="html"><![CDATA[<p>之前的5篇简书小文已经说明了常用的参数的使用方法，学习了当然要致用啊！这里我们就来操作一下<code>fasta</code>文件。</p><p>⛱<code>fasta</code>格式是生信中最为常见也是很容易理解的一种格式。那么使用Perl来对它又可以有哪些操作呢？下面是我在平常会用到的一些操作，现在记录下来，希望对大家有帮助。这一篇你应该就能开始慢慢体会到<code>perl</code>单行的威力了！</p><h2 id="fasta文件的介绍">fasta文件的介绍</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;gene1</span><br><span class="line">ATGAGCTGGCGATGCTGACTGTGATCTGATGCT</span><br><span class="line">GTGACTGACTGACGTATGCGAGCTCAGCTGACG</span><br><span class="line">TGTTAA</span><br><span class="line">&gt;gene2</span><br><span class="line">ATGGCAGGCTGCAGCGATGTAGAGTCGACTTAC</span><br><span class="line">GACTGTGATCTGATGCTTAGAGTCGACTTAAAA</span><br><span class="line">AGTGTGGGTTGA</span><br><span class="line">&gt;gene3</span><br><span class="line">ATGGCAGGCTGTGATGCTTATGTAGAGTCGAAT</span><br><span class="line">GACTTTAGAGTCGACTGATGCTTAGAGTCGACT</span><br><span class="line">AGTGTGGGTTGGTGTTGA</span><br></pre></td></tr></tbody></table></figure><p>fasta文件含有两类信息</p><ul><li>第一类是以<code>&gt;</code>符号开头的，是标题头信息，记录了基因名称，有时候下载的fasta文件含有更多的信息（序列说明、编号、版本号、物种来源等等）</li></ul><p>详情请见<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2Ffasta%E6%A0%BC%E5%BC%8F%2F1168511%3Ffr%3Daladdin">fasta格式</a></p><ul><li>第二类是序列信息，就是跟着<code>&gt;</code>打头的标题头信息的这一行的第二行开始直到遇到下一个<code>&gt;</code>或者到达文件末尾就为这个标题头对应的序列了。</li></ul><h2 id="注意">注意</h2><blockquote><p>由于我使用的windows系统进行演示的，在文件的一行结束的位置除了一个<code>\n</code>换行符之外，还有<code>\r</code>回车符这样的字符存在，而使用perl中的<code>chomp</code>方法不能除去<code>\r</code>回车符，所以下面代码中，在Mac或者Linux中可以直接写为<code>chomp</code>我换成了<code>s/\r?\n//</code>。</p></blockquote><blockquote><p>因为一般fasta文件的序列都是以80个字符一行，就是说序列被分成了多行。<br>不能直接说第1行是序列名称，那么第2行就是序列，第3行是另外一个序列名称。这是错误的！<br>判断的依据就是碰到下一个<code>&gt;</code>或者<code>到达文件末尾</code></p></blockquote><h2 id="获取fasta文件的信息">获取fasta文件的信息</h2><p>首先新建一个测试文件<code>123.fasta</code><br>它的内容为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp4</span><br><span class="line">ATGAGATTTAGTTCACGGGATATGCAGGATAGAAAGATGCTATTTGCTGCTATTCCATCTATTTGTGCATCAAGTCCGAA</span><br><span class="line">GAAGATCTCAATCTATAATGAAGAAATGATAGTAGCTCGTCGTTTTATAGGCTTTATCATATTCAGTCGGAAGAGTTTAG</span><br><span class="line">GTAAGACTTTCAAAGTGACTCTCGACGGGAGAATCGAGGCTATTCAGGAAGAATCGCAGCAATTCCCCAATCCTAACGAA</span><br><span class="line">GTAGTTCCTCCGGAATCCAATGAACAACAACGATTACTTAGGATCAGCTTGCGAATTTGTGGCACCGTAGTAGAATCATT</span><br><span class="line">ACCAACGGCACGCTGTGCGCCTAAGTGCGAAAAGACAGTGCAAGCTTTGTTATGCCGAAACCTAAATGTAAAGTCAGCAA</span><br><span class="line">CACTTCCAAATGCCACTTCTTCCCGTCGCATCCGTCTTCAGGACGATATAGTAACAGGTTTTCACTTCTCAGTGAGTGAA</span><br><span class="line">AGATTTTTCCCCGGGTGTACGTTGAAAGCTTCTATCGTAGAACTCATTCGAGAGGGCTTGGTGGTATTAAGAATGGTTCG</span><br><span class="line">GGTGGGGGGTTCTCTTTTTTAA</span><br><span class="line">&gt;atp6</span><br><span class="line">ACGATTACGCCCAACAGCCCACTTGAGCAATTTGCCATTCTCCCATTGATTCCTATGAATATTGGAAAAATTTATTTCTC</span><br><span class="line">ATTCACAAATCCATCTTTGTCTATGCTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAG</span><br><span class="line">GGGGAAACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCCGGTAAACGAACAA</span><br><span class="line">ATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATCTCGGTCACTTCTACTTTTTCGTTATTTCGTAA</span><br><span class="line">TCCCCAGGGTATGATACCTTATAGCTTCACAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTA</span><br><span class="line">TTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTCCCACTGCCG</span><br><span class="line">TTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCATTAAGCTCAGGAATACGTTTATTTGCTAA</span><br><span class="line">TATGATGGCCGGTCATAGTTCAGTAAAGATTTTAAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATT</span><br><span class="line">TCATAGGAGATCCTGGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAGCTCAT</span><br><span class="line">GTTTCTACGATCTCAATCTGTATTTACTTGAATGATGCTACAAATCTCCATCAAAGTGGTTATTTATTTATAATTGAACA</span><br><span class="line">A</span><br><span class="line">&gt;atp8</span><br><span class="line">ATGCCTCAACTGGATAAATTCACTTATTTCACACAATTCTTCTGGTCATGCCTTCTCCTCTTTACTTTTTATATTCCCAT</span><br><span class="line">ATGCAATGATGGAGATGGAGTACTTGGGATCAGCAGAATTCTCAAACTACGGAACCAACTGGTTTCACACCGGGGGAACA</span><br><span class="line">ACATCCGGAGCAACGACCCCAACAGTTTGGAAGATATCTCGAGAAAAGGTTTTAGCACCGGTGTATCCTATATGTACTCA</span><br><span class="line">AGTTTATTCGAAGTATCCCAATGGTGTAACGCCGTCGACTTATTGGGAAAAAGGAGGAAAATCGCTTTGATCTCTTGTTT</span><br><span class="line">CGGAGAAATAAGTGGCTCACGAGGAATGGAAAGAAACATTCTATATTTGATCTCGAAGTCCTCATATAGCACTTCTTCCA</span><br><span class="line">GTCCTGGATGGGGGATCACTTGTAGGAATGACATAATGCTAATCCATGTTCCACACGGCCAAGGAAGCATCGTTTTTTAA</span><br><span class="line">&gt;atp9</span><br><span class="line">ATGTTAGAAGGTGCAAAATCAATAGGTGCCGGAGCAGCTACAATTGCTTCAGCGGGAGCTGCTGTCGGTATTGGAAACGT</span><br><span class="line">CCTTAGTTCCTCGATCCATTCCGTGGCGCGAAATCCATCATTGGCTAAACAATCATTTGGTTATGCCATTTTGGGCTTTG</span><br><span class="line">CTCTAACCGAAGCTATTGCATCGTTTGCCCCAATGATGGCGTCTCTGATCTCATCCGTATTCCGA</span><br></pre></td></tr></tbody></table></figure><p>由于是实战，所以上面的序列信息尽量使用真实的信息，这些线粒体基因序列是从网上下载的。</p><h3 id="1-显示出标题头">1. 显示出标题头</h3><p><strong>思路</strong>：<code>&gt;</code>打头的就是标题头</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | grep <span class="string">"^&gt;"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-统计fasta文件中序列的条数">2. 统计fasta文件中序列的条数</h3><p><strong>思路</strong>：有多少个<code>&gt;</code>打头的行就有多少条序列</p><ul><li>方法1<br>使用perl</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    # 根据fasta文件的特点，每一个以&gt;开头的就为一个序列</span></span><br><span class="line"><span class="string">    if(m/^&gt;/){$n++;}</span></span><br><span class="line"><span class="string">    # 由于只有一行指令，所以开闭括号写在一行上</span></span><br><span class="line"><span class="string">    END{print "$n"}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></tbody></table></figure><ul><li>方法2<br>使用linux命令</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | grep <span class="string">"^&gt;"</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></tbody></table></figure><h3 id="3-统计fasta的总的碱基数目">3. 统计fasta的总的碱基数目</h3><p><strong>思路</strong>：排除<code>&gt;</code>打头的行，将其他的所有字符进行数量统计</p><ul><li>方法1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用grep来排除序列名称那一行，只剩下序列</span></span><br><span class="line"><span class="built_in">cat</span> 123.fasta | grep -v <span class="string">"^&gt;"</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    # 除去末尾的回车符、换行符</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    $n += length($_);</span></span><br><span class="line"><span class="string">    END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2088</span><br></pre></td></tr></tbody></table></figure><ul><li>方法2</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    # 排除序列名称</span></span><br><span class="line"><span class="string">    if(m/^&gt;/){next;}</span></span><br><span class="line"><span class="string">    $n += length($_);</span></span><br><span class="line"><span class="string">    END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2088</span><br></pre></td></tr></tbody></table></figure><ul><li>方法3</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sed命令把行末的回车符和换行符除去</span></span><br><span class="line"><span class="comment"># 使用wc 的 -c 参数获得字符的计数</span></span><br><span class="line"><span class="built_in">cat</span> 123.fasta | grep -v <span class="string">"^&gt;"</span> | sed <span class="string">"s/\r//"</span> | sed <span class="string">":a;N;s/\n//g;ba"</span> | <span class="built_in">wc</span> -c</span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2089</span><br></pre></td></tr></tbody></table></figure><p>不知道为什么数值是<code>2089</code>，与其他方法比多出来了一个，不知道怎么回事，希望有朋友能够告知。<br>其实这种方法我是拒绝的，因为涉及到使用sed去除行末的换行符，这个问题不太好处理。</p><ul><li>方法3.0<br>不过也可以用perl来割割换行符这个尾巴</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | grep -v <span class="string">"^&gt;"</span> | perl -p -e <span class="string">' s/\r?\n//'</span> | <span class="built_in">wc</span> -c</span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2088</span><br></pre></td></tr></tbody></table></figure><h3 id="4-统计每一条序列的长度">4. 统计每一条序列的长度</h3><p><strong>思路</strong>：遇到<code>&gt;</code>打头的行就到了一条新的序列</p><ul><li>方法1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    # 得到序列的名称</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">    # 将这条序列的长度进行累加，直到遇到&gt;或者文件尾</span></span><br><span class="line"><span class="string">        $title_len{$title} += length($_);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 最后打印出信息来</span></span><br><span class="line"><span class="string">    # 你也可以个性化的输出</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        # </span></span><br><span class="line"><span class="string">        # for my $title (sort {$title_len{$b} &lt;=&gt; $title_len{$a}} keys %title_len){</span></span><br><span class="line"><span class="string">        for my $title (sort keys %title_len){</span></span><br><span class="line"><span class="string">            print "$title","\t","$title_len{$title}","\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atp4    582</span><br><span class="line">atp6    801</span><br><span class="line">atp8    480</span><br><span class="line">atp9    225</span><br></pre></td></tr></tbody></table></figure><ul><li>方法2<br>这个方法就是之前讲<code>$/</code>和<code>$\</code>这两个变量的时候说到过。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    # 首先不要将换行符去掉，我们用来作为一个标识</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        # 首先设置输入分隔符 $/</span></span><br><span class="line"><span class="string">        $/ = "&gt;";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 正则表达式分解</span></span><br><span class="line"><span class="string">    # (.+?) ： 非贪婪匹配，为了匹配序列名称</span></span><br><span class="line"><span class="string">    # \s*   ： 如果序列名称后面有空格，用来匹配空格</span></span><br><span class="line"><span class="string">    # \r?\n ： 匹配第一个换行符</span></span><br><span class="line"><span class="string">    # 在 &gt; 符号 与 第一个换行符 之间那么肯定是序列名称</span></span><br><span class="line"><span class="string">    if(m/(.+?)\s*\r?\n/){</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">        # $&amp;为匹配到的序列长度，那么之后的就是序列了。</span></span><br><span class="line"><span class="string">        $sequence = (substr($_,length($&amp;)) =~ s/\r?\n//rg);</span></span><br><span class="line"><span class="string">        # 由于是以 &gt; 作为“行”的标示符，所以末尾一般都有&gt;。去除</span></span><br><span class="line"><span class="string">        $sequence =~ s/&gt;$//;</span></span><br><span class="line"><span class="string">        $title_len{$title} = length($sequence);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        for my $title (sort {$title_len{$b} &lt;=&gt; $title_len{$a}} keys %title_len){</span></span><br><span class="line"><span class="string">            print "$title","\t","$title_len{$title}","\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atp4    582</span><br><span class="line">atp6    801</span><br><span class="line">atp8    480</span><br><span class="line">atp9    225</span><br></pre></td></tr></tbody></table></figure><h3 id="5-统计N50或者N60、N70…">5. 统计N50或者N60、N70…</h3><h4 id="关于N50">关于N50</h4><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N      :   10  20  30  40  50  60  70  80  90  100 </span><br><span class="line">Mark   :   v   v   v   v   v   v   v   v   v   v</span><br><span class="line">all    :========================================</span><br><span class="line">contig1:===========        |   |   |</span><br><span class="line">contig2:           ========|   |   |</span><br><span class="line">contig3:                   ======= |</span><br><span class="line">contig4:                          ======</span><br><span class="line">contig5:                                =====</span><br><span class="line">contig6:                                     ===</span><br></pre></td></tr></tbody></table></figure><p>按照上图的，将所有的contig按照长度从大到小排列起来，首尾相连得到总的长度。<br>当在序列50%的位置处取一点，这一点对应的组成这个位置的contig，它的长度即为N50。例如上面的是contig3所对应的长度7。<br>同样的，N70就是区总序列的70%的位置，在这个位置上对应的contig的长度就是N70。例如上面的是contig4所对应的长度6。<br>上面为了演示，我故意写了一个100，但是实际上没有N100之说。这里说明一下</p><h4 id="程序实现">程序实现</h4><p><strong>思路</strong>：参考<code>2.3</code>节</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这次借用一下List::Util模块中的求和sum方法</span></span><br><span class="line"><span class="built_in">cat</span> 123.fasta | perl -M<span class="string">'List::Util'</span> -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    #==================# </span></span><br><span class="line"><span class="string">    #=第一部分：收集信息=#</span></span><br><span class="line"><span class="string">    #==================#</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    # 得到序列的名称</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">    # 将这条序列的长度进行累加，直到遇到&gt;或者文件尾</span></span><br><span class="line"><span class="string">        $title_len{$title} += length($_);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    #==================# </span></span><br><span class="line"><span class="string">    #=第二部分：综合分析=#</span></span><br><span class="line"><span class="string">    #==================#</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        # 定义需要求得N值</span></span><br><span class="line"><span class="string">        my $n = 0.5;</span></span><br><span class="line"><span class="string">        # 可以将这里的代码与上图进行对比看。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 将数值进行按照从大到小的排序</span></span><br><span class="line"><span class="string">        my @lengths = sort {$b &lt;=&gt; $a} values %title_len;</span></span><br><span class="line"><span class="string">        # 求所有数值的和</span></span><br><span class="line"><span class="string">        my $all     = List::Util::sum(@lengths);</span></span><br><span class="line"><span class="string">        # 用来累积数值，以与总的长度进行比较</span></span><br><span class="line"><span class="string">        my $accumulation = 0;</span></span><br><span class="line"><span class="string">        # 遍历列表</span></span><br><span class="line"><span class="string">        for my $len (@lengths){</span></span><br><span class="line"><span class="string">            $accumulation += $len;</span></span><br><span class="line"><span class="string">            # 如果累积值达到$all的值的一半以上</span></span><br><span class="line"><span class="string">            if($accumulation &gt; $all * $n){</span></span><br><span class="line"><span class="string">                print "N50:$len";</span></span><br><span class="line"><span class="string">                # 结束循环</span></span><br><span class="line"><span class="string">                last;</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N50:582</span><br></pre></td></tr></tbody></table></figure><p>验证一下结果</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atp4    582</span><br><span class="line">atp6    801</span><br><span class="line">atp8    480</span><br><span class="line">atp9    225</span><br></pre></td></tr></tbody></table></figure><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 按照长度排序</span><br><span class="line">801 582 480 225</span><br><span class="line"># 总长度（2.2节）</span><br><span class="line">2088</span><br><span class="line"># 总长度一半</span><br><span class="line">1044</span><br><span class="line"># 递增</span><br><span class="line">801 &lt; 1044</span><br><span class="line">801 + 582 &gt; 1044</span><br><span class="line"># 结果是</span><br><span class="line">582</span><br></pre></td></tr></tbody></table></figure><p>除了计算N50，也可以计算其他值，只需要改一下那个<code>$n</code>值就可以了。<br>然后如果想同时计算多个N值。可以将这些N值也按照从小大的顺序排列然后进行判断，将对应的N值存到Hash中，最后打印出来，你自己可以试一试哦。</p><h2 id="筛选fasta序列">筛选fasta序列</h2><h3 id="1-按照长度筛选">1. 按照长度筛选</h3><p><strong>思路</strong>：可以利用上述<code>2.3</code>节的方法。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    # 得到序列的名称</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        # 之前说过了，一个序列结束的标志是遇到一个&gt;符号打头的行</span></span><br><span class="line"><span class="string">        # 这个时候先不对$title进行赋值</span></span><br><span class="line"><span class="string">        # 因为title和sequence是对应的</span></span><br><span class="line"><span class="string">        if(defined $sequence){ # 如果是第一次进行title的赋值，那么自然就没有sequence，那么这个语句就不会执行</span></span><br><span class="line"><span class="string">            # 比如我这里限制长度为500</span></span><br><span class="line"><span class="string">            if(length($sequence) &gt;= 500){</span></span><br><span class="line"><span class="string">                print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        # 这个时候再进行赋值</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">        # 由于遇到新的序列名称了，同时需要清空$sequence</span></span><br><span class="line"><span class="string">        $sequence = "";</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">    # 将这条序列进行累加，直到遇到&gt;或者文件尾</span></span><br><span class="line"><span class="string">        $sequence .= $_;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 最后打印出信息来</span></span><br><span class="line"><span class="string">    # 你也可以个性化的输出</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        # 之前说到过，除了遇到&gt;符号打头的行之外，还有就是遇到文件尾也是序列结束的标志。这两个标志是互斥的</span></span><br><span class="line"><span class="string">        # 所以最后我们还需要判断一下最后一条序列是否符合规范</span></span><br><span class="line"><span class="string">        if(length($sequence) &gt;= 500){</span></span><br><span class="line"><span class="string">            print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp4</span><br><span class="line">ATGAGATTTAGTTCACGGGATATGCAGGATAGAAAGATGCTATTTGCTGCTATTCCATCTATTTGTGCATCAAGTCCGAAGAAGATCTCAATCTATAATGAAGAAATGATAGTAGCTCGTCGTTTTATAGGCTTTATCATATTCAGTCGGAAGAGTTTAGGTAAGACTTTCAAAGTGACTCTCGACGGGAGAATCGAGGCTATTCAGGAAGAATCGCAGCAATTCCCCAATCCTAACGAAGTAGTTCCTCCGGAATCCAATGAACAACAACGATTACTTAGGATCAGCTTGCGAATTTGTGGCACCGTAGTAGAATCATTACCAACGGCACGCTGTGCGCCTAAGTGCGAAAAGACAGTGCAAGCTTTGTTATGCCGAAACCTAAATGTAAAGTCAGCAACACTTCCAAATGCCACTTCTTCCCGTCGCATCCGTCTTCAGGACGATATAGTAACAGGTTTTCACTTCTCAGTGAGTGAAAGATTTTTCCCCGGGTGTACGTTGAAAGCTTCTATCGTAGAACTCATTCGAGAGGGCTTGGTGGTATTAAGAATGGTTCGGGTGGGGGGTTCTCTTTTTTAA</span><br><span class="line">&gt;atp6</span><br><span class="line">ACGATTACGCCCAACAGCCCACTTGAGCAATTTGCCATTCTCCCATTGATTCCTATGAATATTGGAAAAATTTATTTCTCATTCACAAATCCATCTTTGTCTATGCTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAGGGGGAAACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCCGGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATCTCGGTCACTTCTACTTTTTCGTTATTTCGTAATCCCCAGGGTATGATACCTTATAGCTTCACAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTATTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTCCCACTGCCGTTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCATTAAGCTCAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTTAAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATTTCATAGGAGATCCTGGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAGCTCATGTTTCTACGATCTCAATCTGTATTTACTTGAATGATGCTACAAATCTCCATCAAAGTGGTTATTTATTTATAATTGAACAA</span><br></pre></td></tr></tbody></table></figure><p>可以看到序列最后是输出到一行，这里能不能与之前一样80个碱基一行呢？</p><p>来改一下程序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    # 得到序列的名称</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        # 之前说过了，一个序列结束的标志是遇到一个&gt;符号打头的行</span></span><br><span class="line"><span class="string">        # 这个时候先不对$title进行赋值</span></span><br><span class="line"><span class="string">        # 因为title和sequence是对应的</span></span><br><span class="line"><span class="string">        if(defined $sequence){ # 如果是第一次进行title的赋值，那么自然就没有sequence，那么这个语句就不会执行</span></span><br><span class="line"><span class="string">            # 比如我这里限制长度为500</span></span><br><span class="line"><span class="string">            if(length($sequence) &gt;= 500){</span></span><br><span class="line"><span class="string">                print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        # 这个时候再进行赋值</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">        # 同时需要清空$sequence</span></span><br><span class="line"><span class="string">        $sequence = "";</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">    # 将这条序列进行累加，直到遇到&gt;或者文件尾</span></span><br><span class="line"><span class="string">        $sequence .= $_;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 最后打印出信息来</span></span><br><span class="line"><span class="string">    # 你也可以个性化的输出</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        # 之前说到过，除了遇到&gt;符号打头的行之外，还有就是遇到文件尾也是序列结束的标志。</span></span><br><span class="line"><span class="string">        # 所以最后我们还需要判断一下最后一条序列是否符合规范</span></span><br><span class="line"><span class="string">        if(length($sequence) &gt;= 500){</span></span><br><span class="line"><span class="string">            print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    chomp;</span></span><br><span class="line"><span class="string">    if(m/^&gt;/){</span></span><br><span class="line"><span class="string">        print $_,"\n";</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">        s/(\w{80})/$1\n/g;</span></span><br><span class="line"><span class="string">        # 因为保不齐恰巧有的序列是80的倍数，如果是那样最后一行序列会存在换行符</span></span><br><span class="line"><span class="string">        if(substr($_,-1,1) =~ m/\n/){</span></span><br><span class="line"><span class="string">            print $_;</span></span><br><span class="line"><span class="string">        }else{</span></span><br><span class="line"><span class="string">            print $_,"\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到在最后再一次通过管道，再运行一个perl命令，使用正则表达式来进行分隔，得到想要的结果。</p><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp4</span><br><span class="line">ATGAGATTTAGTTCACGGGATATGCAGGATAGAAAGATGCTATTTGCTGCTATTCCATCTATTTGTGCATCAAGTCCGAA</span><br><span class="line">GAAGATCTCAATCTATAATGAAGAAATGATAGTAGCTCGTCGTTTTATAGGCTTTATCATATTCAGTCGGAAGAGTTTAG</span><br><span class="line">GTAAGACTTTCAAAGTGACTCTCGACGGGAGAATCGAGGCTATTCAGGAAGAATCGCAGCAATTCCCCAATCCTAACGAA</span><br><span class="line">GTAGTTCCTCCGGAATCCAATGAACAACAACGATTACTTAGGATCAGCTTGCGAATTTGTGGCACCGTAGTAGAATCATT</span><br><span class="line">ACCAACGGCACGCTGTGCGCCTAAGTGCGAAAAGACAGTGCAAGCTTTGTTATGCCGAAACCTAAATGTAAAGTCAGCAA</span><br><span class="line">CACTTCCAAATGCCACTTCTTCCCGTCGCATCCGTCTTCAGGACGATATAGTAACAGGTTTTCACTTCTCAGTGAGTGAA</span><br><span class="line">AGATTTTTCCCCGGGTGTACGTTGAAAGCTTCTATCGTAGAACTCATTCGAGAGGGCTTGGTGGTATTAAGAATGGTTCG</span><br><span class="line">GGTGGGGGGTTCTCTTTTTTAA</span><br><span class="line">&gt;atp6</span><br><span class="line">ACGATTACGCCCAACAGCCCACTTGAGCAATTTGCCATTCTCCCATTGATTCCTATGAATATTGGAAAAATTTATTTCTC</span><br><span class="line">ATTCACAAATCCATCTTTGTCTATGCTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAG</span><br><span class="line">GGGGAAACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCCGGTAAACGAACAA</span><br><span class="line">ATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATCTCGGTCACTTCTACTTTTTCGTTATTTCGTAA</span><br><span class="line">TCCCCAGGGTATGATACCTTATAGCTTCACAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTA</span><br><span class="line">TTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTCCCACTGCCG</span><br><span class="line">TTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCATTAAGCTCAGGAATACGTTTATTTGCTAA</span><br><span class="line">TATGATGGCCGGTCATAGTTCAGTAAAGATTTTAAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATT</span><br><span class="line">TCATAGGAGATCCTGGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAGCTCAT</span><br><span class="line">GTTTCTACGATCTCAATCTGTATTTACTTGAATGATGCTACAAATCTCCATCAAAGTGGTTATTTATTTATAATTGAACA</span><br><span class="line">A</span><br></pre></td></tr></tbody></table></figure><h3 id="2-按照GC含量筛选">2. 按照GC含量筛选</h3><p><strong>思路</strong>：前半部分与上面按照长度筛选相似</p><p>为了看起来方便，我将之前的注释都给去掉</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        # 首先可以定义一个求序列GC含量的</span></span><br><span class="line"><span class="string">        sub statistic_GC_base{ # 统计序列的GC含量和数量</span></span><br><span class="line"><span class="string">            my $sequence = shift;</span></span><br><span class="line"><span class="string">            my $len      = length($sequence);</span></span><br><span class="line"><span class="string">            my $num      = ($sequence =~ tr/GCgc/GCgc/);</span></span><br><span class="line"><span class="string">            my $GC       = sprintf("%.2f",$num * 100 / $len); # 返回的是百分数（不带百分号）</span></span><br><span class="line"><span class="string">            return $GC;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        # 先定义一个GC含量的限制</span></span><br><span class="line"><span class="string">        $GC_threshold = 40;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        if(defined $sequence){</span></span><br><span class="line"><span class="string">            # 比如我这里限制GC含量为50%，小于这个值才能通过</span></span><br><span class="line"><span class="string">            if(statistic_GC_base($sequence) &lt;= $GC_threshold){</span></span><br><span class="line"><span class="string">                print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        # 这个时候再进行赋值</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">        # 同时需要清空$sequence</span></span><br><span class="line"><span class="string">        $sequence = "";</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">    # 将这条序列进行累加，直到遇到&gt;或者文件尾</span></span><br><span class="line"><span class="string">        $sequence .= $_;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 最后打印出信息来</span></span><br><span class="line"><span class="string">    # 你也可以个性化的输出</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        # 之前说到过，除了遇到&gt;符号打头的行之外，还有就是遇到文件尾也是序列结束的标志。</span></span><br><span class="line"><span class="string">        # 所以最后我们还需要判断一下最后一条序列是否符合规范</span></span><br><span class="line"><span class="string">        if(statistic_GC_base($sequence) &lt;= $GC_threshold){</span></span><br><span class="line"><span class="string">            print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span> </span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp6</span><br><span class="line">ACGATTACGCCCAACAGCCCACTTGAGCAATTTGCCATTCTCCCATTGATTCCTATGAATATTGGAAAAATTTATTTCTCATTCACAAATCCATCTTTGTCTATGCTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAGGGGGAAACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCCGGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATCTCGGTCACTTCTACTTTTTCGTTATTTCGTAATCCCCAGGGTATGATACCTTATAGCTTCACAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTATTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTCCCACTGCCGTTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCATTAAGCTCAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTTAAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATTTCATAGGAGATCCTGGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAGCTCATGTTTCTACGATCTCAATCTGTATTTACTTGAATGATGCTACAAATCTCCATCAAAGTGGTTATTTATTTATAATTGAACAA</span><br></pre></td></tr></tbody></table></figure><h3 id="3-除掉零长度序列">3. 除掉零长度序列</h3><p>有时候我们用程序批量得到的一些fasta序列可能<strong>只包含序列名称却不包含序列</strong>，在blast或者其他工具的使用的时候会报错而导致后续无法进行，那么就除掉它！</p><p>例如</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;seq1</span><br><span class="line">&gt;seq2</span><br><span class="line">&gt;seq3</span><br><span class="line">ATCGATGCTGATCGT</span><br></pre></td></tr></tbody></table></figure><p>这种情况下<code>seq1</code>、<code>seq2</code>是不包含序列信息的，<code>seq3</code>是有序列的，所以这里需要将<code>seq1</code>、<code>seq2</code>除掉。这里其实就是把<code>4.1</code>里面的<code>500</code>换成了<code>1</code>，异曲同工。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">        if(defined $sequence){</span></span><br><span class="line"><span class="string">            if(length($sequence) &gt;= 1){</span></span><br><span class="line"><span class="string">                print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        $title = $1;</span></span><br><span class="line"><span class="string">        $sequence = "";</span></span><br><span class="line"><span class="string">    }elsif(defined $title){</span></span><br><span class="line"><span class="string">        $sequence .= $_;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    END{</span></span><br><span class="line"><span class="string">        if(length($sequence) &gt;= 1){</span></span><br><span class="line"><span class="string">            print "&gt;$title\n$sequence\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="提取fasta序列">提取fasta序列</h2><h3 id="1-按照序列名称提取">1. 按照序列名称提取</h3><p>事实上这里适合写perl脚本然后保存脚本文件。<br>如果需要提取的列表多，放在文件里面的话，那么事先可以读取文件。这里比如我要提取<code>123.fasta</code>文件中的<code>atp4</code>和<code>atp8</code>这两个的序列</p><ul><li>第一步：新建一个文件<code>123.list</code>存放这两个序列名</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> atp4 &gt;&gt; 123.list.txt</span><br><span class="line"><span class="built_in">echo</span> atp8 &gt;&gt; 123.list.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>第二步：将序列行合一</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -p -e <span class="string">'s/\r?\n//;s/^&gt;(.+)$/&gt;$1\n/;s/^&gt;/\n&gt;/'</span> &gt; 123.merge.fasta</span><br></pre></td></tr></tbody></table></figure><ul><li>第三步：提取序列</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.merge.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 由于需要使用到两个文件，这里需要使用到文件句柄</span></span><br><span class="line"><span class="string">    open my $file_fh,"&lt;","./123.list.txt" or die $!;</span></span><br><span class="line"><span class="string">    while(&lt;$file_fh&gt;){</span></span><br><span class="line"><span class="string">      s/\r\n//;</span></span><br><span class="line"><span class="string">      if(m/^&gt;?(.+?)[\s\t]*$/){</span></span><br><span class="line"><span class="string">        push @lookup,$1;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    close $file_fh;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  if(m/^&gt;/){</span></span><br><span class="line"><span class="string">    my $title = $_;</span></span><br><span class="line"><span class="string">    my $sequence = &lt;&gt;;</span></span><br><span class="line"><span class="string">    if(grep {$title =~ m/\b\Q$_\E\b/} @lookup){</span></span><br><span class="line"><span class="string">      printf "%s%s",$title,$sequence;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> &gt; 123.extract.fasta</span><br></pre></td></tr></tbody></table></figure><p>这里使用临时文件，为了让第三步的代码更加简洁，其实前面为了一步就达到目标写一个perl单行程序有时候不是很好，这里先将序列合并到一行之上一方面加快程序运行速度，另外一方面也可以方便编写perl单行程序。其实上面的第二三步之间不需要生成中间文件，可以直接管道连接第二步与第三步。</p><h3 id="2-按照长度提取">2. 按照长度提取</h3><p>这里与上面的<code>3.1 按照长度筛选是一样的原理</code>，详细可以参考这一小节。</p><h3 id="3-提取某个区域的序列">3. 提取某个区域的序列</h3><p>与上面的5.1步骤有点相似，这里我们分三步走</p><ul><li>第一步：新建一个文件<code>123.scale.list</code>存放这两个序列名以及需要提取的区域</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"atp4 200-400 500-600"</span> &gt; 123.scale.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"atp8 20-45 68-90"</span> &gt;&gt; 123.scale.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>第二步：将序列行合一</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -p -e <span class="string">'s/\r?\n//;s/^&gt;(.+)$/&gt;$1\n/;s/^&gt;/\n&gt;/'</span> &gt; 123.merge.fasta</span><br></pre></td></tr></tbody></table></figure><ul><li>第三步：提取序列</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.merge.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">      BEGIN{</span></span><br><span class="line"><span class="string">        sub seq_comp_rev{</span></span><br><span class="line"><span class="string">          my $r_c_seq = &amp;seq_com(&amp;seq_rev(shift));</span></span><br><span class="line"><span class="string">          return $r_c_seq;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        sub seq_com{</span></span><br><span class="line"><span class="string">          return shift =~ tr/AGTCagtc/TCAGtcag/r;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        sub seq_rev{</span></span><br><span class="line"><span class="string">          my $temp = reverse shift;</span></span><br><span class="line"><span class="string">          return $temp;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        open my $file_fh,"&lt;","./123.scale.txt" or die $!;</span></span><br><span class="line"><span class="string">        while(&lt;$file_fh&gt;){</span></span><br><span class="line"><span class="string">          s/\r?\n//;</span></span><br><span class="line"><span class="string">          my @temp = split(/\s+/,$_);</span></span><br><span class="line"><span class="string">          push @scales,[@temp];</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        close $file_fh;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      s/\r?\n//;</span></span><br><span class="line"><span class="string">      if(m/^&gt;/){</span></span><br><span class="line"><span class="string">        my $title = $_;</span></span><br><span class="line"><span class="string">        my $sequence = &lt;&gt;;</span></span><br><span class="line"><span class="string">        for my $line (@scales) {</span></span><br><span class="line"><span class="string">          my $name = $line-&gt;[0];</span></span><br><span class="line"><span class="string">          my @scale = @{$line}[1..scalar(@$line) - 1];</span></span><br><span class="line"><span class="string">          if ($title =~ m/&gt;\b\Q$name\E\b/){</span></span><br><span class="line"><span class="string">            for my $s (@scale){</span></span><br><span class="line"><span class="string">              my @temp = split(/-/,$s);</span></span><br><span class="line"><span class="string">              my ($start,$end) = ($temp[0],$temp[1]);</span></span><br><span class="line"><span class="string">              my $len = abs($end - $start) + 1;</span></span><br><span class="line"><span class="string">              my $seg;</span></span><br><span class="line"><span class="string">              if ($start &gt; $end){</span></span><br><span class="line"><span class="string">                  $seg = substr($sequence,$end - 1,$len);</span></span><br><span class="line"><span class="string">                  $seg = seq_comp_rev($seg);</span></span><br><span class="line"><span class="string">              }else{</span></span><br><span class="line"><span class="string">                  $seg = substr($sequence,$start - 1,$len);</span></span><br><span class="line"><span class="string">              }</span></span><br><span class="line"><span class="string">              push @total , ["$title:$start-$end",$seg];</span></span><br><span class="line"><span class="string">            }</span></span><br><span class="line"><span class="string">          }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      END{</span></span><br><span class="line"><span class="string">        for my $line (@total){</span></span><br><span class="line"><span class="string">          printf "%s\n%s\n",$line-&gt;[0],$line-&gt;[1];</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    '</span></span><br></pre></td></tr></tbody></table></figure><p>记得重定向哦</p><h2 id="序列转换">序列转换</h2><h3 id="1-转换为反向互补序列">1. 转换为反向互补序列</h3><p>将序列转换为反向互补的序列。例如ATGC转变为GCAT。实际上这个就是一个序列反转，字符替换的问题。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    sub seq_comp_rev{</span></span><br><span class="line"><span class="string">      my $r_c_seq = &amp;seq_com(&amp;seq_rev(shift));</span></span><br><span class="line"><span class="string">      return $r_c_seq;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub seq_com{</span></span><br><span class="line"><span class="string">      return shift =~ tr/AGTCagtc/TCAGtcag/r;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub seq_rev{</span></span><br><span class="line"><span class="string">      my $temp = reverse shift;</span></span><br><span class="line"><span class="string">      return $temp;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  s/\r?\n//;</span></span><br><span class="line"><span class="string">  if(m/^&gt;(.+?)\s*$/){</span></span><br><span class="line"><span class="string">    $n++;</span></span><br><span class="line"><span class="string">    if(defined $sequence){</span></span><br><span class="line"><span class="string">      printf "&gt;%s\n%s\n",$title,&amp;seq_comp_rev($sequence);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    $title = $1;</span></span><br><span class="line"><span class="string">    $sequence = "";</span></span><br><span class="line"><span class="string">  }elsif(defined $title){</span></span><br><span class="line"><span class="string">    $sequence .= $_;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    if($n &gt;= 1){</span></span><br><span class="line"><span class="string">      printf "&gt;%s\n%s\n",$title,&amp;seq_comp_rev($sequence);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span> &gt; 123.com_rev.fasta</span><br></pre></td></tr></tbody></table></figure><p>其实这里不一定偏要什么用cat读取文件然后用perl来处理。就是说这里不管数据从cat读取文件来还是从别的东西输出通过管道来perl都能处理。你也可以尝试一下。</p><h3 id="2-大小写转换">2 大小写转换</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    if(m/^&gt;/){</span></span><br><span class="line"><span class="string">        print;</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">        # 转大写</span></span><br><span class="line"><span class="string">        print uc($_);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    '</span></span><br></pre></td></tr></tbody></table></figure><h2 id="序列分离">序列分离</h2><h3 id="1-把包含多条序列的一个fasta文件分为多个">1. 把包含多条序列的一个fasta文件分为多个</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> temp</span><br><span class="line"><span class="built_in">cat</span> 123.fasta \</span><br><span class="line">| sed <span class="string">'/^$/d'</span> \</span><br><span class="line">| perl -<span class="built_in">nl</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    $/ = "&gt;"</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  s/&gt;$//;</span></span><br><span class="line"><span class="string">  if($_ ne ""){</span></span><br><span class="line"><span class="string">    $title = $1 if m/^(.+?)\r?\n/;</span></span><br><span class="line"><span class="string">    open my $write, "&gt;", "./temp/$title.fasta" or die;</span></span><br><span class="line"><span class="string">    print $write "&gt;$_";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>最后得到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./temp/atp4.fasta</span><br><span class="line">./temp/atp6.fasta</span><br><span class="line">./temp/atp8.fasta</span><br><span class="line">./temp/atp9.fasta</span><br></pre></td></tr></tbody></table></figure><h3 id="2-把一条长序列切成多段">2. 把一条长序列切成多段</h3><p>拿一条序列来做实验，例如<code>&gt;atp4</code>，把它放到一个新的文件<code>456.fasta</code>中</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 456.fasta \</span><br><span class="line">| perl -p -e <span class="string">'s/\r?\n//;s/^&gt;(.+)$/&gt;$1\n/;s/^&gt;/\n&gt;/'</span> \</span><br><span class="line">| sed <span class="string">'/^$/d'</span> \</span><br><span class="line">| perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/^&gt;(.+)\r?\n/){</span></span><br><span class="line"><span class="string">    $title = $1;</span></span><br><span class="line"><span class="string">    $seq   = &lt;&gt;;</span></span><br><span class="line"><span class="string">    # 设定长度</span></span><br><span class="line"><span class="string">    my $len = 100;</span></span><br><span class="line"><span class="string">    my $total = 0;</span></span><br><span class="line"><span class="string">    my $count = 1;</span></span><br><span class="line"><span class="string">    while(my $temp = substr($seq,0,$len,"")){</span></span><br><span class="line"><span class="string">       $before = $total + 1;</span></span><br><span class="line"><span class="string">       $total  = $before + length($temp) - 1;</span></span><br><span class="line"><span class="string">       open my $write ,"&gt;", "${title}_$count.fasta" or die;</span></span><br><span class="line"><span class="string">       print $write "&gt;${title}:$before-$total\n$temp\n";</span></span><br><span class="line"><span class="string">       close $write;</span></span><br><span class="line"><span class="string">       $count++;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-将单行的极长的序列按照特定长度换行">3. 将单行的极长的序列按照特定长度换行</h3><p>有的时候我们拿到的序列都是排布在一行之上，特别的长，这种序列在某些软件分析的时候会出错。而且也不方便复制。<br>比如<code>123.fasta</code>：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp4</span><br><span class="line">ATGAGATTTAGTTCACGGGATATGCAGGATAGAAAGATGCTATTTGCTGCTATTCCATCTATTTGTGCATCAAGTCCGAAGAAGATCTCAATCTATAATGAAGAAATGATAGTAGCTCGTCGTTTTATAGGCTTTATCATATTCAGTCGGAAGAGTTTAGGTAAGACTTTCAAAGTGACTCTCGACGGGAGAATCGAGGCTATTCAGGAAGAATCGCAGCAATTCCCCAATCCTAACGAAGTAGTTCCTCCGGAATCCAATGAACAACAACGATTACTTAGGATCAGCTTGCGAATTTGTGGCACCGTAGTAGAATCATTACCAACGGCACGCTGTGCGCCTAAGTGCGAAAAGACAGTGCAAGCTTTGTTATGCCGAAACCTAAATGTAAAGTCAGCAACACTTCCAAATGCCACTTCTTCCCGTCGCATCCGTCTTCAGGACGATATAGTAACAGGTTTTCACTTCTCAGTGAGTGAAAGATTTTTCCCCGGGTGTACGTTGAAAGCTTCTATCGTAGAACTCATTCGAGAGGGCTTGGTGGTATTAAGAATGGTTCGGGTGGGGGGTTCTCTTTTTTAA</span><br><span class="line">&gt;atp6</span><br><span class="line">ACGATTACGCCCAACAGCCCACTTGAGCAATTTGCCATTCTCCCATTGATTCCTATGAATATTGGAAAAATTTATTTCTCATTCACAAATCCATCTTTGTCTATGCTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAGGGGGAAACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCCGGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATCTCGGTCACTTCTACTTTTTCGTTATTTCGTAATCCCCAGGGTATGATACCTTATAGCTTCACAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTATTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTCCCACTGCCGTTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCATTAAGCTCAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTTAAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATTTCATAGGAGATCCTGGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAGCTCATGTTTCTACGATCTCAATCTGTATTTACTTGAATGATGCTACAAATCTCCATCAAAGTGGTTATTTATTTATAATTGAACAA</span><br><span class="line">&gt;atp8</span><br><span class="line">ATGCCTCAACTGGATAAATTCACTTATTTCACACAATTCTTCTGGTCATGCCTTCTCCTCTTTACTTTTTATATTCCCATATGCAATGATGGAGATGGAGTACTTGGGATCAGCAGAATTCTCAAACTACGGAACCAACTGGTTTCACACCGGGGGAACAACATCCGGAGCAACGACCCCAACAGTTTGGAAGATATCTCGAGAAAAGGTTTTAGCACCGGTGTATCCTATATGTACTCAAGTTTATTCGAAGTATCCCAATGGTGTAACGCCGTCGACTTATTGGGAAAAAGGAGGAAAATCGCTTTGATCTCTTGTTTCGGAGAAATAAGTGGCTCACGAGGAATGGAAAGAAACATTCTATATTTGATCTCGAAGTCCTCATATAGCACTTCTTCCAGTCCTGGATGGGGGATCACTTGTAGGAATGACATAATGCTAATCCATGTTCCACACGGCCAAGGAAGCATCGTTTTTTAA</span><br><span class="line">&gt;atp9</span><br><span class="line">ATGTTAGAAGGTGCAAAATCAATAGGTGCCGGAGCAGCTACAATTGCTTCAGCGGGAGCTGCTGTCGGTATTGGAAACGTCCTTAGTTCCTCGATCCATTCCGTGGCGCGAAATCCATCATTGGCTAAACAATCATTTGGTTATGCCATTTTGGGCTTTGCTCTAACCGAAGCTATTGCATCGTTTGCCCCAATGATGGCGTCTCTGATCTCATCCGTATTCCGA</span><br></pre></td></tr></tbody></table></figure><p>将这种一行的序列分割到多行上，我这里设置的是<code>80</code>，你也可以自己更改一下。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        $word_num = 80;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    chomp;</span></span><br><span class="line"><span class="string">    if(m/^&gt;/){</span></span><br><span class="line"><span class="string">        print $_,"\n";</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">        s/(\w{$word_num})/$1\n/g;</span></span><br><span class="line"><span class="string">        if(substr($_,-1,1) =~ m/\n/){</span></span><br><span class="line"><span class="string">            print $_;</span></span><br><span class="line"><span class="string">        }else{</span></span><br><span class="line"><span class="string">            print $_,"\n";</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span> &gt; 123.multi_line.fasta</span><br></pre></td></tr></tbody></table></figure><h2 id="序列合并">序列合并</h2><p>额，这里不使用perl脚本来执行，说实话不是很合适而且也没有那个必要。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是.fa，那改为.fa即可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">ls</span> *.fasta);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cat</span> <span class="variable">${i}</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span> &gt; total.fasta</span><br></pre></td></tr></tbody></table></figure><h2 id="序列名称">序列名称</h2><h3 id="1-序列重名怎么办？">1. 序列重名怎么办？</h3><p>有的时候fasta文件中有重名的，比如有一文件<code>test.fasta</code>：</p><figure class="highlight objectivec"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;mouse</span><br><span class="line"><span class="built_in">CGTAGCTGGATG</span></span><br><span class="line">&gt;dog</span><br><span class="line"><span class="built_in">CGATGCTGACGT</span></span><br><span class="line">&gt;mouse</span><br><span class="line">GCTACGTACGTG</span><br><span class="line">&gt;mouse</span><br><span class="line">GTACGTGAGCGT</span><br></pre></td></tr></tbody></table></figure><p>这种<code>fasta</code>文件用于后续分析某些软件可能会报错，怎么做呢？有多种方法处理，这里最为推荐的是在序列名后面加上编号：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.fasta | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/^&gt;/){</span></span><br><span class="line"><span class="string">    chomp;</span></span><br><span class="line"><span class="string">    my $temp = $_;</span></span><br><span class="line"><span class="string">    my $n = 1;</span></span><br><span class="line"><span class="string">    while ( exists $hash{$temp} ){</span></span><br><span class="line"><span class="string">      $temp = $_ . "_" . $n;</span></span><br><span class="line"><span class="string">      $n++;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    $hash{$temp}++;</span></span><br><span class="line"><span class="string">    print "$temp\n";</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    print;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;mouse</span><br><span class="line">CGTAGCTGGATG</span><br><span class="line">&gt;dog</span><br><span class="line">CGATGCTGACGT</span><br><span class="line">&gt;mouse_1</span><br><span class="line">GCTACGTACGTG</span><br><span class="line">&gt;mouse_2</span><br><span class="line">GTACGTGAGCGT</span><br></pre></td></tr></tbody></table></figure><h2 id="后记">后记</h2><p>这一次相较于之前的perl命令行参数的介绍，代码量明显增加了一些，但是所有的知识都是与之前相互关联的，如果需要可以查看之前的短文。</p><ul><li><a href="https://www.jianshu.com/p/a0a361c6daa4">perl One-Liners | perl命令行学习5 $/和$\变量</a> - 介绍<code>$/</code>变量</li><li><a href="https://www.jianshu.com/p/1467da5c8410">perl One-Liners | perl命令行学习4 -M与-I参数</a> - 介绍模块的导入</li><li><a href="https://www.jianshu.com/p/63e2abb1b788">perl One-Liners | perl命令行学习3 -a和-F参数</a> - 介绍<code>BEGIN{}</code>块 和 <code>END{}</code>块</li></ul><p>目前有关fasta的操作暂时想到了这些，如果有朋友能够想到更多有关的操作，希望能告诉我一下，多谢各位了！</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之特殊变量</title>
      <link href="/posts/1d803e51.html"/>
      <url>/posts/1d803e51.html</url>
      
        <content type="html"><![CDATA[<h2 id="上集回顾">上集回顾</h2><p>上次我们看了一下<code>-M</code>与<code>-I</code>这两个搭档 这次我们来看看这两个特殊的”变量“<code>$/</code>和<code>$\</code>，不是参数。</p><h2 id="解释">解释</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$/ : 输入记录分隔符</span><br><span class="line">$\ : 输出记录分隔符</span><br></pre></td></tr></tbody></table></figure><p>说实话，这两个符号的确是有些诡异！可以这么来记，“太阳出来我爬山坡，爬上山坡我好唱歌”，爬坡的是<code>/</code>（入），下坡的是<code>\</code>（出）。</p><p>这两个变量是特殊变量，什么意思呢？就是它们是从娘胎里来的，本来就有，不需要你去声明，它们就在那里。为什么要说这两个变量呢？这两个变量是什么意思呢？下面先说明一下这两个奇特的怪物究竟是个什么玩意，这里举个例子。</p><p>比如在工厂车间的流水线，生产罐头的那种：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   [] [] [] [] [] [] [] [] [] [] [] []</span><br><span class="line">-&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;</span><br><span class="line">| O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O |</span><br><span class="line">&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;-</span><br><span class="line"></span><br><span class="line">当得到成品罐头之后，需要装箱了，可是多少个装一箱呢。</span><br><span class="line">这个时候就有机器负责控制履带移动的长度来控制几个罐头为一组进行装箱（罐头之间间距相等）。</span><br><span class="line">比如4个罐头装一箱，那好,当过了一定长度之后传送带停下来，机械臂将4个罐头装箱，OK</span><br><span class="line"></span><br><span class="line">                          |===================</span><br><span class="line">                          -</span><br><span class="line">                         | |</span><br><span class="line">                          |</span><br><span class="line">   [] [] [] [] [] [] [] [] [] [] [] []</span><br><span class="line">-&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;</span><br><span class="line">| O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O |</span><br><span class="line">&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;-</span><br><span class="line"></span><br><span class="line">下一批</span><br><span class="line">                          |===================</span><br><span class="line">                          -                         ---------</span><br><span class="line">                         | |                        | [] [] |</span><br><span class="line">                          |                         | [] [] |</span><br><span class="line">               [] [] [] [] [] [] [] []              --------- </span><br><span class="line">-&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;  ####################</span><br><span class="line">| O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O |  ####################</span><br><span class="line">&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;-  ####################</span><br><span class="line"></span><br><span class="line">再下一批</span><br><span class="line">                          |===================</span><br><span class="line">                          -                         --------- ---------</span><br><span class="line">                         | |                        | [] [] | | [] [] |</span><br><span class="line">                          |                         | [] [] | | [] [] |</span><br><span class="line">                           [] [] [] []              --------- --------- </span><br><span class="line">-&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;  #################### </span><br><span class="line">| O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O |  ####################</span><br><span class="line">&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;-  ####################</span><br></pre></td></tr></tbody></table></figure><p>假如我的包装箱变大了，这次要装6个，怎么搞，好办，设置一下传送带每次传送的长度就OK</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                          |===================      ---------</span><br><span class="line">                          -                         | [] [] |</span><br><span class="line">                         | |                        | [] [] |</span><br><span class="line">                          |                         | [] [] |</span><br><span class="line">                           [] [] [] [] [] []        ---------</span><br><span class="line">-&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;--&gt;  #################### </span><br><span class="line">| O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O |  #################### </span><br><span class="line">&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;--&lt;-  #################### </span><br></pre></td></tr></tbody></table></figure><p>有的时候厂家搞活动，在箱子里面除了有罐头，还有小礼品哟。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------</span><br><span class="line">| [] [] |--|            +++</span><br><span class="line">| [] [] |  |            +++ 小礼品，比如杯子，哈哈</span><br><span class="line">| [] [] | +++</span><br><span class="line">--------- +++</span><br><span class="line"></span><br><span class="line">^^^^^^^^^^</span><br><span class="line">||||||||||</span><br><span class="line">上面是一个装罐头的箱子，外面用绳子系了个礼物在外面，我怕我灵魂画手的功力太深，你们认不出来~~</span><br></pre></td></tr></tbody></table></figure><p>这里不妨把perl的文本处理流程当作是工厂中的流水线，每次读取一“行”，来处理。</p><ul><li><code>$/</code>就是说在什么地方将文本分隔开来作为一组”罐头“，类似于控制传送带移动的长度。</li><li><code>$\</code>就是当我想打印文本的时候后面带的小尾巴是什么，就像是上面的小礼品一样。</li></ul><h2 id="现实世界与机器世界">现实世界与机器世界</h2><p>平常我们读书，从左到右转头就是一行。但是在机器世界，究竟什么是“行”，其实计算机的存储是连续的，并不是说想现实世界那样还转行之类的。那么究竟是如何区分行与行呢？比如有一段序列：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATGCGTAGCTA</span><br><span class="line">TAGCTAGCTTG</span><br><span class="line">AA</span><br></pre></td></tr></tbody></table></figure><p>其实真实的是这样的</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATGCGTAGCTA\nTAGCTAGCTTG\nAA</span><br></pre></td></tr></tbody></table></figure><p>当然了，更加还原是以1和0表示，这里为了方便叙述。也就是说在这三“行”序列之间是用一个<code>\n</code>连起来的，并不是像现实世界转头之类的。机器为了区分，每次读到<code>\n</code>，就知道了到了一“行”了。 上面两张图说明了现实的书本纸和机器世界的区别<code>LF</code>就是指<code>\n</code>。这个就是为了告诉机器要“换行了”。那么这里Perl不仅可以要机器在<code>\n</code>的地方换行，也可以自己设置如果碰到什么字符那就换行，比如<code>!</code>、<code>~</code>、<code>@</code>等等。</p><blockquote><p>我之前有一个同学在处理文本的时候没有将末尾的那个不可见的换行符去除，导致正则表达式无法匹配，也就无法得到正确结果，但是他换成从命令行输出那一行信息却可以匹配（从命令行读取的不包含换行符）。一直纠结，后来我给他说了，他一直不相信，知道后来事实证明他没搞清楚这个换行符。</p></blockquote><p>额，可能被我搞的糊涂了，来看看例子就明白啦！</p><h2 id="用法">用法</h2><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$/ = <span class="string">"\n"</span>;</span><br><span class="line">$\ = <span class="string">"\n"</span>;</span><br></pre></td></tr></tbody></table></figure><p>这两个就是变量，也就是说可以直接对他们赋值</p><h2 id="实例">实例</h2><ul><li>示例1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这次不用-a与-F参数来处理</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"12-34-56,45-23-67,678-56-12"</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        # 在读取数据之前就设置好输入记录分隔符</span></span><br><span class="line"><span class="string">        # 设置 , 作为“一行”的结尾的标志</span></span><br><span class="line"><span class="string">        $/ = ",";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 在将读取的每一“行”的一系列用 - 连起来的数值进行分隔</span></span><br><span class="line"><span class="string">    my @list = split /-/,$_;</span></span><br><span class="line"><span class="string">    # 对每组数值求和</span></span><br><span class="line"><span class="string">    my $total = 0;  # 初始化变量</span></span><br><span class="line"><span class="string">    for my $num (@list){</span></span><br><span class="line"><span class="string">        $total += $num;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    print "$total\n";</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">102</span><br><span class="line">135</span><br><span class="line">746</span><br></pre></td></tr></tbody></table></figure><p>这里来解释一下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        |        |</span><br><span class="line">        v        v</span><br><span class="line">12-34-56,45-23-67,678-56-12</span><br></pre></td></tr></tbody></table></figure><p>箭头所指的就是每次读取的”一行“的停止位置，平常我们一般都是认为换行符才是一行的末尾，但是这里<code>$/</code>大哥说了，机器人的世界中的天上天下的——换行，都归我管 。也就是说这里它重新定义了行的概念，就是说，按照<code>,</code>来作为标志。比如：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">机器读</span><br><span class="line">12-34-56,</span><br><span class="line">这是”一行“</span><br><span class="line">再读</span><br><span class="line">45-23-67,</span><br><span class="line">这是”一行“</span><br><span class="line">在读</span><br><span class="line">678-56-12</span><br><span class="line">这是”一行“</span><br></pre></td></tr></tbody></table></figure><p>这里的“行”是指机器读的行，来点实际的东西</p><ul><li>示例2</li></ul><p>假如有一个文件<code>123.txt</code>，内容为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;atp1</span><br><span class="line">AGTCAGCTGACTCGATCTACGTCTAGCGACGT</span><br><span class="line">GATACGTACGTACGGTACTCGTAGCTACCGTA</span><br><span class="line">TAGTAGC</span><br><span class="line">&gt;cox</span><br><span class="line">ATGCGTAGCTATCGTAGCTAGCTCGATCGTCA</span><br><span class="line">AGTAGCTCAGG</span><br><span class="line">&gt;nad1</span><br><span class="line">ATGCTAGCTGACTTGACTGCATACGATGCTAG</span><br><span class="line">GTAGTCATGCTAGCTAGC</span><br></pre></td></tr></tbody></table></figure><p>其实在平常我们碰到很多fasta文件，它的序列是按照80个碱基为一行就进行了换行了，所以我们后续处理有些麻烦。比如我们想要得到名为atp1的序列，那么就是当我判断了到了atp1之后，接下来就是序列，可是只打印出<code>&gt;atp1</code>下面的一行却不是它的完整序列，还需要继续打印，直到碰到<code>&gt;cox</code>，这样其实某种程度上来说就有点不太方便。</p><p>怎么做呢？你根据今天说的内容应该想出来怎么办了吧！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 &gt; 作为输入分隔符</span></span><br><span class="line"><span class="comment"># 代码如下</span></span><br><span class="line"><span class="built_in">cat</span> 123.txt | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        $/ = "&gt;";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 由于是以 &gt; 作为分隔符，那么尾巴处就可能有&gt;符号（除了最后一行可能没有其他都有）</span></span><br><span class="line"><span class="string">    $_ =~ s/&gt;$//;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 正则表达式中\s*\r*使因为不只知道在atp1后面是否有空格和回车符，所以加上</span></span><br><span class="line"><span class="string">    if($_ =~ m/^atp1\s*\r*\n/){</span></span><br><span class="line"><span class="string">        # 1. 也可以在这里除去里面的换行符</span></span><br><span class="line"><span class="string">        # print (substr($_,length($&amp;)) =~ s/\r*\n//gr);</span></span><br><span class="line"><span class="string">        # 2. 也可以不去除</span></span><br><span class="line"><span class="string">        print ( substr($_,length($&amp;) );</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">AGTCAGCTGACTCGATCTACGTCTAGCGACGT</span><br><span class="line">GATACGTACGTACGGTACTCGTAGCTACCGTA</span><br><span class="line">TAGTAGC</span><br></pre></td></tr></tbody></table></figure><p>这里我把分隔出来的每一批字符写一下</p><p>第一批：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure><p>第二批：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atp1</span><br><span class="line">AGTCAGCTGACTCGATCTACGTCTAGCGACGT</span><br><span class="line">GATACGTACGTACGGTACTCGTAGCTACCGTA</span><br><span class="line">TAGTAGC</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure><p>第三批：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cox</span><br><span class="line">ATGCGTAGCTATCGTAGCTAGCTCGATCGTCA</span><br><span class="line">AGTAGCTCAGG</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure><p>第四批：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nad1</span><br><span class="line">ATGCTAGCTGACTTGACTGCATACGATGCTAG</span><br><span class="line">GTAGTCATGCTAGCTAGC</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：由于这里我们对机器世界的行进行了重新定义，在这每一“行”中就可能存在多个<code>\n</code>，而“行”的结尾就变成了<code>&gt;</code>。</p><h3 id>$\</h3><p>这个参数就是说当输出的时候，在输出的内容后带上一个小尾巴，比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'</span></span><br><span class="line"><span class="string">    BEGIN{</span></span><br><span class="line"><span class="string">        $\ = "~";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    for my $num (1..10){</span></span><br><span class="line"><span class="string">        print "$num";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1~2~3~4~5~6~7~8~9~10~</span><br></pre></td></tr></tbody></table></figure><p>就是说每次print，都会在print的内容后面加上<code>$\</code>指定的内容，这里是否想到减少按键盘的次数了。将<code>$\</code>赋值为<code>\n</code>。你自己多试一试哦。</p><h2 id="后记">后记</h2><p>这一次并没有说参数相关的，而是说了这两个怪物，其实从第一篇再到这个第五篇，顺序是按照我个人认为的重要程度来述说的，有点主观啊！但是要是写的话就是说如果有一根线穿连着会不会更加有效一些。因为Perl特别擅长文本处理，而涉及到文本就不得不牵扯到换行啦，打印啦之类的。而这两个特殊变量就是与之相关的，虽然怪异但是这两个变量的确好用。对了，上面的例子都是搭配BEGIN{}和END{}搭配进行的全局的分隔符的设置，其实有时候可以使用<code>local $/ = "&gt;"</code>，<code>local $\ = "\n"</code>，之类的写法来在局部块中进行设置。</p><h2 id="相关">相关</h2><p>有关<code>BEGIN{}</code>和<code>END{}</code>的说明已经在之前的内容中提到了。可以参见：</p><ul><li>perl命令行 -a与 -F参数</li><li>Perl命令行 -M与-I参数</li></ul><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之参数-M和-I</title>
      <link href="/posts/340e5adf.html"/>
      <url>/posts/340e5adf.html</url>
      
        <content type="html"><![CDATA[<p>【上集回顾】</p><p>上次我们看了一下<code>-a</code>与<code>-F</code>这两个搭档，男女搭配干活不累~~</p><p>这次我们来看一下另外一对搭档~~，参数<code>-M</code>和<code>-I</code>。</p><p>【参数解释】</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-M : 导入模块或者编译指示（Pragmas）到Perl单行程序中</span><br><span class="line">-I : 指定一个用来查找模块位置的路径</span><br></pre></td></tr></tbody></table></figure><h2 id="用法">用法</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perl -Mmodulename</span><br><span class="line">perl -Idirectory</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">perl -M<span class="string">'modulename'</span></span><br><span class="line">perl -I<span class="string">'directory'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意模块名称或者引号要贴着<code>-M</code>，中间不能有空格</strong> <strong>注意路径或者引号要贴着<code>-I</code>，中间不能有空格，如果路径中有空格，务必用引号将其引起来</strong></p><h2 id="实例">实例</h2><h3 id="M">-M</h3><p><strong>目的</strong>：比如我要查看当前路径或者文件名的基名</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先查看一下当前路径</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">/c/Users/tian/Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如我想获得该路径的基名，也就是Desktop</span></span><br><span class="line"><span class="comment"># 使用File::Basename中的basename函数</span></span><br><span class="line"><span class="built_in">pwd</span> | perl -MFile::Basename -n -e <span class="string">'print File::Basename::basename($_)'</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Desktop</span><br></pre></td></tr></tbody></table></figure><p>再来一个例子 如果有一个文件是 <code>123.txt</code>，内容为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name Chinese math english</span><br><span class="line">Mike 90 89 78</span><br><span class="line">Mary 99 96 90</span><br><span class="line">Tom 80 70 60</span><br></pre></td></tr></tbody></table></figure><p><strong>目的</strong>：就是需要计算每个人的总成绩，最后将得到的总分放在这一行的末尾输出。之间用空格隔开</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -MList::Util -a -F<span class="string">"\s+"</span> -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 如果是标题行</span></span><br><span class="line"><span class="string">  if($. == 1){</span></span><br><span class="line"><span class="string">    print "@F"," ","total\n";</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">  # 如果不是标题行</span></span><br><span class="line"><span class="string">    $sum = List::Util::sum(@F[qw/1 2 3/]);</span></span><br><span class="line"><span class="string">    print "@F"," ","$sum\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">name Chinese math english total</span><br><span class="line">Mike 90 89 78 257</span><br><span class="line">Mary 99 96 90 285</span><br><span class="line">Tom 80 70 60 210</span><br></pre></td></tr></tbody></table></figure><h3 id="I">-I</h3><p>假如在当前目录的lib目录中有一个<code>test.pm</code>模块文件，内容为：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个求两个数的和的函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">add</span> </span>{</span><br><span class="line">    <span class="keyword">my</span> ($a,$b) = @_;</span><br><span class="line">    <span class="keyword">return</span> $a+$b;</span><br><span class="line">}</span><br><span class="line"><span class="comment"># 这是一个求两个数的差的函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">subtract</span> </span>{</span><br><span class="line">    <span class="keyword">my</span> ($a,$b) = @_;</span><br><span class="line">    <span class="keyword">return</span> $a-$b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果说我需要在单行程序中使用它，在lib文件夹的上层位置处我们打开<code>git for windows</code>或者终端<code>cd</code>到这个位置：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-a和-F将echo输入过来的数值分开</span></span><br><span class="line"><span class="comment"># 使用-I指定模块的位置</span></span><br><span class="line"><span class="comment"># 使用-M导入模块</span></span><br><span class="line"><span class="comment"># 使用-e读取从管道传来的数值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'123 567'</span> | perl -a -F<span class="string">'\s+'</span> -I./lib -Mtest -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    $num1 = $F[0];</span></span><br><span class="line"><span class="string">    $num2 = $F[1];</span></span><br><span class="line"><span class="string">    # 注意这里函数需要使用全名</span></span><br><span class="line"><span class="string">    # 比如求123 + 567</span></span><br><span class="line"><span class="string">    print "add      : ",test::add($num1,$num2),"\n";</span></span><br><span class="line"><span class="string">    # 比如求123 - 567</span></span><br><span class="line"><span class="string">    print "subtract : ",test::subtract($num1,$num2),"\n";</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">add      : 690</span><br><span class="line">subtract : -444</span><br></pre></td></tr></tbody></table></figure><h2 id="其他实例-选看">其他实例[选看]</h2><ul><li>使用warnings与strict</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mwarnings -Mstrict -e <span class="string">'$n = 1;print $n'</span></span><br></pre></td></tr></tbody></table></figure><p>额，出错了！这么说一直以来我们就写的错误代码？其实假如不使用<code>warnings</code>和<code>strict</code>的情况下，这个程序没有问题，错就错在一般我们声明新的变量要么加<code>my</code> 要么加 <code>our</code> 要么 <code>use vars</code>，假如这里不加任何声明的词语的话就是相当于在BEGIN块中使用<code>use vars</code>来声明该变量。它的作用是它的作用是</p><blockquote><p>在当前包中，该变量为全局变量。同时该变量会在该程序运行期间它的值会被保留</p></blockquote><p>什么意思呢？ 你可以就这样理解，就是这个变量在哪个地方我都可以用，同时在每每读取一行文件文件之前，它的值都是上一次读取文件进来之后进行运算之后的值。也就是变量不会抹去。实际上之前我们常常这样写，而并没有加上<code>warnings</code>和<code>strict</code>。</p><p>举个例子，比如有一个文件<code>123.txt</code>，内容为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 Tom 100</span><br><span class="line">2 Jack 98</span><br><span class="line">3 Mary 92</span><br><span class="line">4 Bess 89</span><br><span class="line">5 Betty 79</span><br><span class="line">6 Mike 78</span><br><span class="line">7 Louie 77</span><br><span class="line">8 Emily 75</span><br><span class="line">9 Leo 75</span><br><span class="line">10 Noah 72</span><br></pre></td></tr></tbody></table></figure><p>如果这是一个成绩排名，我想知道有多少人是80分及其以上的人数和80分一下的人数。这里其实一眼就看出来了，但是请配合一下，我们用程序实现一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  if($F[2] &gt;= 80){</span></span><br><span class="line"><span class="string">    $n += 1;</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    $m += 1;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    print "the number of upper 80 score : $n !\n";</span></span><br><span class="line"><span class="string">    print "the number of lower 80 score : $n !\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the number of upper 80 score : 4 !</span><br><span class="line">the number of lower 80 score : 6 !</span><br></pre></td></tr></tbody></table></figure><p>结果正确，但是如果这样做：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  my ($n,$m);</span></span><br><span class="line"><span class="string">  if($F[2] &gt;= 80){</span></span><br><span class="line"><span class="string">    $n += 1;</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    $m += 1;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    print "the number of upper 80 score : $n !\n";</span></span><br><span class="line"><span class="string">    print "the number of lower 80 score : $n !\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the number of upper 80 score : 1 !</span><br><span class="line">the number of lower 80 score : 1 !</span><br></pre></td></tr></tbody></table></figure><p>结果不对。再试一试这样做：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -Mstrict -Mwarnings -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 声明必须放在BEGIN块中，否则每次读取一行文件就会重新声明该全局变量，它之前的值会被抹掉</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 声明变量</span></span><br><span class="line"><span class="string">    our ($n,$m);</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 该变量已经存在，那么就为了让该变量在接下来的作用域中默认使用这两个变量</span></span><br><span class="line"><span class="string">  our $n;</span></span><br><span class="line"><span class="string">  our $m;</span></span><br><span class="line"><span class="string">  if($F[2] &gt;= 80){</span></span><br><span class="line"><span class="string">    $n += 1;</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    $m += 1;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    print "the number of upper 80 score : $n !\n";</span></span><br><span class="line"><span class="string">    print "the number of lower 80 score : $n !\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the number of upper 80 score : 4 !</span><br><span class="line">the number of lower 80 score : 6 !</span><br></pre></td></tr></tbody></table></figure><p>其实上述的代码可以这样理解。我们来看一下执行的情况的对照关系。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                                               |</span><br><span class="line"><span class="comment"># perl script                                  | # perl one-liners</span></span><br><span class="line">use strict;                                    | perl -Mstrict</span><br><span class="line">use warnings;                                  | perl -Mwarnings</span><br><span class="line">                                               | BEGIN{</span><br><span class="line">                                               |   <span class="comment"># 这里不能使用my声明，如果使用my声明的话，出了BEGIN块，这两个变量就失效了</span></span><br><span class="line">our (<span class="variable">$n</span>,<span class="variable">$m</span>);                                   |   our (<span class="variable">$n</span>,<span class="variable">$m</span>);</span><br><span class="line">                                               | }</span><br><span class="line">open FILE,<span class="string">"&lt;"</span>,<span class="string">"123.txt"</span> or die $!;             | <span class="comment"># 其实在说-e参数的时候就已经说过，除了BEGIN与END块之外，perl的代码块其实是处在类似于whlie(&lt;FILE&gt;)的循环之中</span></span><br><span class="line"><span class="keyword">while</span>(&lt;FILE&gt;){                                 | <span class="built_in">cat</span> 123.txt |</span><br><span class="line">                                               | </span><br><span class="line"><span class="comment"># 仍然在our的作用范围之内                         | # 出了BEGIN代码块，这里需要再次指明使用这两个变量</span></span><br><span class="line">                                               | our (<span class="variable">$n</span>,<span class="variable">$m</span>);</span><br><span class="line">    my @F = <span class="built_in">split</span> /\s+/,<span class="variable">$_</span>;                    | </span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$F</span>[2] &gt;= 80){                           | <span class="keyword">if</span>(<span class="variable">$F</span>[2] &gt;= 80){</span><br><span class="line">        <span class="variable">$n</span> += 1;                               |   <span class="variable">$n</span> += 1;</span><br><span class="line">    }<span class="keyword">else</span>{                                     | }<span class="keyword">else</span>{</span><br><span class="line">        <span class="variable">$m</span> += 1;                               |   <span class="variable">$m</span> += 1;</span><br><span class="line">    }                                          | }</span><br><span class="line">}                                              |</span><br><span class="line">                                               | END{ </span><br><span class="line"><span class="built_in">print</span> <span class="string">"the number of upper 80 score : <span class="variable">$n</span> !\n"</span>; |   <span class="built_in">print</span> <span class="string">"the number of upper 80 score : <span class="variable">$n</span> !\n"</span>;</span><br><span class="line"><span class="built_in">print</span> <span class="string">"the number of lower 80 score : <span class="variable">$n</span> !\n"</span>; |   <span class="built_in">print</span> <span class="string">"the number of lower 80 score : <span class="variable">$n</span> !\n"</span>;</span><br><span class="line">                                               | }</span><br></pre></td></tr></tbody></table></figure><p>也许你会这么写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'</span></span><br><span class="line"><span class="string">use strict;</span></span><br><span class="line"><span class="string">use warnings;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my ($n,$m);</span></span><br><span class="line"><span class="string">open FILE,"&lt;","123.txt" or die $!;</span></span><br><span class="line"><span class="string">while(&lt;FILE&gt;){</span></span><br><span class="line"><span class="string">    my @F = split /\s+/,$_;</span></span><br><span class="line"><span class="string">    if($F[2] &gt;= 80){</span></span><br><span class="line"><span class="string">        $n += 1;</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">        $m += 1;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print "the number of upper 80 score : $n !\n";</span></span><br><span class="line"><span class="string">print "the number of lower 80 score : $n !\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>这么写没错，运行结果很对，但是有点违背初衷了，就是简洁的写法，但是其实解决了问题这个写法也不是不可以。</p><p>好了，这个例子主要是想告诉大家，有关-e参数后引号里面的代码的运行情况，其实与strict和warnings没多大干系。</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之参数-a和-F</title>
      <link href="/posts/d4df8203.html"/>
      <url>/posts/d4df8203.html</url>
      
        <content type="html"><![CDATA[<p>【上集回顾】</p><p>上次说到了<code>-p</code>与<code>-n</code>参数，其实再加上之前学的<code>-e</code>参数已经可以做很多事情了，但是为了方便，Perl还有这样一对搭档组合的参数，就是<code>-a</code>和<code>-F</code></p><p>【参数解释】</p><blockquote><p><strong>-a</strong> : 将读入的<code>$_</code>进行分割，保存到<code>@F</code>列表之中，类似于<code>split /分隔符/ , $_;</code> 而这个分隔符是由<code>-F</code>参数指定的，其实这个功能与awk工具相似</p></blockquote><blockquote><p><strong>-F</strong> : 在添加<code>-a</code>参数时候，指定分隔符（可以是正则表达式），如果不加好像是由空格作为分隔符，一般对其进行设置</p></blockquote><h2 id="实例说明">实例说明</h2><p>为了更加清晰的说明，还是举例子吧，打开终端或者git for windows</p><p>输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如我需要把来自管道的数据按照空格分隔成一个一个单元，存到列表里面</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"qwe asd zxc"</span> | perl -n -a -F<span class="string">"\s+"</span>-e <span class="string">'</span></span><br><span class="line"><span class="string">  $" = "\n";</span></span><br><span class="line"><span class="string">  foreach my $item (@F){</span></span><br><span class="line"><span class="string">      print "$item\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">qwe</span><br><span class="line">asd</span><br><span class="line">zxc</span><br></pre></td></tr></tbody></table></figure><p>这次的例子要比之前的例子复杂一点，我来一一说明</p><ol><li><code>echo</code>在屏幕上打印出qwe asd zxc这个字符串，这字符串中间由空格分成三个部分，分别是qwe、asd、zxc</li><li><code>echo</code>的输出进入管道 |</li><li>被<code>perl</code>逐行读取（因为只有一行，所以直接读完了）</li><li>读取的字符串赋值给<code>$_</code></li><li><code>$_</code>被分割为三份（应<code>-a</code>的要求，根据<code>-F</code>（注意双引号是贴着-F参数的，中间没有空格隔开）的指定的\s+（意思是按照一个或者多个空格或者制表符分隔，这里也可以改为" +"），将<code>$_</code>分割为三份）</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qwe asd zxc</span><br><span class="line">   ^   ^</span><br><span class="line">   |   |</span><br><span class="line">   空格</span><br><span class="line"></span><br><span class="line"># 根据空格来划分 \s+ 表示如果有多个空格相连也一并视为一个整体</span><br><span class="line"># 切割之后，空格都消失</span><br><span class="line"></span><br><span class="line">    /   /</span><br><span class="line">qwe/asd/zxc    成为 @F中的元素  ('qwe','asd','zxc')</span><br><span class="line">  /   /</span><br></pre></td></tr></tbody></table></figure><ol><li>分隔的三份按照顺序存在<code>@F</code>列表中</li><li>遍历<code>@F</code>列表，将其中的内容打印出来</li></ol><p>其实你可能会说，用之前之前学的参数就够了啊！比如</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"qwe asd zxc"</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    my @F = split /\s+/,$_;</span></span><br><span class="line"><span class="string">    $" = "\n";</span></span><br><span class="line"><span class="string">    print "@F\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>那为什么要这样做呢？其实在平常的文本中比没有感觉到，在linux或者mac系统下面，有很多信息就是以文本的形式给出来的，而且中间一般都是用空格或者制表符分隔的，就比如使用df命令查看磁盘使用情况</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">C:/Program Files/Git 104857596  63822260  41035336  61% /</span><br><span class="line">D:                   318168060 313664144 125465657  40% /d</span><br><span class="line">E:                    41942012  21699268  20242744  52% /e</span><br></pre></td></tr></tbody></table></figure><p>可以看到很鲜明的由空格或者制表符分隔的信息形式。 问题来了，利用这两个参数，我们可以试着做一下事情</p><p><strong>问题1：我需要将所有的盘符提取并打印出来？</strong></p><p>来试一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  print $F[0],"\n";</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Filesystem</span><br><span class="line">C:/Program</span><br><span class="line">D:</span><br><span class="line">E:</span><br></pre></td></tr></tbody></table></figure><p>可是标题行不是我想要的，怎么除去呢？ 有多种方法</p><ol><li>使用特殊变量<code>$.</code></li></ol><blockquote><p><code>$.</code>意为当前读取的行数</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 第一行就是标题行了，直接跳过它</span></span><br><span class="line"><span class="string">  if($. == 1){</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    print $F[0],"\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">C:/Program</span><br><span class="line">D:</span><br><span class="line">E:</span><br></pre></td></tr></tbody></table></figure><ol><li>借助Linux命令</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk中NR为内置变量，与上面的perl中的 $. 变量意义相同，就是当前读取的行数</span></span><br><span class="line"><span class="built_in">df</span> | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  print $F[0],"\n";</span></span><br><span class="line"><span class="string">'</span> | awk <span class="string">'NR&gt;1{print $0}'</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">C:/Program</span><br><span class="line">D:</span><br><span class="line">E:</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：你发现在现实盘符的时候<code>C:/Program Files/Git</code>显示的是不完整的，只显示了<code>C:/Program</code>，也就是它被分隔了！！这里要说明一下，文件夹是可以使用空格的（特别是像windows下面的系统文件夹<code>C:/Program Files</code>，的确是很烦人），这个时候使用空格分隔则要小心，一般在linux和mac下面碰不到这种情况。这里为了演示更加方便，然后便于初次的讲解，我把C盘排除掉。但是要是的确有需要加入C盘来进行处理也是可以进行的，只是有点复杂，这里我不叙述，在文章末尾我进行一下探讨。</p><p><strong>问题2：我要计算D盘和E盘总共已经使用的磁盘的内存（排除了C盘，原因见上述说明）</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与上面一样，还是将df命令的结果读取进来，然后分隔成各个元素存到@F中去</span></span><br><span class="line"><span class="built_in">df</span> | perl -n -a -F<span class="string">"\s+"</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">BEGIN{</span></span><br><span class="line"><span class="string">  $total = 0;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">chomp;</span></span><br><span class="line"><span class="string"># 排除C盘</span></span><br><span class="line"><span class="string">if(m/^C:/){</span></span><br><span class="line"><span class="string">  next;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">if($. == 1){</span></span><br><span class="line"><span class="string">  next;</span></span><br><span class="line"><span class="string">}else{</span></span><br><span class="line"><span class="string">  $total = $total + $F[2];</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">END{</span></span><br><span class="line"><span class="string">  print "total use : $total\n";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">total use : 335363412</span><br></pre></td></tr></tbody></table></figure><p>上面用到了两个特殊的代码块<code>BEGIN{}</code>和<code>END{}</code>，这两个代码块在perl的单行程序中会经常用到，说明一下它们两个的作用：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 单行程序中的结构          # 流程解释</span><br><span class="line">_________________________________________________________</span><br><span class="line">BEGIN{              |       +++++++++ 读取文件之前</span><br><span class="line">  代码1;            |       + 代码1 +  就运行代码1</span><br><span class="line">}                   |       +++++++++  只运行一次</span><br><span class="line">                    |</span><br><span class="line">                    |       ---&gt; ++++</span><br><span class="line">                    |       ---&gt; +代+  然后每次读取一行</span><br><span class="line">代码2;              |       ---&gt; +码+  运行一下代码2</span><br><span class="line">                    |       ---&gt; +2 +</span><br><span class="line">                    |       .... ++++</span><br><span class="line">                    |</span><br><span class="line">END{                |       +++++++++ 最后文件读取完毕</span><br><span class="line">  代码3;            |       + 代码3 + 运行代码3</span><br><span class="line">}                   |       +++++++++ 只运行一次</span><br><span class="line">_________________________________________________________</span><br></pre></td></tr></tbody></table></figure><p>其实<code>BEGIN{}</code>与<code>END{}</code>块放的顺序和位置并不重要，也就是说可以这样</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 形式1</span><br><span class="line"></span><br><span class="line">BEGIN{  </span><br><span class="line">  代码1;</span><br><span class="line">}       </span><br><span class="line">END{    </span><br><span class="line">  代码3;</span><br><span class="line">}  </span><br><span class="line">代码2;  </span><br><span class="line">------------------</span><br><span class="line"># 形式2</span><br><span class="line">END{    </span><br><span class="line">  代码3;</span><br><span class="line">}</span><br><span class="line">代码2;</span><br><span class="line">BEGIN{  </span><br><span class="line">  代码1;</span><br><span class="line">} </span><br><span class="line">------------------</span><br><span class="line"># 形式3</span><br><span class="line">代码2; </span><br><span class="line">BEGIN{  </span><br><span class="line">  代码1;</span><br><span class="line">}       </span><br><span class="line">END{    </span><br><span class="line">  代码3;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>其实除了这些由空格分隔的，我们平常使用的excel中的两个格式也是由特定的字符分隔的：</p><ul><li><strong>CSV</strong>文件 : 由逗号分隔的文本文件</li><li><strong>TSV</strong>文件 : 由制表符分割的文本文件</li></ul><p>对于这种文件，使用这两个参数进行搭配，就省了很多事儿，是吧</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例如一个文件 123.csv</span><br><span class="line"># 新建一个txt文本文件，将后缀名改成csv就可以</span><br><span class="line"># 内容为</span><br><span class="line">name,apple,banana,orange,grape,strawberry</span><br><span class="line">color,red,yellow,orange,purple,red</span><br></pre></td></tr></tbody></table></figure><ul><li>示例1</li></ul><p><strong>目标</strong>：打印出第一列，也就是标题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.csv | perl -n -a -F<span class="string">","</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  print "$F[0]\n";</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">name</span><br><span class="line">color</span><br></pre></td></tr></tbody></table></figure><ul><li>示例2</li></ul><p><strong>目标</strong>：计算出现了多少种颜色</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.csv | perl -n -a -F<span class="string">","</span> -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 如果第一列是color就执行代码</span></span><br><span class="line"><span class="string">  if($F[0] eq '</span>color<span class="string">'){</span></span><br><span class="line"><span class="string">    # 将第一个元素给扔掉</span></span><br><span class="line"><span class="string">    shift @F;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    for my $color (@F){</span></span><br><span class="line"><span class="string">      # 利用哈希对重复的颜色的合并</span></span><br><span class="line"><span class="string">      # 而不是简单的记录这个列表中有多少元素</span></span><br><span class="line"><span class="string">      # 因为存在重复的颜色</span></span><br><span class="line"><span class="string">      # 红色是两份，它的值为2</span></span><br><span class="line"><span class="string">      $hash{$color}++;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 使用scalar方法得到哈西键的个数</span></span><br><span class="line"><span class="string">    print "Total number of color type : ",scalar(keys %hash),"\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Total number of color <span class="built_in">type</span> : 4</span><br></pre></td></tr></tbody></table></figure><ul><li>示例3 <strong>目标</strong>：按照下面那样的方式打印出来(之间是逗号相隔开)，这个其实就是列表的翻转，这个例子稍微有点复杂，这个例子意义其实不大。但是结合了多个perl单行程序</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name,color</span><br><span class="line">apple,red</span><br><span class="line">banana,yellow</span><br><span class="line">orange,orange</span><br><span class="line">grape,purple</span><br><span class="line">strawberry,red</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码开始</span></span><br><span class="line"><span class="built_in">cat</span> 123.csv | perl -n -a -F<span class="string">","</span> -e <span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # 因为没有去处换行符，所以每一个元素后面均会带有回车符和换行符</span></span><br><span class="line"><span class="string">  # 这里将其除去</span></span><br><span class="line"><span class="string">  $F[-1] =~ s/\r*\n//;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  my $title = shift @F;</span></span><br><span class="line"><span class="string">  my @items = @F;</span></span><br><span class="line"><span class="string">  my $item_num = scalar(@items) unless defined $item_num;</span></span><br><span class="line"><span class="string">  $title_num++;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 列表里面的原始是有序的</span></span><br><span class="line"><span class="string">  # 用它来记录有顺序的title</span></span><br><span class="line"><span class="string">  push @title_list,$title;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 哈希里面的元素是无序的</span></span><br><span class="line"><span class="string">  # 用它来记录每个title对应的该行的元素</span></span><br><span class="line"><span class="string">  $hash{$title} = \@items;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    $" = ",";</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 先输出标题行</span></span><br><span class="line"><span class="string">    print "@title_list\n";</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 然后打印出各个元素</span></span><br><span class="line"><span class="string">    for my $row (0..$item_num-1){</span></span><br><span class="line"><span class="string">      for my $key (@title_list){</span></span><br><span class="line"><span class="string">        print $hash{$key}-&gt;[$row];</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        print ",";</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      print "\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> | perl -p -e <span class="string">'s/,$//'</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">name,color</span><br><span class="line">apple,red</span><br><span class="line">banana,yellow</span><br><span class="line">orange,orange</span><br><span class="line">grape,purple</span><br><span class="line">strawberry,red</span><br></pre></td></tr></tbody></table></figure><h2 id="补充说明">补充说明</h2><ul><li>-a与-F参数的顺序不重要，但是一定要放在-e参数之前</li><li>-F指定分隔符的时候后面的分隔符要贴着-F参数，中间不要有空格之类，否则会报错</li></ul><h2 id="探讨">探讨</h2><p>上面说到有时候文件夹会出现空格的情况，像上面出现的<code>C:/Program Files/Git</code>被分隔的情况。那这样难道就没有办法来处理吗？再来看一下<code>df</code>的输出结果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">C:/Program Files/Git 104857596  63822260  41035336  61% /</span><br><span class="line">D:                   318168060 313664144 125465657  40% /d</span><br><span class="line">E:                    41942012  21699268  20242744  52% /e</span><br></pre></td></tr></tbody></table></figure><p>虽然按照空格来分隔可能有些行不通了，但是能不能转换一下思维，按照字符串的数量来划分：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-------------------|---------|---------|---------|----|----------|</span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">C:/Program Files/Git 104857596  63822260  41035336  61% /</span><br><span class="line">D:                   318168060 313664144 125465657  40% /d</span><br><span class="line">E:                    41942012  21699268  20242744  52% /e</span><br></pre></td></tr></tbody></table></figure><p>可以看到每一列对应的字符串长度（空格也会被计算）是一致的 来！试一试：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个时候不能直接用空格分隔了，得采用一些特殊的方法</span></span><br><span class="line"><span class="comment"># 设置行数</span></span><br><span class="line"><span class="built_in">export</span> col=1</span><br><span class="line"><span class="built_in">df</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 设置想要打印的列数</span></span><br><span class="line"><span class="string">    # 传入环境中变量</span></span><br><span class="line"><span class="string">    $col = $ENV{'</span>col<span class="string">'};</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  if($. == 1){</span></span><br><span class="line"><span class="string">    @title_slice = (22,11,11,11,5,11);</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  my $offset = 0;</span></span><br><span class="line"><span class="string">  map {$offset+= $_} @F[0..$col-2] if $col-2 &gt; 0;</span></span><br><span class="line"><span class="string">  print substr($_,$offset,$title_slice[$col-1]-1) =~ s/\s*(.+?)\s*/$1/r,"\n";</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="comment"># 但是这样需要人工去数，也不是个好办法</span></span><br></pre></td></tr></tbody></table></figure><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之参数-p和-n</title>
      <link href="/posts/29e0fbc7.html"/>
      <url>/posts/29e0fbc7.html</url>
      
        <content type="html"><![CDATA[<p><strong>【上集回顾】</strong>： 上一次提到了-e参数，一般在使用perl的单行程序时都会加上-e参数。-e参数就是将后面引号内的内容当作perl代码执行。</p><p>这一次来说一说另外两个常见的-p和-n参数，这两个参数与输入输出相关</p><h2 id="简介">简介</h2><blockquote><p><strong>-p</strong>：将参数当作文件读取进来，并且每次读取一行遍历文件，并把执行-e参数之后的perl代码部分得到默认变量$_打印到标准输出中（可以是屏幕也可以进入管道）。</p><p><strong>-n</strong>：将参数当作文件读取进来，并且每次读取一行遍历文件。</p></blockquote><p>两个看起来共性有点大，那有什么区别呢？</p><p>在之前先来看一个例子吧！</p><h2 id="例子">例子</h2><p>首先新建一个文件 <code>123.txt</code></p><p>里面的内容为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the string is hello</span><br><span class="line">the number is 12345</span><br><span class="line">the float is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>我怎么知道是不是逐行读取的呢？</p><p>在<code>123.txt</code>所在位置右键，打开<code>git bash here</code>或者打开终端<code>cd</code>到当前目录</p><p>输入：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">perl -n -e <span class="string">'++$n;print "$n  $_"'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line"></span><br><span class="line">1  the string is hello</span><br><span class="line">2  the number is 12345</span><br><span class="line">3  the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>可以看到程序部分执行了三次，<strong>文件是逐行读取的</strong>。</p><h2 id="p参数">-p参数</h2><ul><li>示例1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如我想让含有字符串string的行打印出来</span></span><br><span class="line">perl -p -e <span class="string">'m/string/'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the string is hello</span><br><span class="line">the number is 12345</span><br><span class="line">the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>可以看到和原来的文件是没有什么两样的</p><ul><li>示例1.1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">perl -p -e <span class="string">'s/string/number/'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">the number is hello</span><br><span class="line">the number is 12345</span><br><span class="line">the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>第一行和之前的结果不一样了</p><p>但是假如说我想的是“只要那些有string这样字眼的行输出出来呢”？</p><p>于是我就想可不可以这样写:</p><ul><li>示例2</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">perl -p -e <span class="string">'if(m/string/){print $_}'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the string is hello</span><br><span class="line">the string is hello</span><br><span class="line">the number is 12345</span><br><span class="line">the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>可以看到文件第一行输出了两次，也就是说</p><blockquote><p><code>-p</code>参数不管你的代码中有什么判断语句来控制输出，每读取一行都会输出一下<code>$_</code>，这个与代码中的print不会合并，它不管究竟有没有print</p></blockquote><p>那它是输出的什么呢，输出什么时候的<code>$_</code>呢？</p><p>来这样试一下：</p><ul><li>示例3</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -p -e <span class="string">'s/string/number/;s/hello/world/'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the number is world</span><br><span class="line">the number is 12345</span><br><span class="line">the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>传进来文件第一行的变量<code>$_</code>在perl代码中其实变换了两次</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最开始时候：the string is hello</span><br><span class="line">第一次变换：the number is hello</span><br><span class="line">第二次变化：the number is world</span><br></pre></td></tr></tbody></table></figure><p>可以看到，<code>-p</code>参数每次输出的<code>$_</code>的值是它从代码执行最后的值</p><p>再来调戏一下<code>$_</code>：</p><ul><li>示例4</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -p -e <span class="string">'if(m/string/){$_ = "foo\n"}'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">foo</span><br><span class="line">the number is 12345</span><br><span class="line">the <span class="built_in">float</span> is 1.2345</span><br></pre></td></tr></tbody></table></figure><p>第一行已经变了，就是说<code>$_</code>是可以被改变，甚至改变巨大都可以</p><p>那为了刚才我们的目标，可以这样：</p><ul><li>示例5</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不能匹配到 string 就将变量$_设置为空字符串，类似于清空 </span></span><br><span class="line">perl -p -e <span class="string">'if(!m/string/){$_ = ""}'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">the string is hello</span><br></pre></td></tr></tbody></table></figure><p>哈哈！没难倒我们！达到目标了！</p><p>你有没有感觉不太好呢！这里判断条件倒是很简单，所以可以这样做，假如判断条件多了，代码量多了，每次都要这样来思考不是有点不顺吗？</p><p>这样吧，开门见山，有请<code>-n</code>参数登场</p><h2 id="n参数">-n参数</h2><p>先来按照<code>-p</code>的路子试一试<code>-n</code></p><ul><li>示例6</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我想要的是将含有string字符串的行打印出来</span></span><br><span class="line">perl -n -e <span class="string">'m/string/'</span> 123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为：</span></span><br></pre></td></tr></tbody></table></figure><p>是的，什么都没有，的确是这样，不是我码字把它码掉了。其实有了上面的<code>-p</code>的说明，这里<code>-n</code>已经比较明确了，它其他方面的和<code>-p</code>一样，但是他不会输出<code>$_</code>，也就是说程序默认不会输出任何东西（当然不包括错误信息在内）</p><p>于是上面的问题就可以这样解了：</p><ul><li>示例7</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -n -e <span class="string">'if(m/string/){print $_}'</span> 123.txt</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">the string is hello</span><br></pre></td></tr></tbody></table></figure><blockquote><p>到了这里大家应该明白了-p和-n的区别，其实对于命令行来说，-p和-n用的都挺多的，就看你需要什么，怎么做起来更快，就选哪一个。</p></blockquote><h2 id="问题">问题</h2><p><strong>问：假如我读取文件不想要后面的换行符出现，输出的时候我自己加换行符，怎么做？</strong></p><p>答：其实和写perl脚本一样，其实可以这样做</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -n -e <span class="string">'chomp;if(/string/){print "$_\n"}'</span> 123.txt</span><br></pre></td></tr></tbody></table></figure><p>也就是加一个chomp。其实除了这种方式，还有一种加上参数<code>-l</code>可以达到先自动<code>chomp</code>，之后自动在<code>$_</code>后面加上<code>\n</code>然后输出</p><p><strong>问：这个-p和-n参数的每行读取文件怎么和那个钻石操作符<code>&lt;&gt;</code>一样啊！</strong></p><p>答：的确是这样的</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平常写perl脚本我们一般写</span></span><br><span class="line"><span class="keyword">open</span> READ,<span class="string">"&lt;"</span>,<span class="string">"123.txt"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"$!"</span>;</span><br><span class="line"><span class="keyword">while</span>(&lt; READ &gt;){</span><br><span class="line">    ..........;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于单行程序直接就是</span></span><br><span class="line">perl -n -e <span class="string">'........'</span> <span class="number">123</span>.txt</span><br></pre></td></tr></tbody></table></figure><p>这样看来单行程序在写较短程序上比直接去写perl脚本来的快，来的节省</p><p>在这里再引申一下</p><p>如果我有一个fasta文件，假设名称为fasta.fasta 内容为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;cox1</span><br><span class="line">ATGCGATCGTAGCATGCTAGCTACG</span><br><span class="line">ACAAGCTAGCTAGCTAGCAGCATCT</span><br><span class="line">ACGTGCAT</span><br><span class="line">&gt;rpl10</span><br><span class="line">ATGAGCTAGCTAGCTAGACGTACGT</span><br><span class="line">ACGTAG</span><br></pre></td></tr></tbody></table></figure><p>假如在命令行中这样输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -p -e <span class="string">'if(/^&gt;/){$_ = &lt;&gt; || ""}'</span> fasta.fasta</span><br></pre></td></tr></tbody></table></figure><p>输出为</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ATGCGATCGTAGCATGCTAGCTACG</span><br><span class="line">ACAAGCTAGCTAGCTAGCAGCATCT</span><br><span class="line">ACGTGCAT</span><br><span class="line">ATGAGCTAGCTAGCTAGACGTACGT</span><br><span class="line">ACGTAG</span><br></pre></td></tr></tbody></table></figure><p><strong>问：为什么我一直没有输出啊！</strong></p><p>答：你是不是把参数顺序写反了</p><ul><li>错误写法 <code>perl -e -p 'print if /string/' 123.txt</code> <code>perl -e -n 'print if /string/' 123.txt</code> <code>perl -ep 'print if /string/' 123.txt</code></li><li>正确写法 <code>perl -p -e 'print if /string/' 123.txt</code> <code>perl -pe 'print if /string/' 123.txt</code></li></ul><p>第三种情况虽然两个参数并在一起写了，可是有先后顺序，其实第三种就是第一种的写法。也就是说引号对引起来的代码需要靠近-e，而且-e参数一般放在所有参数最后一个</p><h2 id="perl读取文件的方式">perl读取文件的方式</h2><ul><li>放在命令行代码块的末尾</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -n -e <span class="string">'print $_'</span> 123.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>结合Linux工具</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -n -e <span class="string">'print $_'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用文件句柄</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'</span></span><br><span class="line"><span class="string">open FILE,"&lt;","123.txt" or die $!;</span></span><br><span class="line"><span class="string">while(&lt;FILE&gt;){</span></span><br><span class="line"><span class="string">    print $_;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之参数-e</title>
      <link href="/posts/2916cf.html"/>
      <url>/posts/2916cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始单行程序！">开始单行程序！</h2><p><strong>建议</strong>：后面的代码最好你自己也输入一下感受一下</p><p>我是用的Windows进行演示的，在Mac和Linux上也是一样的（<strong>终端</strong>） 首先写几个示例代码</p><h3 id="例子">例子</h3><ul><li>示例1</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'print "Hello World!"'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></tbody></table></figure><ul><li>示例2</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'my $str = '</span>asdfghasd<span class="string">';$str =~ s/a/%/g;print "$str"'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">%sdfgh%sd</span><br></pre></td></tr></tbody></table></figure><ul><li>示例3</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'for(1..10){print "$_ "}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></tbody></table></figure><p>发现规律没， <code>perl -e ''</code> 是他们的共同结构，其中关键的是<code>-e</code>参数，它意思就是</p><blockquote><p>在其后面的引号里面的东西当作perl代码来执行。</p></blockquote><p>这个岂不是不需要写pl脚本就可以做很多事情了。是的，就是这样，不过有些东西有些差别，以后再说。 你现在可以在<code>-e</code>后面的的引号（<strong>建议用单引号，不然可能报错，然后还会牵扯到其他问题</strong>）里面输入perl代码试一试。</p><h2 id="用法">用法</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'代码'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="问题">问题</h2><ul><li><strong>换行</strong></li></ul><p>我想换行继续输入，按了一下回车，结果代码直接执行了。呃，尴尬， 单行程序和之前的写在代码编辑器里面的不一样，假如我们想换行输入代码我们可以这样做，我们先不把引号对打全，只打出单个，也就是这样：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>继续：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'my $str = "asdfghasd";</span></span><br></pre></td></tr></tbody></table></figure><p>按一下回车输入其他内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'my $str = "asdfghasd";</span></span><br><span class="line"><span class="string">$str =~ s/a/%/g;</span></span><br><span class="line"><span class="string">print "$str";</span></span><br></pre></td></tr></tbody></table></figure><p>最后加上末尾的引号，完整代码为：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'my $str = "asdfghasd";</span></span><br><span class="line"><span class="string">$str =~ s/a/%/g;</span></span><br><span class="line"><span class="string">print "$str";'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">%sdfgh%sd</span><br></pre></td></tr></tbody></table></figure><p>有人可能会问，为什么不输入 <code>\</code> 符号来续行呢？好，来试一试：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'my $str = "asdfghasd";\</span></span><br><span class="line"><span class="string">$str =~ s/a/%/g;\</span></span><br><span class="line"><span class="string">print "$str";'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Can<span class="string">'t modify single ref constructor in substitution (s///) at -e line 2, near "s/a/%/g;"</span></span><br><span class="line"><span class="string">Execution of -e aborted due to compilation errors.</span></span><br></pre></td></tr></tbody></table></figure><p>出错了！因为之前说过了，在<code>-e</code>参数之后的引号内东东都会被认为是perl代码，所以这个引号里面不能这么做，在引号外的命令被视为是shell的命令，在shell中的续行的方法就是在代码换行之前输入<code>\</code> 然后再按下回车，就可以继续输入代码了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell代码</span></span><br><span class="line"><span class="built_in">echo</span> 123 \</span><br><span class="line">qwe \</span><br><span class="line">asd</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="built_in">echo</span> 123 qwe asd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">123 qwe asd</span><br></pre></td></tr></tbody></table></figure><p>既然有这种方式，能不能利用一下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'$n = 1;'</span> \</span><br><span class="line">-e <span class="string">'print $n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><p>这种方法利用输入<code>\</code> 实现了续行，但是我们可以看到 <code>\</code> 是不在引号对之内，所以属于shell命令。</p><p><strong>注意</strong>：这里有两个<code>-e</code>参数，之后引号内的内容当作perl命令执行，同时还可以看到，看似我们使用两个<code>-e</code>把程序打断了，变量$n的内容还被保存，没有丢，但是一旦在执行下一个perl命令的时候它就没有了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'$n = 1;'</span> \</span><br><span class="line">-e <span class="string">'print $n'</span> \</span><br><span class="line">| perl -e <span class="string">' print "n is $n\n";'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line">n is</span><br></pre></td></tr></tbody></table></figure><p>变量<code>$n</code>是空的，所以在执行一个perl内的变量会暂时保存，但是一旦用管道隔开，变量就消失了，perl单行程序重新开始。</p><ul><li><strong>引号</strong></li></ul><p>刚才前面说到了在<code>-e</code>参数后面要用<code>''</code>（单引号），最好不要用<code>""</code>（双引号）,不然shell中的变量和perl的变量会搞混</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell中的变量</span></span><br><span class="line">varname=123</span><br><span class="line"><span class="comment"># 然后在perl中声明同样名字的变量</span></span><br><span class="line">perl -e <span class="string">"my <span class="variable">$varname</span> = 'asd';print <span class="variable">$varname</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">syntax error at -e line 1, near <span class="string">"my 123"</span></span><br><span class="line">Execution of -e aborted due to compilation errors.</span><br></pre></td></tr></tbody></table></figure><p>按照错误说明，其实在声明这个变量的时候就出错了，也就是perl外部变量与内部变量的混淆了，为了避免这种事情发生，我建议使用单引号对。</p><p>如果偏要这么做的话也不是不行，那直接转义咯！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">varname=123</span><br><span class="line">perl -e <span class="string">"my \$varname = 'asd';print \$varname"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">asd</span><br></pre></td></tr></tbody></table></figure><p>但是实际上，使用双引号你可能觉得可以进行shell向perl传递变量。但是，每次使用perl自己的变量还要在 $ 前面加上<code>\</code>来转意，这太麻烦了！perl变量传递还有更好的做法，所以不推荐使用双引号对。</p><h2 id="后记">后记</h2><p>其实话说回来，<strong>One-Liners</strong>说的单行程序，一般来说的确就是写在一行上面，也就是说代码量不多的情况下，但其实有的时候还是有必要进行换行的，那样更容易修改和理清程序，这里其实是为了表明Perl是那种很能干的特质，就像在《Learning Perl》这本书里面说的那样：</p><blockquote><p>骆驼长得也有点丑陋，但是它们努力工作，哪怕是在严酷的环境下也一样不辞辛劳。骆驼能在种种不利的条件下帮你把事情搞定，尽管它长相丑陋，气味难闻，偶尔冷不丁的还对你吐上几口口水。</p></blockquote><h2 id="补充">补充</h2><p>今天看《perl技术内幕》突然发现还有一种命令行运行perl代码的方式：</p><ul><li><strong>用法</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入perl之后，在后面写上短横线，然后换行</span></span><br><span class="line">perl - </span><br><span class="line">代码</span><br><span class="line"><span class="comment"># 最后使用__END__标记来结束代码</span></span><br><span class="line">__END__</span><br></pre></td></tr></tbody></table></figure><p>但是我发现这种方法无法接受管道的数据，而且比较丑陋！</p><h2 id="更多">更多</h2><ul><li>目前有人已经写出了一本有关单行程序的书，想要下载的可以移步 [Perl One-Liners书的下载地址](<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ffile.allitebooks.com%2F20150525%2FPerl">https://links.jianshu.com/go?to=http%3A%2F%2Ffile.allitebooks.com%2F20150525%2FPerl</a> One-Liners.pdf)，或者问我要 ^#^</li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.safaribooksonline.com%2Flibrary%2Fview%2Fperl-one-liners%2F9781457185281%2F%3Futm_medium%3Dreferral%26utm_campaign%3Dpublisher%26utm_source%3Doreilly%26utm_content%3Dbuybox">在线阅读</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpkrumins%2Fperl1line.txt">github</a> 也是《Perl One-Liners》这本书的作者的github。</li></ul><p>但是这本书都是介绍的一些小技巧，并没有比较系统的说明各个参数之间的关联以及各个参数的具体功能，但是当你熟知这些参数之后回头去看这本书会得到一定的启发。</p><hr><h2 id="应用">应用</h2><p>其实只是用这样一个参数就可以干活了（因为-e后面的引号内的东西作为perl代码来执行，也就是说某种程度上就是写perl脚本） 例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有一个文件123.txt</span></span><br><span class="line"><span class="comment"># 内容为</span></span><br><span class="line">Hello World!</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># perl</span></span><br><span class="line">perl -e <span class="string">'</span></span><br><span class="line"><span class="string">open FILE,"&lt;","123.txt" or die $!;</span></span><br><span class="line"><span class="string">while(&lt;FILE&gt;){</span></span><br><span class="line"><span class="string">    print $_;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></tbody></table></figure><p>再比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 123.txt | perl -e <span class="string">'</span></span><br><span class="line"><span class="string">while(&lt;&gt;){</span></span><br><span class="line"><span class="string">    print $_;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure><p>但是实际上很多时候并不方便，仅仅使用<code>-e</code>参数孤掌难鸣，<code>-e</code>参数是一个大头，也是必不可少的。俗话说的好，“一个好汉三个帮”，还需要搭配其他的参数来完成更加快捷简洁方便的方法来。</p><p>今天的<code>-e</code>参数就说到这里，后面还有更好玩的参数哦！我刚学perl单行程序，有哪些地方说错了请多多指教，多谢了！</p><h3 id="我学习Perl单行程序的经历">我学习Perl单行程序的经历</h3><p>刚开始看Perl的时候（那时候还没有接触编程的东西），我看到了老师写了一些程序，于是想这个Perl到底是什么样的语言，还可以在那种黑乎乎的东西（shell）里面这样写，当时在网上查了一下各个参数的意思，刚开始不明白，想着这都是些什么玩意啊！就把笔记本丢到一边去了。再后来，我看到了知乎的这个问题，突然想起来还有这个用法，然后慢慢的一边看老师的代码，一边自己练习。慢慢的我就开始使用这门“独门奇招”，谈不上熟练，只是觉得好用，有时候觉得没必要写脚本就迫使自己写单行程序，现在有时候不直接写perl脚本，而是直接上perl单行程序搭配shell的工具使用。</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl One-Liners之前期准备</title>
      <link href="/posts/1d803e51.html"/>
      <url>/posts/1d803e51.html</url>
      
        <content type="html"><![CDATA[<p>简书现在已经广告满天飞（“是兄弟就来砍我”），原本是因为简书的界面的简洁、对于Markdown的渲染比较美观，更因为由很多人在上面把简书当成博客，现在点进去看一些之前产量很高的用户他们最后的一篇文章时间停留在2019年…。简书的这个操作说实话不能理解。（我的简书账号是<a href="https://www.jianshu.com/u/47e00a43ceda">白菜代码小推车</a>）</p><h1>Perl单行程序</h1><p><strong>注</strong>：本内容需要点的perl编程基础，最好是读过《perl语言入门》。</p><p><strong>本系列是自己平常学习工作中的总结，每一个实例均为我为了讲解而设置的，自己试过的，如有错误，望能见谅。</strong></p><p><img src="/posts/1d803e51/perl%E5%8D%95%E8%A1%8C.jpg" alt="perl单行"></p><p>本系列由</p><ul><li>github：<a href="https://github.com/eternal-bug">eternal-bug</a></li><li>简书：<a href="https://www.jianshu.com/u/47e00a43ceda">白菜代码小推车</a></li></ul><p>编写。</p><h2 id="前言">前言</h2><p><em>之前在知乎上看到别人提问</em></p><blockquote><p><a href="https://www.zhihu.com/question/37944158">“你见过哪些令你瞠目结舌的Perl代码技巧?” —— 有的人说是perl可以写诗，有的人就说是perl One-Liners。</a></p></blockquote><p>perl的单行程序在很多时候非常方便，而且可以实现比较复杂的功能，接下来看看它是怎么方便和强大的。</p><h2 id="Perl-One-Liners简介">Perl One-Liners简介</h2><p>我一般就叫 Perl单行程序 ，那与平常写perl脚本有什么区别呢？</p><ul><li>平常写perl脚本</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># 比如打开文件，然后读取文件，逐行打印出来</span><br><span class="line">open FILE, "&lt;", "123.txt" or die $!;</span><br><span class="line">while(&lt;FILE&gt;){</span><br><span class="line">    print $_;</span><br><span class="line">}</span><br><span class="line">close FILE;</span><br></pre></td></tr></tbody></table></figure><ul><li>使用单行程序</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 123.txt | perl -n -e 'print $_'</span><br></pre></td></tr></tbody></table></figure><p>看起来的确是简洁一些，但是实际上简练只是一方面，我的老师曾经说：</p><blockquote><p>有的时候的确是简练，但更重要一点是 ——<strong>“流程化”</strong>。</p></blockquote><p>什么意思呢？其实按照shell编程来看，很多时候都是<strong>很多个工具相互搭配干活</strong>，中间用<strong>管道</strong>将他们哥几个串联起来，这样一前一后这种<strong>流程感</strong>是不是很强烈，有木有。就是知道干了什么事情，比较清晰明白。</p><p>例如某个流程是这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat --&gt; awk --&gt; grep --&gt; perl</span><br><span class="line"></span><br><span class="line">cat  读取文件到标准输入中</span><br><span class="line">awk  预处理</span><br><span class="line">grep 筛选</span><br><span class="line">perl 个性化处理</span><br></pre></td></tr></tbody></table></figure><p>同时，作为单行程序，在shell里面运行是可以利用到linux的工具的，也就是说perl也可以掺和进去，和里面的其他工具搭配干活的，比如<code>cat</code>,<code>echo</code>,<code>ls</code>,<code>pwd</code>,<code>last</code>,<code>find</code>,<code>ps</code>,<code>parallel</code>,<code>sed</code>,<code>grep</code>,<code>awk</code>等等好多工具。</p><p>对比之下有这样一些区别：</p><ul><li>脚本需要写到文件中去然后才能运行，而单行命令的使用与其他命令行工具一样直接在终端或者shell中写代码或者直接复制之前的代码，之后运行就可以。</li><li>单行程序可以搭配众多linux工具，使用管道串联起来，形成流程处理。而编写脚本虽然可以使用反引号或者system()或者exec()可以运行linux工具，但是流程感没有那么强烈。</li><li>单行程序携带方便，比如在自己简书里面放一些代码，到别处只需要登陆简书复制代码就可以运行了。</li><li>单行程序一前一后的流程并不是固定的，不同需求的情况下通过组合流程中的不同部分可以得到需要的结果，将所有处理的过程写到脚本中更改处理顺序不方便，当然也可以把perl单行写到脚本中然后参与shell的命令行的运行也是可以的。</li><li>如果有的时候有些shell命令的用法你忘了，这个时候全部用perl命令行替代它的功能是可以的，就是说其实我感觉像是一些命令<code>sed</code>，<code>grep</code>，<code>awk</code>，<code>sort</code>，<code>wc</code>之类的命令的一些常见用法都可以用perl单行写出来，这样一来很多东西可以统一，但是可能不适用于单行而是适用于bash脚本了。</li><li>另外还有一点我忽略了，在沧浪之水v的博文<a href="https://www.jianshu.com/p/eaf717f852d7">《Perl programming and perl one line》</a>里面提到了perl单行程序对于调试来说很方便，从而不需要IDE来。比如忘了某个函数的用法，你可以在单行里面直接开写，而不用写到文件里面，然后打开终端之后运行文件…</li></ul><p>其实这样看来perl One-Liners有这么多好处，简练、流程化、可以搭配众多Linux大佬工具，那都用它得了。但是如果仅仅只是使用perl来完成所有的事情，那么将perl单行中的代码量增加很多，实际上写接近五十行代码的perl已经不适合用perl One-Liners了，因为在shell里面修改不方便，同时代码的保存也是问题。那个时候好不如写在脚本<code>.pl</code>文件里面了，同时对于使用较多模块，或者自己写包的形式就完全不适合用单行程序了。</p><p>打个比方，可能不太恰当，“perl单行程序就像是自行车，从家里哐当推出去骑着就跑；而写perl脚本就像是摩托车，从家里推车出来都要会儿时间，还得启动，有时候可能熄火；自行车最后跑起来那的确是没有摩托车快，也没有摩托车跑得远，但是它骑上去就开始跑了，轻便快捷，然后还有各种Linux工具的相互配合，进行接力！有时候胜过直接写perl脚本哦”。</p><table><thead><tr><th style="text-align:center">perl单行</th><th style="text-align:center">perl 脚本</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/1d803e51/%E8%87%AA%E8%A1%8C%E8%BD%A6.png" alt="自行车"></td><td style="text-align:center"><img src="/posts/1d803e51/%E6%91%A9%E6%89%98%E8%BD%A6.png" alt="摩托车"></td></tr></tbody></table><p>好，废话少说。在之前先做一下准备工作。</p><p>首先你是用的是什么系统</p><h2 id="Windows"><strong>Windows</strong></h2><p><strong>说明</strong>：做生物信息学推荐使用linux，虽然现在windows 10下面有linux子系统，可能配置某些工具的时候会出点问题。因为我写文章习惯用我的笔记本写，所以我用Windows演示。不过没有关系，我下面的这些perl代码是跨平台的。</p><p>windows下没有包含perl的解释器，你需要先下载一个<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitforwindows.org"><strong>git for windows</strong></a>（不是github for windows）</p><p>或者下载一个完整版的<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.softpedia.com%2Fdyn-postdownload.php%2Fb926b13e000a1479df0450d43614f43f%2F5aa64681%2F3ba60%2F0%2F2"><strong>cmder</strong></a></p><p>这里推荐安装git for windows（虽然cmder完整版包含了git for windows，但是cmder使用的perl单行程序来说有些差别，就是在-e参数后面不能用单引号，需要用双引号，这与Linux和Mac上就有差别了，为了统一，就使用git for windows，然后在windows中的cmd中运行perl命令行程序，只能用双引号引起来，不方便后面的操作，没有Linux命令，不利于后续的使用） 安装好了之后，你会发现你的右键菜单多了点东西</p><ul><li>Git GUI Here</li><li>Git Bash Here</li></ul><p><img src="/posts/1d803e51/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.jpg" alt="右键菜单"></p><p>右键菜单</p><p>如果没有这两个选项，就按照<code>C:\Program Files\Git\git-bash.exe</code>这个路径找</p><blockquote><p>就我现在的理解（我刚用这个软件），就是相当于把linux的shell里面的命令搬到windows下面运行，同时也搬了perl的一些核心功能过来，所以我们就可以用这个软件来使用Linux下面的perl单行程序了！是不是很酷！</p></blockquote><p>我们先试一试perl是不是在这个软件里面，我们在桌面<strong>右键</strong>（其实在别处也可以）（在mac或者linux系统中就打开<strong>终端</strong>），选择 *<strong>Git Bash Here</strong> 这一项（没有这一项就 <code>徽标 + R</code>调出运行面板，在里面输入<code>C:\Program Files\Git\git-bash.exe</code>）</p><p>输入 <code>perl -h</code></p><p><img src="/posts/1d803e51/perl%E5%B8%AE%E5%8A%A9.jpg" alt="perl帮助"></p><p>perl帮助信息</p><p>可以看到这个软件带了perl程序，帮助里面列出来的这些参数是后来要说的。</p><h2 id="Mac或Linux"><strong>Mac或Linux</strong></h2><p>Mac和Linux就干脆一些，它们自带perl，你只需要打开终端就可以，所以不需要前期准备。</p><h2 id="准备写代码">准备写代码</h2><p>经过上面的简单认识和准备之后，后面我会对几个关键的参数进行举例叙述。</p><p><strong>注</strong>：<strong>之前一直觉得在新浪博客上写不方便，现在把原文搬到简书上面了，稍微改了改，加了点内容。</strong></p><p>部分图片来自UI制造者。</p><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterFly主题的调教</title>
      <link href="/posts/c648e0ee.html"/>
      <url>/posts/c648e0ee.html</url>
      
        <content type="html"><![CDATA[<p>最好的是查看官网教程<a href="https://butterfly.zhheo.com/">Butterfly主题美化教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ButterFly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用github和Hexo搭建个人博客</title>
      <link href="/posts/196e9b33.html"/>
      <url>/posts/196e9b33.html</url>
      
        <content type="html"><![CDATA[<p><strong>这个文件会不断更新</strong></p><p>这两天外面下雨闲着没事准备做一个博客，看网上说要什么搞个域名、买个服务器啊、然后部署啊之类的，觉得有点麻烦，我怕这种麻烦会让我还没开始就结束了写博客之旅，所以就准备用<code>github</code>来托管一下博客，这个比较方便。唯一不好的就是国内上<code>github</code>不稳定，网速还慢，但是相较于在<code>CSDN</code>这个<code>（CSDN Steals Documents on Network）</code>上写博客对于身心健康来说是大有脾益的；相较于<code>gitee</code>的代码审核，<code>github</code>可以即时展示。</p><p>本文主要参考的<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>进行，为了简洁，关于工具的详细介绍这里不赘述，只写关键的代码部分。</p><p><strong>注意：下面的操作均是在windows系统上进行。</strong></p><h2 id="介绍">介绍</h2><p>有关于Hexo是什么和github这里不多说，只说说比较的关键的和写博客密切相关的东西。我个人理解的<code>github + Hexo</code>的博客的流程图：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">         编写markdown格式的博文</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">     使用Hexo把markdown转换为html文件</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">       使用Hexo把文件上传到github</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">访问xxx.github.io（github是公网大家都能访问）</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">    github按照对应路径给出对应的静态html文件</span><br><span class="line">                  |</span><br><span class="line">                  v</span><br><span class="line">             浏览器渲染页面</span><br></pre></td></tr></tbody></table></figure><p><code>hexo</code>就是一个比较方便的把你写的markdown的文章按照你指定的主题转换为html文件的工具，也就是说除了hexo你也可以用其他的工具比如Hugo，甚至是你自己手写html然后放到github都可以；github实际上就是按照特定的路径把你事先准备好的html文件给显示出来，这就是托管作用。</p><p>比如可以看<a href="https://github.com/Haojen/haojen.github.io">hexo-theme-Claudia作者的github博客</a>，里面就是按照日期的文件夹，下面对应的就是一个<code>index.html</code>文件，当然了，还会有一些<code>css</code>、<code>js</code>文件。</p><h2 id="安装npm">安装npm</h2><p>下载windows的node：<a href="https://nodejs.org/dist/v18.16.0/node-v18.16.0-x64.msi%EF%BC%8C%E5%8F%8C%E5%87%BB%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://nodejs.org/dist/v18.16.0/node-v18.16.0-x64.msi，双击进行安装。</a></p><p>安装之后打开cmd测试一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在对应的文件夹右键，打开cmd（或者直接在任务栏的搜索里面搜索cmd）。如果没有，我推荐再安装一个ConEmu，然后右键会出现一个<code>ConEmu Here</code>。</p></blockquote><p>安装hexo插件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果出现下面的报错：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! code CERT_HAS_EXPIRED</span><br><span class="line">npm ERR! errno CERT_HAS_EXPIRED</span><br><span class="line">npm ERR! request to https://registry.npm.taobao.org/hexo-asset-image failed, reason: certificate has expired</span><br></pre></td></tr></tbody></table></figure><p>运行下面的代码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line">npm config <span class="built_in">set</span> strict-ssl <span class="literal">false</span></span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="安装git">安装git</h2><p>进入<a href="https://git-scm.com/download/win">git for windows</a>下载<code>git</code>，下载完成之后安装。完成之后在桌面右键，看是否多了两个选项：<code>git GUI here</code>、<code>git bash here</code>。</p><h2 id="初始化博客">初始化博客</h2><p>新建一个文件夹，比如<code>D:/博客/</code>，（这个文件夹是需要比较稳定的，不能放在随手不注意给删除了地方比如桌面之类的）。打开cmd，然后输入：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里文件夹的路径你可以修改为其他位置</span></span><br><span class="line">md D:/博客</span><br><span class="line"><span class="built_in">cd</span> D:/博客</span><br></pre></td></tr></tbody></table></figure><p>进入这个文件夹，之后输出下面的命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个hexo的项目（blog可以更改为你认为合适的名字）</span></span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入新建项目的内部</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 新建一个文章名叫test_my_site</span></span><br><span class="line">hexo new test_my_site</span><br><span class="line"><span class="comment"># 启动本地服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>你会看到在cmd中出现这些文字：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></tbody></table></figure><p>打开浏览器，输入<code>http://localhost:4000</code>，你可以一个Hexo的地平线的网页，表示你创建成功了。</p><h2 id="更改主题">更改主题</h2><p>默认的主题有点历史感，目前我个人喜欢<a href="https://github.com/Haojen/hexo-theme-Claudia">Haojen/hexo-theme-Claudia</a> - <a href="https://haojen.github.io/Claudia-theme-blog/">Demo</a></p><p>如果上面服务开启了，先<code>ctrl + c</code>关闭掉，然后输入下面的命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Haojen/hexo-theme-Claudia.git themes/Claudia</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果上面git clone不下来，可以直接下载<a href="https://codeload.github.com/Haojen/hexo-theme-Claudia/zip/refs/heads/master">hexo-theme-Claudia.zip</a>，然后把文件夹解压放到<code>themes</code>文件夹里面，然后把文件夹名称更改为<code>Claudia</code>。</p></blockquote><p>然后下载这个主题的依赖：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意安装下面的包一定是要在blog根目录下</span></span><br><span class="line"><span class="built_in">cd</span> D:/博客/blog</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-pug </span><br><span class="line">npm install hexo-renderer-dartsass</span><br><span class="line">npm install hexo-generator-search</span><br><span class="line"></span><br><span class="line"><span class="comment"># if you need RSS, you must be install this plugin</span></span><br><span class="line">npm install hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="comment"># Flowchat</span></span><br><span class="line">npm install hexo-filter-flowchart        </span><br><span class="line"><span class="comment"># Math</span></span><br><span class="line">npm install hexo-renderer-mathjax</span><br></pre></td></tr></tbody></table></figure><p>打开<code>blog/_config.yml</code>文件，将下面这一行修改为：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">Claudia</span></span><br></pre></td></tr></tbody></table></figure><p>保存，再次输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>继续在浏览器中输入<code>http://localhost:4000</code>查看主题是否更改了。</p><h2 id="编写文章">编写文章</h2><p>写的文章都是放在<code>D:/博客/blog/source/_posts</code>下面，你可以看到之前我们生成的<code>test-my-site.md</code>文件，这里的笔记都是使用<code>markdown</code>格式编写的，如果不了解这个格式可以搜索<a href="https://markdown.com.cn/basic-syntax/">markdown语法</a>学习。</p><p>比如这里我想写一个新的文章，名叫<code>使用github和Hexo搭建个人博客</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"使用github和Hexo搭建个人博客"</span></span><br></pre></td></tr></tbody></table></figure><p>然后里面写上这些内容：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用github + Hexo搭建个人博客</span><br><span class="line">date: 2023-06-17 22:31:58</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 安装node</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 安装git</span></span><br><span class="line"></span><br><span class="line"><span class="section">## ...</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意文章中<code>title</code>、<code>date</code>、<code>tags</code>之类的东西不要删除掉，这是用来对文章进行排序和显示博文标题的。</p></blockquote><p>以后在编写文章的时候推荐使用一个markdown的编辑器，我这里用的是<code>Typora</code>的历史版本（免费的那一版，我是用的<code>0.9.92</code>版），然后可以在里面编写好粘贴在使用<code>hexo new</code>生成的文件下面，然后修改一下<code>title</code>、<code>date</code>、<code>tags</code>的内容。</p><h2 id="其他调整">其他调整</h2><p>有一些信息是默认的，需要更改为自己的信息，下面是一些常见的需要更改的地方：</p><p><strong>1) Hexo的配置文件</strong></p><p>这里打开的是<code>blog/_config.yml</code>文件，里面的这几项最好修改：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你的博客的站点的名称</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">eternal-bug的博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">"打不死的小强"</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"一个喜欢牵着骆驼、带着闪亮的R形状的戒指的白菜哥。"</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">"生物信息"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">eternal-bug</span></span><br><span class="line"><span class="comment"># 语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站地址（更改为你自己的github博客的地址）</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://eternal-bug.github.io</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意，yml格式的<code>:</code>后面一定要有一个空格，不然这个会识别不出来，除了中文文字和句子中的标点之外，其他所有逗号空格，都需要是在英文输入状态下输入。</p></blockquote><h2 id="上传到github">上传到github</h2><p>现在是在本地查看，需要将这些东西上传到github上可以让其他人能访问到。</p><p><strong>1) github注册</strong></p><p>如果你没有github，需要注册一个github，新建一个GitHub账号，具体怎么申请，这里不赘述，如果有你直接登录就可以。</p><p><strong>2) 新建仓库</strong></p><p>申请好账号和登录github之后，你需要点击右上角的<code>+</code>，然后<code>New repository</code>，在<code>Repository Name</code>下面填上<code>你的github名字.github.io</code>（<strong>必须这么写</strong>，比如我的github的名字是<code>eternal-bug</code>，那么我就写上<code>eternal-bug.github.io</code>），其他的不用动，只需要给<code>Add a README.md</code>前面打勾。这个时候你可以打开<code>https://eternal-bug.github.io/</code>就已经可以访问了（<code>eternal-bug</code>更改为你的github的名字），只不过是默认页面。</p><p><strong>3) 添加SSH关联</strong></p><p>因为上传是需要口令的，这里需要申请一个口令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.name eternal-bug</span><br><span class="line"><span class="comment"># 输入申请github账号时候的邮箱</span></span><br><span class="line">git config --global user.email xxxxxxxxxx@qq.com</span><br></pre></td></tr></tbody></table></figure><blockquote><p>第一次登录时，Git会提示你输入密码，但出于保密因素，除“Enter your password: ”这行系统提示消息外，命令行不会显示任何字符，也不会在你输入或删除字符时用增减星号（井号）表示，因此输入密码时，最好放慢速度，避免因打字过快而输错。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 申请口令</span></span><br><span class="line">ssh-keygen -t rsa -C xxxxxxxxxx@qq.com</span><br></pre></td></tr></tbody></table></figure><p>会弹出下面的话，直接回车就好了（这是是让你上传github代码的时候输入的密码，因为这是我自己的电脑，密钥文件也是存在我这里这里，所以这个不需要设置密码）：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/c/Users/tanglab_lzh/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></tbody></table></figure><p>完成之后，会在你的电脑的<code>C:\Users\XXX\.ssh</code>下面有（XXX表示你的电脑的用户名字）</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br></pre></td></tr></tbody></table></figure><p>两个文件。打开<code>id_rsa.pub</code>，然后按下<code>ctrl+a</code>选中所有的文本。</p><p>再次进入到github的界面，<code>点击个人头像</code>-&gt;<code>Setting</code>-&gt;点击<code>SSH and GPG keys</code>-&gt;点击SSH keys右侧<code>New SSH key</code>，在<code>title</code>里面填上你自己认识的名称，然后在key一栏中粘贴刚才从<code>id_rsa.pub</code>文件中复制过来的内容。点击<code>Add SSH key</code>完成口令的添加。</p><p><strong>4) 上传</strong></p><p>修改<code>blog/_config.yml</code>中的对应内容，拉到最下面：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:eternal-bug/eternal-bug.github.io.git</span></span><br><span class="line">  <span class="comment"># 早些时候github主分支是master，但是从2020年10月01日开始美国为了政治正确，将master分支名称更改为了main，所以这里与时俱进写为main</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></tbody></table></figure><p>回到本地，现在需要上传，进入<code>blog</code>文件夹，然后输入：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理之前生成的静态文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 将文件推到github上面</span></span><br><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><p>如果出现：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host 'github.com (xx.xxx.xxx.xxx)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxx/xxxxxxx/xxxx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])?</span><br></pre></td></tr></tbody></table></figure><p>输入<code>yes</code>，回车，如果出现：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase</span><br></pre></td></tr></tbody></table></figure><p>直接回车。</p><p>最后如果出现：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></tbody></table></figure><p>表示上传成功，这个时候可以去你的github上查看。</p><blockquote><p><strong>注意</strong></p><p>因为之前很多教程是让把<code>branch: </code>写为<code>branch: master</code>的，如果你上传之后发现github的博客文件夹中的文件没有变化，这是因为现在主分支是<code>main</code>，一般可以把<code>master</code>合并到<code>main</code>中，但是相对于来说步骤比较多，这里直接把<code>branch: master</code>更改为<code>branch: main</code>然后再<code>hexo g</code>一次就可以了。</p></blockquote><h2 id="查看效果">查看效果</h2><p>打开网址<code>https://eternal-bug.github.io</code>查看效果（这里你需要把<code>eternal-bug</code>更改为你的github的名字）。如果显示github的404，检查一下你在<code>New repository</code>生成的文件的名称是否正确。</p><h2 id="更多优化">更多优化</h2><p>这里我们只是测试了一下基本的功能，把最主要的步骤走了一遍，但是页面不是很好看细节不够，还有更加丰富的东西去探索。</p><h3 id="分门别类">分门别类</h3><p><strong>0) 博客项目说明</strong></p><p><code>blog/public</code>的目录下没有一个<code>README.md</code>文件，在你的github的页面，比如<code>https://github.com/eternal-bug/eternal-bug.github.io</code>下面，点进去没有介绍，这个不是必要的，但是为了更加完整，可以在上面执行<code>hexo g</code>把本地的文件上传的时候，放一个<code>README.md</code>到<code>blog/public</code>里面，当然你可以一直放在这个文件夹里面随时更改。</p><p><strong>1) 文章标签</strong></p><p>在写的博文多了之后，如果按照时间线或者一页一页的去找是很麻烦的（不过<code>Claudia</code>主题包含了全文搜索的功能可以用一下），需要对文章分类，可以通过打标签的方式去给博文分类。</p><p>在生成文章的时候你应该发现文章头里面有一个：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 使用github和Hexo搭建个人博客</span><br><span class="line">tags:</span><br></pre></td></tr></tbody></table></figure><p>这样的东西，它是用来标记这篇文章的信息的，其中<code>tags</code>就是这篇文章的标签啦，你可以自己增加一些标签：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 使用github和Hexo搭建个人博客</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="bullet">  -</span> github</span><br><span class="line"><span class="bullet">  -</span> 博客</span><br></pre></td></tr></tbody></table></figure><p><strong>2) 文章分类</strong></p><p>除了标签之外，还有分类。</p><p><strong>3) 关于页面</strong></p><p>一个博客没有关于自己的页面你写着博客就没劲啊，在这里可以介绍一下自己。</p><p><strong>4) 404页面</strong></p><p>如果不设置这个页面，在网页访问出错（比如原来你写了某一篇博客，但是后来更改了名称或者删除，别人保存了网址书签，再去访问）会出现的页面，如果不设置<code>404</code>的页面，会简单的弹出灰扑扑的<code>404</code>怼到浏览器面前。</p><h3 id="嵌入图片">嵌入图片</h3><p><strong>1) 图片</strong></p><p>在编写文章的时候，内部插入的图片的方法是可以将图片放在本地，然后在typora中编辑markdown文件写<code>![image](/path/to/image.jpg)</code>等等方式，这样做本地可以显示，在hexo将博客上传到github的时候就没了，需要按照特定的方式来放图片以便hexo可以将图片上传到github，以github作为图床来得到图片的路径，下面是具体做法：</p><p>安装npm的包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></tbody></table></figure><p>找到npm安装包的路径<code>D:/博客/node_modules/hexo-asset-image/index.js</code>，将它的内容替换为如下内容：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line">     </span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) {</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">}</span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">'.'</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">'after_post_render'</span>, <span class="keyword">function</span>(<span class="params">data</span>){</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>){</span><br><span class="line">       <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">   <span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">   <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++){</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], {</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      });</span><br><span class="line">     </span><br><span class="line">      $(<span class="string">'img'</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">       <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>)){</span><br><span class="line">           <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">           <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>).<span class="title function_">replace</span>(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">           <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">              !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) {</span><br><span class="line">             <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">             <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">             <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">'/'</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>){</span><br><span class="line">               <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">             });</span><br><span class="line">             <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">'/'</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>){</span><br><span class="line">               <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">             });</span><br><span class="line">             <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">               srcArray.<span class="title function_">shift</span>();</span><br><span class="line">             src = srcArray.<span class="title function_">join</span>(<span class="string">'/'</span>);</span><br><span class="line">             $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">             <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">"update link as:--&gt;"</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">           }</span><br><span class="line">       }<span class="keyword">else</span>{</span><br><span class="line">           <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">       }</span><br><span class="line">      });</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>编辑<code>blog</code>文件夹下的<code>_config.yml</code>文件，将第43行的：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>替换为：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>保存一下。</p><p>这个时候新建一个博客用来测试图片：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"测试图片"</span></span><br></pre></td></tr></tbody></table></figure><p>在新建博客之后，会有一些与之前不一样的地方，除了生成一个<code>测试图片插入.md</code>文件之外，还额外多了一个一摸一样名字的文件夹<code>测试图片插入</code>，这里你随便找一张图片比如叫<code>test.jpg</code>放到这个文件夹里面。</p><p>在对应的markdown文件中写上：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">image</span>](<span class="link">test.jpg</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后hexo本地预览一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>之前你写的博客也想要添加图片？可以手工在<code>blog/source/_posts</code>下建立一个和文章markdown文件相同名称的文件夹，把图片放进去，更改markdown文件，用hexo再生成一下就行了。</p><p><strong>2) 字体</strong></p><h3 id="评论系统">评论系统</h3><p>为了方便我使用的基于GitHub Discussions的评论的<code>giscus</code>插件，好处是自己方便，访客不是太方便，他们想要评论需要登录github，授权github作为评论账号。具体做法如下：</p><p><strong>1. 创建github仓库</strong></p><p>进入你自己的github界面，点击头像，选择<code>your repositories</code>，点击<code>New</code>新建一个仓库，名称我这里就写为<code>giscus</code>，点击<code>Create repositories</code>（一定不要设置为<code>Private</code>）。这个时候是位于这个仓库下面，点击仓库的<code>Setting</code>，找到<code>Features</code>，下面有一个<code>Discussions</code>栏目前面有一个小框，给小框打上勾。</p><p><strong>2. 安装giscus应用</strong></p><p>点击这个链接<a href="https://github.com/apps/giscus">giscus github apps</a>，点击<code>Install</code>，在下面的选项中选择<code>Only select repositories</code>，选择你刚才新建的那个仓库（这里我就是选的<code>eternal-bug/giscus</code>）。点击<code>Install</code>。</p><p><strong>3. giscus配置</strong></p><p>点击这个链接<a href="https://giscus.app/zh-CN">giscus配置</a>，拉到<code>仓库</code>这里，有一个输入框，输入框里面填上仓库的名称（这里我填写的是<code>eternal-bug/giscus</code>），在页面映射部分选择<code>Discussion 的标题包含页面的URL</code>，然后在<code>Discussion 分类</code>的下拉框里面选择<code>Announcements</code>。</p><p><strong>4. 复制代码到github中</strong><br>在<code>启用 giscus</code>下面有一段代码，你复制这个代码放到你markdown文章的末尾：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://giscus.app/client.js"</span></span><br><span class="line">        data-repo=<span class="string">"eternal-bug/giscus"</span></span><br><span class="line">        data-repo-id=<span class="string">"xxxxxxxxxxxxx"</span></span><br><span class="line">        data-category=<span class="string">"Announcements"</span></span><br><span class="line">        data-category-id=<span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">        data-mapping=<span class="string">"url"</span></span><br><span class="line">        data-strict=<span class="string">"0"</span></span><br><span class="line">        data-reactions-enabled=<span class="string">"1"</span></span><br><span class="line">        data-emit-metadata=<span class="string">"0"</span></span><br><span class="line">        data-input-position=<span class="string">"bottom"</span></span><br><span class="line">        data-theme=<span class="string">"preferred_color_scheme"</span></span><br><span class="line">        data-lang=<span class="string">"zh-CN"</span></span><br><span class="line">        crossorigin=<span class="string">"anonymous"</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>注意：不要放在代码框中。</p><p>除此之外，使用<code>Twikoo</code>插件你可以将评论系统保存在腾讯云上，评论的时候游客只需要在相应的文本框中填入必要的信息即可评论，详细可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/645394881">Hexo + Butterfly 评论功能</a>。</p><h3 id="搜索系统">搜索系统</h3><p>后面在研究一下。</p><h3 id="嵌入多媒体">嵌入多媒体</h3><p><strong>emoji支持</strong></p><p>安装一个库就可以：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:/博客/blog</span><br><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p>然后打开<code>_config.yml</code>文件，在里面<strong>新增</strong>下面的配置信息：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">inject:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></tbody></table></figure><p><strong>网易云音乐</strong></p><p>比如你想添加一个网易云音乐的播放按钮，你可以在markdown中添加这个代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1956202531&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1956202531&amp;auto=0&amp;height=66"></iframe><p>上面的<code>auto</code>设置为<code>0</code>是不自动播放，设置为<code>1</code>是自动播放。</p><blockquote><p>如何查找你想要的歌曲的代码呢？首先打开<a href="https://music.163.com/">网易云音乐</a>（其他的音乐我暂时还没尝试应该也可以），搜索或者查找到你想要的歌曲，这里我查找《快乐老家》，点击“生成外链播放器”，把文本框里面的<code>&lt;iframe&gt;...&lt;/iframe&gt;</code>复制过来，直接粘贴到markdown相应的位置（不需要放到代码框里面）。</p></blockquote><p><strong>bilibili的视频</strong></p><p>比如你想添加一个b站的视频的播放界面，可以在对应的视频下面比如<a href="https://www.bilibili.com/video/BV1hT4y1Y7RF/?spm_id_from=333.337.search-card.all.click">天线宝宝央配旧版开头/压箱底自收藏</a>，点击<code>分享按钮</code>，然后选择<code>嵌入代码</code>，代码会复制到你的剪贴板中：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=938030801&amp;bvid=BV1hT4y1Y7RF&amp;cid=573164441&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但是这个页面的展示不是很完美，可以把上面的代码中添加一些东西：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=938030801&amp;bvid=BV1hT4y1Y7RF&amp;cid=573164441&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&amp;autoplay=0"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">sandbox</span>=<span class="string">"allow-top-navigation allow-same-origin allow-forms allow-scripts"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><iframe src="//player.bilibili.com/player.html?aid=938030801&amp;bvid=BV1hT4y1Y7RF&amp;cid=573164441&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe><p>主要调整的是宽度和高度、再就是不进行自动播放。</p><p><strong>百度地图</strong></p><p>在<a href="https://map.baidu.com/">百度地图</a>里面找到你需要找的地方，点击百度给与的地点之后，点击<code>分享</code>，然后把网址复制<code>https://j.map.baidu.com/58/rnJ</code>下来，填到下面的<code>src</code>后面：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://j.map.baidu.com/58/rnJ"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"600px"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">scrolling</span>=<span class="string">"No"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><iframe src="https://j.map.baidu.com/58/rnJ" width="100%" height="600" frameborder="0" scrolling="No"></iframe><p>上面的<code>width</code>和<code>height</code>可以根据你自己的需要更改。</p><p><strong>高级设置</strong></p><p>你如果对于<code>html</code>和<code>css</code>语法比较了解的，可以自己去修改主题的内部的东西得到你自己想要的效果。</p><h3 id="其他主题">其他主题</h3><p>除了上面主题之外，你也可以去<a href="https://hexo.io/themes/">hexo主题列表 - themes</a>看更多的主题，注意最好是选择标记有<code>#中文</code>的主题，比如<code>Next</code>、<code>ButterFly</code>主题。但是我觉得<code>Next</code>主题过于简洁，而且很容易和其他人的博客“撞衫”，色调太单调了；<code>ButterFly</code>主题也还不错可以试一试。</p><p>你可以按照上面的更换主题的方式进行更换，只需要注意安装主题的依赖包，然后再对主题的配置进行细节的配置。</p><h3 id="永久链接">永久链接</h3><p>最新写了几篇文章之后意识到一个很大的问题，文章的网页URL链接非常长，如果我把之前写的文章标题更改之后，其他引用这篇的文章的引用会失效，给别人分享的链接也会因此失效，搜了一下发现一个库可以解决这个问题，叫做<code>hexo-abbrlink</code>，具体做法如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后安装库都进入这个文件夹</span></span><br><span class="line"><span class="built_in">cd</span> D:/博客/blog</span><br><span class="line"></span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后，用记事本打开这个文件夹下的<code>_config.yml</code>文件，将原本的这一行注释更换为这一行：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置</span></span><br></pre></td></tr></tbody></table></figure><p>在下面额外粘贴这些内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment"># support crc16(default) and crc32 进制</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment"># support dec(default) and hex  算法</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment"># (true)Process draft,(false)Do not process draft. false(default) </span></span><br><span class="line">  <span class="comment"># Generate categories from directory-tree</span></span><br><span class="line">  <span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#true(default)</span></span><br><span class="line">     <span class="attr">depth:</span>        <span class="comment">#3(default)</span></span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#enable auto title, it can auto fill the title by path</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#enable auto date, it can auto fill the date by time today</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span></span><br></pre></td></tr></tbody></table></figure><p>保存文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理一下之前生成的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 再次生成一下</span></span><br><span class="line">hexo g</span><br></pre></td></tr></tbody></table></figure><p>它将原本这样的链接：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://eternal-bug.github.io/2023/06/18/%E4%BD%BF%E7%94%A8github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</span><br></pre></td></tr></tbody></table></figure><p>转换为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://eternal-bug.github.io/posts/196e9b33.html</span><br></pre></td></tr></tbody></table></figure><p>实际上网页后面的代码来自于markdown中，你会发现markdown文件头部多了一点东西，每一篇文章都不同：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span> <span class="string">196e9b33</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：这样处理之后新的问题又出现了，更新之后的文章中的图片失效了，原因是<code>hexo-abbrlink</code>和之前安装的<code>hexo-asset-image</code>库冲突了，之前图片的路径是以文字标题作为路径索引，这里更改文章路径之后图片就找不到了。查询了一圈，最好的解决办法是，去<a href="https://github.com/foreveryang321/hexo-asset-image/blob/master/index.js">foreveryang321/hexo-asset-image/index.js</a>把里面的代码全部复制，替换掉<code>node_modules/hexo-asset-image/index.js</code>里面的内容，然后再次<code>hexo clean</code>、<code>hexo g</code>就可以了。</p><h3 id="访问统计">访问统计</h3><p>可以使用百度和谷歌的统计。这里使用<code>ButterFly</code>主题了，默认自带了流量和访问计数统计。强烈推荐这个主题😄！</p><hr><p>下面会详细写一下<code>ButterFly</code>主题的调教。</p><h2 id="参考">参考</h2><ul><li><a href="https://hexo.io/zh-cn/docs/index.html">Hexo文档</a></li></ul><p>搭建流程</p><ul><li><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a></li><li><a href="http://tanglab.pku.edu.cn/2022/11/24/R&amp;D/2022/GitHub_pages_tutorial/">Tutorial:基于Hexo框架的GitHub个人主页搭建教程（前篇）</a></li><li><a href="http://tanglab.pku.edu.cn/2022/11/24/R&amp;D/2022/GitHub_pages_tutorial_sequel/">Tutorial:基于Hexo框架的GitHub个人主页搭建教程（后篇）</a></li><li><a href="https://blog.csdn.net/qq_44732432/article/details/124714408">使用Hexo搭建博客并部署到Github</a></li></ul><p>主题</p><ul><li><a href="https://www.zhihu.com/question/24422335/answer/1632402674">有哪些好看的 Hexo 主题？</a></li><li><a href="https://www.zhihu.com/question/24422335/answer/115800792">有哪些好看的 Hexo 主题？</a></li></ul><p>图片</p><ul><li><a href="https://zhuanlan.zhihu.com/p/645679541">解决Hexo+Github+Typora图片无法正确显示的问题</a></li><li><a href="https://blog.csdn.net/qq_35947021/article/details/126949854">Hexo图片不显示问题</a></li></ul><p>永久链接</p><ul><li><a href="https://www.imbhj.com/posts/b6a99401/">Hexo 博客生成永久链接</a></li></ul><p>iframe</p><ul><li><a href="https://blog.zezeshe.com/archives/use-bilibili-iframe-player.html">使用更干净的哔哩哔哩iframe播放器</a></li><li><a href="https://blog.csdn.net/xinshou_caizhu/article/details/94028606">接入B站iframe视频(bilibili引用视频)</a></li></ul><script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
