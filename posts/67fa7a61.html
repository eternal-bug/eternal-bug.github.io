<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Perl 命令行实战2 - fastq文件的相关操作 | eternal-bug的博客</title><meta name="author" content="eternal-bug"><meta name="copyright" content="eternal-bug"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="fastq文件的介绍 详细介绍：fastq格式 fastq是一种除了fasta文件之外，做生信另外一个最为常见的文件类型。 fastq文件主要是用来存储测序的序列信息的。它以4行为一个单位，是严格按照行限定的格式，不像之前的fasta文件那样比较灵活的形式。 虽然网上有很多关于fastq文件的介绍，这里我还是想啰嗦几句，因为这样到后面写perl程序的时候可以前后对应着看会稍微方便一点 示例 123">
<meta property="og:type" content="article">
<meta property="og:title" content="Perl 命令行实战2 - fastq文件的相关操作">
<meta property="og:url" content="https://eternal-bug.github.io/posts/67fa7a61.html">
<meta property="og:site_name" content="eternal-bug的博客">
<meta property="og:description" content="fastq文件的介绍 详细介绍：fastq格式 fastq是一种除了fasta文件之外，做生信另外一个最为常见的文件类型。 fastq文件主要是用来存储测序的序列信息的。它以4行为一个单位，是严格按照行限定的格式，不像之前的fasta文件那样比较灵活的形式。 虽然网上有很多关于fastq文件的介绍，这里我还是想啰嗦几句，因为这样到后面写perl程序的时候可以前后对应着看会稍微方便一点 示例 123">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eternal-bug.github.io/img/avatar.png">
<meta property="article:published_time" content="2024-06-12T15:06:57.000Z">
<meta property="article:modified_time" content="2024-06-29T14:06:18.924Z">
<meta property="article:author" content="eternal-bug">
<meta property="article:tag" content="Perl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eternal-bug.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/bug1.png"><link rel="canonical" href="https://eternal-bug.github.io/posts/67fa7a61.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Perl 命令行实战2 - fastq文件的相关操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-29 22:06:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="eternal-bug的博客" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-timeline"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Perl/"><i class="fa-fw fas fa-code"></i><span> Perl</span></a></li><li><a class="site-page child" href="/categories/Python/"><i class="fa-fw fas fa-code"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/R/"><i class="fa-fw fas fa-code"></i><span> R</span></a></li><li><a class="site-page child" href="/categories/%E5%8D%9A%E5%AE%A2/"><i class="fa-fw fas fa-blog"></i><span> 博客</span></a></li><li><a class="site-page child" href="/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><i class="fa-fw fas fa-microchip"></i><span> 大模型</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%BE%E8%AE%A1/"><i class="fa-fw fas fa-pen-ruler"></i><span> 设计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/statistics/"><i class="fa-fw fas fa-chart-simple"></i><span> 统计</span></a></li><li><a class="site-page child" href="/bioinformatics/"><i class="fa-fw fas fa-dna"></i><span> 生信</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-sliders"></i><span> 多媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/starbound.half.png')"><nav id="nav"><span id="blog-info"><a href="/" title="eternal-bug的博客"><span class="site-name">eternal-bug的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-timeline"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Perl/"><i class="fa-fw fas fa-code"></i><span> Perl</span></a></li><li><a class="site-page child" href="/categories/Python/"><i class="fa-fw fas fa-code"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/R/"><i class="fa-fw fas fa-code"></i><span> R</span></a></li><li><a class="site-page child" href="/categories/%E5%8D%9A%E5%AE%A2/"><i class="fa-fw fas fa-blog"></i><span> 博客</span></a></li><li><a class="site-page child" href="/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><i class="fa-fw fas fa-microchip"></i><span> 大模型</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%BE%E8%AE%A1/"><i class="fa-fw fas fa-pen-ruler"></i><span> 设计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/statistics/"><i class="fa-fw fas fa-chart-simple"></i><span> 统计</span></a></li><li><a class="site-page child" href="/bioinformatics/"><i class="fa-fw fas fa-dna"></i><span> 生信</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-sliders"></i><span> 多媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Perl 命令行实战2 - fastq文件的相关操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-12T15:06:57.000Z" title="发表于 2024-06-12 23:06:57">2024-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-29T14:06:18.924Z" title="更新于 2024-06-29 22:06:18">2024-06-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Perl/">Perl</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Perl 命令行实战2 - fastq文件的相关操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="fastq文件的介绍">fastq文件的介绍</h2>
<p>详细介绍：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFASTQ_format">fastq格式</a></p>
<p>fastq是一种除了fasta文件之外，做生信另外一个最为常见的文件类型。</p>
<p>fastq文件主要是用来存储测序的序列信息的。它以4行为一个单位，是严格按照行限定的格式，不像之前的fasta文件那样比较灵活的形式。<br>
虽然网上有很多关于fastq文件的介绍，这里我还是想啰嗦几句，因为这样到后面写perl程序的时候可以前后对应着看会稍微方便一点</p>
<h3 id="示例">示例</h3>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATCA</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9???FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br><span class="line">@SRR2177462.2 FCC600JACXX:2:1101:1661:2085/1</span><br><span class="line">NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">+</span><br><span class="line">#4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们从头开始，每4行为一组，在每一组之内的：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>第一行</strong>：以<code>@</code>字符开头，表示这条序列的测序信息，来自于哪台测序仪、第几个run、第几个lane、第几个tail、以及在这个tail的X轴与Y轴的位置。</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATCA</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>第二行</strong>：测序得到的序列。也可以说是read</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>第三行</strong>：以<code>+</code>字符开头，后面跟着ID序列标识符，如果<code>+</code>后面有东西那么必须与第一行一致，一般都是没有的，为了节省内存。</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9???FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>第四行</strong>：是第二行序列每个碱基的质量编码值，包含与第二行字符数量相同的符号。经过转换之后可以得到这个碱基的质量数值，以及这个碱基的错误率。</li>
</ul>
<h2 id="前期准备">前期准备</h2>
<p>因为一般的fastq文件都是经过压缩的，如果你想拿fastq的实际文件来做这次的测试，那样可能比较耗时间，特别是在<code>gzip</code>或者<code>pigz</code>的解压时间上面。所以这里如果你想快速进行实战演练的话，我建议先把本文末尾的<code>测试数据</code>这一步做了，得到<code>123.fastq.gz</code>进行测试会快一些。</p>
<h2 id="注意">注意!!</h2>
<blockquote>
<p>由于我演示是使用的windows系统，在文件的一行结束的位置除了一个<code>\n</code>换行符之外，还有<code>\r</code>回车符这样的字符存在，而使用perl中的<code>chomp</code>方法不能除去<code>\r</code>回车符，所以下面代码中，在Mac或者Linux中可以直接写为<code>chomp</code>我换成了<code>s/\r?\n//</code>。在后面生成<code>123.fastq.gz</code>文件的时候粘贴复制到文本里面去的时候也可能带上回车符<code>\r</code>，这里使用<code>windows</code>进行测试要注意了。</p>
</blockquote>
<h2 id="获取fastq文件的信息">获取fastq文件的信息</h2>
<h3 id="1-序列条数">1. 序列条数</h3>
<p><strong>思路</strong> ： 利用fastq的四个为一个单位的特征</p>
<ul>
<li><strong>方法1</strong><br>
比较丑陋</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  # 因为四个为一组，没必要将所有的行都加起来再除以4</span></span><br><span class="line"><span class="string">  # 消耗掉其他三行</span></span><br><span class="line"><span class="string">  &lt;&gt;;&lt;&gt;;&lt;&gt;;</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法1.0<br>
也可以这么写</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if($. % 4 == 1){</span></span><br><span class="line"><span class="string">    $n++;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>或者使用<code>pigz</code>，<code>pigz</code>要比<code>gzip</code>解压快一些，但是<code>git for windows</code>上没有这个东西，另外使用<code>zcat</code>进行查看文件我发现比直接解压文件要快，所以后面测试还是使用<code>zcat</code>。不过也展示一下<code>pigz</code>的使用方式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d : 解压模式</span></span><br><span class="line"><span class="comment"># -c : 将解压的得到的数据输出到标准输出中</span></span><br><span class="line">pigz -d -c 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  &lt;&gt;;&lt;&gt;;&lt;&gt;;</span></span><br><span class="line"><span class="string">  END{print $n}</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>方法2</strong><br>
使用linux命令</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc -l 计算行数</span></span><br><span class="line">line=`zcat 123.fastq.gz | <span class="built_in">wc</span> -l`</span><br><span class="line"><span class="built_in">let</span> seq_num=<span class="variable">$line</span>/4</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$seq_num</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-质量值的类型">2. 质量值的类型</h3>
<h4 id="有关质量值的编码方式">有关质量值的编码方式</h4>
<p>现在一般都是采用的<code>Phred+33</code>类型的，那为什么还要说这一小节呢？</p>
<p>通过介绍这些质量值类型可以帮助理解fastq中质量值与序列的关联性以及在这种利用文本传达信息的过程中，人们所展现出来的智慧！</p>
<h5 id="测序的错误来源">测序的错误来源</h5>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+==============+       +==============+</span><br><span class="line">| .   .   .   .|       | *   *   *   *|</span><br><span class="line">|   .   .   .  |  ==&gt;  |   *   *   *  |</span><br><span class="line">| .   .   .   .|       | *   *   *   *|</span><br><span class="line">|   .   .   .  |       |   *   *   *  |</span><br><span class="line">+==============+       +==============+</span><br><span class="line"></span><br><span class="line"> 测序芯片中测序点          激发之后产生荧光</span><br></pre></td></tr></tbody></table></figure>
<p>在测序的时候，是通过对应位置发出来的对应颜色的荧光的强度来得到这个位置测定出。</p>
<p><img src="/posts/67fa7a61/chromatogram.jpg" alt="chromatogram样图"></p>
<p>那测序的错误是从何而来呢？</p>
<blockquote>
<p>在荧光染料测序中，每次发生碱基合成时会释放出荧光信号，该信号被CCD图像传感器捕获。记录下荧光信号的峰值，生成一个实时的轨迹数据（chromatogram）（如上图所示）。因为不同的碱基用不用的颜色标记，检测这些峰值即可判断出对应的碱基。但由于这些信号的波峰、密度、形状和位置等是不连续或模糊的，有时很难根据波峰判断出正确的碱基。通过对每一个点对不同颜色的曲线参与的程度进行计算，计算许多与波峰大小和分辨率相关的参数，根据这些参数，从一个巨大的查询表中找出碱基质量得分。这个查询表是根据对已知序列的测序数据分析得到的（应该是分析得到波峰参数与碱基错误率的关系，再通过公式把错误率转换成质量得分，得到波峰参数与质量得分的直接对应表）。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>波长1</th>
<th>波长2</th>
<th>波长3</th>
<th>波长4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.65</td>
<td>0.14</td>
<td>0.01</td>
<td>0.02</td>
</tr>
<tr>
<td>B</td>
<td>0.81</td>
<td>1.03</td>
<td>0.02</td>
<td>0.03</td>
</tr>
<tr>
<td>C</td>
<td>0.02</td>
<td>0.02</td>
<td>0.95</td>
<td>0.04</td>
</tr>
<tr>
<td>D</td>
<td>0.03</td>
<td>0.03</td>
<td>1.10</td>
<td>1.56</td>
</tr>
</tbody>
</table>
<p>表2.2.0.1 例如一个测序位点不同碱基所带的荧光基团在这个点发出的荧光的贡献</p>
<p>那么也就是说，一个点ATGC四个碱基上经过激发之后得到不同的波长，如果这个位点不同颜色占据的量越多，那么出错的可能性就越大，如果某种颜色占据的越多那么越有可能是这个碱基。那么如何描述这种碱基的纯粹程度呢？</p>
<h5 id="错误的评判标准">错误的评判标准</h5>
<p><code>Quality Score</code> —— 评判一个碱基判读可靠性指标</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo>−</mo><mn>10</mn><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q = -10log(P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>是质量值</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>是错误率</li>
</ul>
<table>
<thead>
<tr>
<th>准确度</th>
<th>P值(错误率)</th>
<th>Q值（质量值）</th>
</tr>
</thead>
<tbody>
<tr>
<td>90%</td>
<td>10%</td>
<td>10</td>
</tr>
<tr>
<td>99%</td>
<td>1%</td>
<td>20</td>
</tr>
<tr>
<td>99.9%</td>
<td>0.1%</td>
<td>30</td>
</tr>
<tr>
<td>99.99%</td>
<td>0.01%</td>
<td>40</td>
</tr>
<tr>
<td>99.999%</td>
<td>0.001%</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>平常常常说<code>Q30</code>，就是说碱基准确度达到99.9%的程度，就是说出错的可能性为0.1%。这里别人推荐了一种记忆方法，10是一个9，20两个9，40是4个9。</p>
<p>这里有关的测序步骤以及质量值可以参看陈老师的视频</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav23077195%3Ffrom%3Dsearch%26seid%3D15283415322892062157">陈巍学基因</a></p>
<p>有关P值更加详细的计算说明见这篇文章<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F22595128">P值与基因组学（1）：从fastq文件的分析的分析谈起</a></p>
<p>那么就需要对每次每个测得的碱基的质量进行记录，怎么来记录呢？可是质量值从个位数到十位数会发生什么呢？</p>
<h5 id="质量值的记录方式">质量值的记录方式</h5>
<p>使用数值的序列与质量值得对应关系</p>
<p>本来对应关系是这样的</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N 2</span><br><span class="line">A 19</span><br><span class="line">A 28</span><br><span class="line">T 35</span><br><span class="line">G 35</span><br><span class="line">A 37</span><br><span class="line">A 37</span><br><span class="line">A 37</span><br><span class="line">T 39</span><br><span class="line">T 39</span><br><span class="line">A 37</span><br><span class="line">A 39</span><br><span class="line">A 37</span><br><span class="line">G 40</span><br><span class="line">A 38</span><br><span class="line">. .</span><br><span class="line">. .</span><br><span class="line">. .</span><br></pre></td></tr></tbody></table></figure>
<p>写到一行上（其实没有这种数值类型的表示方式）</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 </span><br><span class="line">21928353537373739393739374038403940404041363839403840323940413740363939394040404040364039404040413437403941403940403239403737384040413937394040414041373137363938403539393230333134</span><br></pre></td></tr></tbody></table></figure>
<p>就单单只看两个碱基，碱基与质量值之间的对应关系有多种</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">N =&gt; 2</span><br><span class="line">A =&gt; 1</span><br><span class="line">或者</span><br><span class="line">N =&gt; 21</span><br><span class="line">A =&gt; 9</span><br><span class="line">或者</span><br><span class="line">N =&gt; 2</span><br><span class="line">A =&gt; 19</span><br><span class="line">或者</span><br><span class="line">N =&gt; 21</span><br><span class="line">A =&gt; 92</span><br></pre></td></tr></tbody></table></figure>
<p>如果这么写的话，第一个碱基质量值为个位数，其他的为十位数，这样记录之后，后续程序怎么来分析它呢？一个碱基对应的质量值到底是个位数还是十位数呢？这个样子质量值与碱基之间怎么对应啊？这是个问题…</p>
<p>那如果用空格将数值间隔开呢？</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 2 19 28 35 35 37 37 37 39 39 37 39 37 40 38 40 39 40 40 40 41 36 38 39 40 38 40 32 39 40 41 37 40 36 39 39 39 40 40 40 40 40 36 40 39 40 40 40 41 34 37 40 39 41 40 39 40 40 32 39 40 37 37 38 40 40 41 39 37 39 40 40 41 40 41 37 31 37 36 39 38 40 35 39 39 32 30 33 31 34</span><br></pre></td></tr></tbody></table></figure>
<p>有没有感觉到瞬间多了好多字符一样的，这样带来的后果就是占用的内存急剧增加。</p>
<p>于是乎人们就想到了一个好办法</p>
<p><img src="/posts/67fa7a61/ASCII%E7%A0%81%E8%A1%A8.jpg" alt="ASCII码表"></p>
<p>使用ASCII码的序列与质量值得对应关系</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列 NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">质量 #4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到一个碱基对应一个表示质量值的字符，这样既减少了文件所占据的内存，也让碱基质量值与碱基的对应关系更加清晰。</p>
<p>那么将使用ASCII码进行记录的质量值与直接使用数字进行记录的质量进行比较，使用数字表示法：</p>
<ul>
<li><strong>文件占据内存增加</strong>：在fastq文件中，占内存的大头是序列以及质量值的文字，如果质量值用两个数字表示那内存占据会增加很多</li>
<li><strong>碱基与质量值对应的关系</strong>：如果是以数字的形式对应碱基的话，如果一直是1个碱基对应2个数字那都好说，可是保不齐某些碱基测序质量极差，质量值为个位数，那么既有1对2、也有1对1，怎么才能确定碱基与质量值之间的对应关系呢？</li>
</ul>
<p>既然采用ASCII码来记录碱基质量，那么为什么还要分什么<strong>Phred+33</strong>、<strong>Phred+64</strong>之类的？</p>
<h5 id="质量值的编码方式">质量值的编码方式</h5>
<p>现有的常见的测序质量值编码方式</p>
<ul>
<li><strong>Phred+33</strong></li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJ</span><br><span class="line">                  |         |         |         |         ||</span><br><span class="line">   Quality score: 0........10........20........30........4041</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Phred+64</strong></li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |         |         |         |         |</span><br><span class="line">   Quality score: 0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Solexa+64</strong></li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: ;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |    |         |         |         |         |</span><br><span class="line">   Quality score:-5....0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure>
<p>话说<strong>Phred</strong>和<strong>solexa</strong>是什么意思呢？百度<strong>Phred</strong>之后发现有一个很古老的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.phrap.com%2Fphred%2F">网站</a>，网页比较简洁，里面写着</p>
<blockquote>
<p>Phred is a base-calling program for DNA sequence traces. Phred reads DNA sequence chromatogram files and analyzes the peaks to call bases, assigning quality scores (“Phred scores”) to each base call.</p>
</blockquote>
<p>就是说<strong>Phred</strong>这个原来是一个工具，用来对测序得到的<code>chromatogram</code>文件分析（可以见上面的有四条曲线的图）。这个软件通过对四种不同的荧光的强度来分析得到该碱基位点的质量值。</p>
<p>当时是1998年发现核酸研究上的一篇文章《 Base-calling of automated sequencer traces using phred. I. Accuracy assessment》然后同年又发了文章《Base-calling of automated sequencer traces using phred. II. Error probabilities》。</p>
<blockquote>
<p>最初开发时，Phred在所检查的数据集中产生的错误明显少于其他方法，平均减少40-50％的错误。Phred质量评分已被广泛接受用于表征DNA序列的质量，并且可用于比较不同测序方法的功效 。Phred在人类基因组计划中发挥了重要作用，自动脚本处理大量序列数据。它当时是学术和商业DNA测序实验室最广泛使用的碱基调用软件程序，因为它具有很高的碱基调用准确性。 ——wikipedia</p>
</blockquote>
<p>而<strong>solexa</strong>是一种基于边合成边测序的技术。通过单分子阵列实现小型阵列上的桥式PCR反应。新的阻断技术能够每次只合成一个碱基，经过激光激发之后得到激发光，对激发光进行分析得到碱基信息。</p>
<blockquote>
<p>早些年，人们在谈到新一代测序仪时，经常会提起Solexa，而不是Illumina。这是一家低调的公司，规模也不大，但是测序技术却非常新颖。它开发出的测序仪，在通量上领先于其他竞争产品。收购Solexa，也成为Illumina的转折点，从此踏上高速发展的道路。 ——生物通</p>
</blockquote>
<p><img src="/posts/67fa7a61/%E4%B8%8D%E5%90%8C%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B.jpg" alt="不同编码类型.jpg"></p>
<p>现在大部分都是用的Illumina 1.8+的<code>Phred+33</code>方式，也就是将质量值加上<code>33</code>，得到一个数值，再将这个数值按照上面的<code>ASCII</code>码表对应到特定的字符上去。</p>
<p>比如</p>
<table>
<thead>
<tr>
<th>Q值（质量值）</th>
<th>+33之后的值</th>
<th>对应的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>33</td>
<td>!</td>
</tr>
<tr>
<td>1</td>
<td>34</td>
<td>"</td>
</tr>
<tr>
<td>10</td>
<td>43</td>
<td>+</td>
</tr>
<tr>
<td>20</td>
<td>53</td>
<td>5</td>
</tr>
<tr>
<td>30</td>
<td>63</td>
<td>?</td>
</tr>
<tr>
<td>40</td>
<td>73</td>
<td>I</td>
</tr>
<tr>
<td>41</td>
<td>74</td>
<td>J</td>
</tr>
</tbody>
</table>
<p>为什么偏要<code>+33</code>，而不是<code>+11</code>啊！<code>+22</code>啊之类的？</p>
<p>你可以看看上面的<code>ASCII</code>码表，因为在<code>0~32</code>这个范围之内有很多奇形怪状的字符，同时还包含什么制表符、换行符、回车符、空格、响铃、退格等这类的看不见的字符。而很多时候质量值需要一是肉眼能方便查看；二是要方便程序读取。显然在<code>0-32</code>这个范围内不适合取。而从<code>33</code>开始直到<code>127</code>均为可见的字符。那从33开始取值不就的了，怎么又来个什么+64之类的？</p>
<p>谷歌了一下，暂时没有找到究竟+64的原因，但是在一篇博客《质量值体系 Phred33 和 Phred 64 的由来 及其在质量控制中的实际影响 - Part 1》中作者自己脑补的两者之间的关联。我觉得下面这句话可能可以说明一下作者脑补的内容：</p>
<blockquote>
<p>一流的企业做标准，二流的企业做品牌，三流的企业做产品</p>
</blockquote>
<p>就是当时测序公司有多家，互相之间相互竞争，各家公司是竞争对手，怎么可能你用什么我也用什么。所以我也要想出一定的标准，哈哈！后来的Solexa就不采用+33的方式（这个方式就是<code>Phred+33</code>的编码方式当时Sanger公司所采用的），而使用<strong>Solexa+64</strong>，其实+64也不是就是随便来的，可以再看一下上面的ASCII码对照表。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quality encoding: @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">                  |         |         |         |         |</span><br><span class="line">   Quality score: 0........10........20........30........40</span><br></pre></td></tr></tbody></table></figure>
<p><em>在质量值<code>0</code>对应的<code>@</code>之后，就是从英文大写字母<code>A</code>开始了，也就是质量值<code>1-26</code>对应编码字符<code>A-Z</code>了。这样人肉眼看的话其实质量值是相当直观了。不过在质量值到达<code>33</code>之后，又出现了小写字母…这个个人感觉就不如Phred+33那样的呢。</em></p>
<p>到后来2006年Solexa公司被Illumina公式收购，于是又有了Illumina 1.3+ Phred+64（这里是我自己脑补的- . -）。于是就有了Sanger公司的Phred+33的方式以及Illumina的Phred+64的方式。于是两家公司互相不让着谁。这可苦了当时编写生信数据分析的人，后来没办法只有在程序中加上自动判断的程序。</p>
<p>可是墨菲他老人家不高兴了（这里我不太了解墨菲和这个事件之间的联系），所以在 2011 年, Illumina 公司表示他们又要改成 Phred33 体系了 (<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fseqanswers.com%2Fforums%2Fshowthread.php%3Ft%3D8895%26page%3D4">Upcoming changes in CASAVA</a>)。这样来来回回还是回到了Phred+33的体系。</p>
<p>期间有意思的是，当时三巨头的另一家测序仪公司 454 Life Sciences (后被 Roche 收购) 就更绝, 人家从碱基开始就不用 ACTG 表示, 直接整了个 ColorSpace 体系出来, 根本不和你们玩，当然后来大家也不跟 454 玩了, 最后他也就没得玩了 。</p>
<p>这个是在网上别人得到的 ColorSpace数据：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SRR2967009.1 100_1000_1168_F3</span><br><span class="line">T10011023211201220121202030102221012302121010131001</span><br><span class="line">+</span><br><span class="line">2@@@@&gt;@?@@@@&lt;@@//;@@/@9?@8@=@@@6;6@66;&lt;@6@67?2?;/@</span><br><span class="line">@SRR2967009.2 100_1000_1211_F3</span><br><span class="line">T20132312201120021312220200023110220113100012321011</span><br><span class="line">+</span><br><span class="line">@@@@@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@?@@@@/?@@@@@@@@&lt;?@</span><br></pre></td></tr></tbody></table></figure>
<p>序列是用<code>double-encoded data</code>或者称<code>colorspace</code>的模式表示的。</p>
<p>按照手册的说明：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA, CC, GG, TT : 0</span><br><span class="line">AC, CA, GT, TG : 1</span><br><span class="line">AG, CT, GA, TC : 2</span><br><span class="line">AT, CG, GC, TA : 3</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Therefore five base long sequence <code>AACTA</code> will be represented as <code>0123</code>. The encoding is <code>AA=0</code>, <code>AC=1</code>, <code>CT=2</code>, and <code>TA=3</code>.</p>
</blockquote>
<p>额，感觉有些诡异。不过这样做应该有他的考虑，只是现在我不清楚。</p>
<h5 id="质量值的区别方法">质量值的区别方法</h5>
<ol>
<li><strong>肉眼查看</strong><br>
通过Phred+33与Phred+64的区别，可以知道，<code>[0~9]</code>的为Phred33特有的质量字符，小写字母<code>[a~z]</code>的为Phred64特有的质量字符。</li>
<li><strong>程序判断</strong></li>
</ol>
<p>这个shell代码不知道出处是哪里，反正放在这里吧，如果有侵权，那我就删除了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fqtype</span></span> () {</span><br><span class="line">        less <span class="variable">$1</span> | <span class="built_in">head</span> -n 999 | awk <span class="string">'{if(NR%4==0) printf("%s",$0);}'</span> \</span><br><span class="line">        | <span class="built_in">od</span> -A n -t u1 -v \</span><br><span class="line">        | awk <span class="string">'BEGIN{min=100;max=0;}\</span></span><br><span class="line"><span class="string">        {for(i=1;i&lt;=NF;i++) {if($i&gt;max) max=$i; if($i&lt;min) min=$i;}}END\</span></span><br><span class="line"><span class="string">        {if(max&lt;=74 &amp;&amp; min&lt;59) print "Phred+33"; \</span></span><br><span class="line"><span class="string">        else if(max&gt;73 &amp;&amp; min&gt;=64) print "Phred+64"; \</span></span><br><span class="line"><span class="string">        else if(min&gt;=59 &amp;&amp; min&lt;64 &amp;&amp; max&gt;73) print "Solexa+64"; \</span></span><br><span class="line"><span class="string">        else print "Unknown score encoding"; \</span></span><br><span class="line"><span class="string">        print "( " min ", " max, ")";}'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>仿照上面的shell代码，我改成了Perl One-liners的版本。一般只需要取一部分序列进行计算就可以了，计算这个值还是挺快的。使用真实的fastq数据同样也很快，只需要接近0.05秒的时间。（😒你可能会说你看上面的<code>bash</code>脚本就这么几行就完事了，怎么用perl要写这么多！你之前应该也听说过perl有一句名言<code>事实的真相不止一个！</code>，如果把perl写成很<strong>单行</strong>的形式，估计不好看懂，这里是为了展示代码的转换时是个什么原理，而且代码如果是自己用，<strong>不要装逼到吓到自己</strong>！）</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里实际上只取20行不够，真正的最好取上千条比较好(4000行)</span></span><br><span class="line"><span class="comment"># 因为有的时候测序质量很高，采样太少根本无法得到真正的上下限的值</span></span><br><span class="line"><span class="comment"># 这里是因为123.fastq.gz文件本身只有80行，所以只取了80行</span></span><br><span class="line"><span class="comment"># 为了方便使用，这里可以提前赋值一个变量，以后改行数的时候会比较方便</span></span><br><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 首先初始化两个用来判断质量值上下限的两个变量</span></span><br><span class="line"><span class="string">    $max = 0;    # 将最大值设置得精良小</span></span><br><span class="line"><span class="string">    $min = 1000; # 将最小值设置得尽量大</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 质量行在4的倍数行</span></span><br><span class="line"><span class="string">  if($. % 4 == 0){</span></span><br><span class="line"><span class="string">    # 去除回车符换行符</span></span><br><span class="line"><span class="string">    s/\r?\n$//;</span></span><br><span class="line"><span class="string">    my $word;</span></span><br><span class="line"><span class="string">    # 每次“吞”一个字符进行ASCII码值转换</span></span><br><span class="line"><span class="string">    while($word = chop($_)){</span></span><br><span class="line"><span class="string">      my $ascll_num = ord($word);</span></span><br><span class="line"><span class="string">      # 不断扩大min与max的范围，得到更加真实的上下限值</span></span><br><span class="line"><span class="string">      if($ascll_num &gt; $max){$max = $ascll_num;}</span></span><br><span class="line"><span class="string">      if($ascll_num &lt; $min){$min = $ascll_num;}</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 如果质量最大值低于75，最小值小于59，那么认为就是Phred+33类型</span></span><br><span class="line"><span class="string">    if($max &lt; 75 and $min &lt; 59){</span></span><br><span class="line"><span class="string">      print "Phred+33!\n";</span></span><br><span class="line"><span class="string">    }elsif($max &gt; 73 and $min &gt; 63){</span></span><br><span class="line"><span class="string">    # 如果质量最大值高于73，最小值高于63，那么认为就是Phred+64类型</span></span><br><span class="line"><span class="string">      print "Phred+64!\n";</span></span><br><span class="line"><span class="string">    }elsif($min &gt; 53 and $min &lt; 64 and $max &gt; 73){</span></span><br><span class="line"><span class="string">    # 如果最小值在58和64之间，最大值大于73，那就是Solexa+64类型</span></span><br><span class="line"><span class="string">      print "Solexa+64!\n";</span></span><br><span class="line"><span class="string">    }else{</span></span><br><span class="line"><span class="string">    # 否则不知道类型</span></span><br><span class="line"><span class="string">      print "unkown!\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 打印出上下限信息</span></span><br><span class="line"><span class="string">    print "Max:$max\n";</span></span><br><span class="line"><span class="string">    print "Min:$min\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Phred+33!</span><br><span class="line">Max:74</span><br><span class="line">Min:35</span><br></pre></td></tr></tbody></table></figure>
<p>但是这里你觉得这样的步骤可不可以分解呢？</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [说明]：</span></span><br><span class="line"><span class="comment"># 这里不是炫技之类的，就是多使用其他linux工具进行搭配</span></span><br><span class="line"><span class="comment"># 减少perl中的那些判断的代码，让单行程序更加“单行”一些</span></span><br><span class="line"><span class="comment"># 让功能更加专一，便于代码重用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zcat 负责解压</span></span><br><span class="line"><span class="comment"># head 负责提取前面几行</span></span><br><span class="line"><span class="comment"># awk  负责排除其他行</span></span><br><span class="line"><span class="comment"># perl 负责得到上下限的值</span></span><br><span class="line"><span class="comment"># perl 负责对这个值进行判断并且得到质量类型</span></span><br><span class="line"></span><br><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 首先初始化两个用来判断质量值上下限的两个变量</span></span><br><span class="line"><span class="string">    $max = 0;    # 将最大值设置得尽量小</span></span><br><span class="line"><span class="string">    $min = 1000; # 将最小值设置得尽量大</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 去除回车符换行符</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  # 每次“吞”一个字符进行ASCII码值转换</span></span><br><span class="line"><span class="string">  while($word = chop($_)){</span></span><br><span class="line"><span class="string">    my $ascll_num = ord($word);</span></span><br><span class="line"><span class="string">    # 将上下限的值赋值给刚才的两个变量</span></span><br><span class="line"><span class="string">    if($ascll_num &gt; $max){$max = $ascll_num;}</span></span><br><span class="line"><span class="string">    if($ascll_num &lt; $min){$min = $ascll_num;}</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    print "$max:$min\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> | perl -n -a -F: -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    sub print_type {</span></span><br><span class="line"><span class="string">      my ($max,$min)=@_;</span></span><br><span class="line"><span class="string">      if($max &lt; 75 and $min &lt; 59){</span></span><br><span class="line"><span class="string">        return "Phred+33!\n";</span></span><br><span class="line"><span class="string">      }elsif($max &gt; 73 and $min &gt; 63){</span></span><br><span class="line"><span class="string">        return "Phred+64!\n";</span></span><br><span class="line"><span class="string">      }elsif($min &gt; 53 and $min &lt; 64 and $max &gt; 73){</span></span><br><span class="line"><span class="string">        return "Solexa+64!\n";</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        return "unkown!\n";</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  my ($max,$min) = @F;</span></span><br><span class="line"><span class="string">  print "Max:$max\n";</span></span><br><span class="line"><span class="string">  print "Min:$min\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-fastqc相关统计量">3. fastqc相关统计量</h3>
<h4 id="序列长度的分布">序列长度的分布</h4>
<p>这个统计序列长度就比统计fasta序列的长度简单一些啦！</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先使用awk排除其他行</span></span><br><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $seq_len = length($_);</span></span><br><span class="line"><span class="string">  # 把序列长度以及为此长度的信息存入哈希中</span></span><br><span class="line"><span class="string">  $hash{$seq_len}++;</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "length\tcount\n";</span></span><br><span class="line"><span class="string">    for my $len (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$len\t$hash{$len}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出为</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length  count</span><br><span class="line">89      1</span><br><span class="line">90      18</span><br><span class="line">91      1</span><br></pre></td></tr></tbody></table></figure>
<p>也可以重定向到文件中，拿这个文件可以使用R来画图。</p>
<p>同样的你也可以写成：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if($. % 4 == 2){</span></span><br><span class="line"><span class="string">    s/\r?\n$//;</span></span><br><span class="line"><span class="string">    my $seq_len = length($_);</span></span><br><span class="line"><span class="string">    # 把序列长度以及为此长度的信息存入哈希中</span></span><br><span class="line"><span class="string">    $hash{$seq_len}++;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "length\tcount\n";</span></span><br><span class="line"><span class="string">    # 按照长度进行排序</span></span><br><span class="line"><span class="string">    for my $len (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$len\t$hash{$len}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>实际上上面的方法比下面的要慢一些，但是上面的程序将perl所承担的任务量减少了，所以代码量看起来少了一些。有的时候不能兼得，每项需要均衡一下。</p>
<hr>
<blockquote>
<p><strong>放松时间</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|_・) |ω・） |･ω･｀) (╯ε╰) ^.^ (๑￫ܫ￩) ←_← (╯ε╰) ^.^ (๑￫ܫ￩) ←_← (╯ε╰) ^.^ (๑￫ܫ￩) ←_← ﾍ(･_|</span><br></pre></td></tr></tbody></table></figure>
<p>最近听了一下<code>重阳世界观-狂点技能树(1)</code>，和大家分享一下，里面说到：</p>
<blockquote>
<p>在兵马俑坑，出土最多的青铜兵器是箭头，考古人员发现了4万多支箭头，是三棱型的。制作的非常规范，箭头底部宽度的误差为0.83毫米，而且金属配比基本上是相同的。</p>
<p><strong>为什么选择这种三棱形状的箭头呢？</strong></p>
<p>三棱箭头拥有三个锋利的棱角，在击中目标的瞬间，棱的锋刃处就会形成切割力，箭头就能够穿透铠甲，直达人体。同时这三个面是呈流线型的，据说这个流线型的轮廓和子弹的外形都一致。按照现在话来说，有一个好的空气动力学的特性。除了三棱型的箭矢，还有什么狼牙箭——带倒钩和翼面的。但翼面容易受风的影响，使箭头偏离目标。</p>
<p>武器有很多个维度，如果只追求单一的维度，那么这个武器不会太好，就说这样一个小小的箭头啊！制作工艺简单，标准化，那样才能大量生产；如果太复杂，成本太高，不能大量装备；另外如果只盲目追求杀伤力，打不准那也不行。</p>
</blockquote>
<p><img src="/posts/67fa7a61/%E4%B8%89%E6%A3%B1%E7%AE%AD%E5%A4%B4.jpg" alt="三棱箭头"></p>
<p>三棱箭头.jpg</p>
<p><img src="/posts/67fa7a61/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E7%AE%AD%E5%A4%B4.jpg" alt="各种各样的箭头"></p>
<p>各种各样的箭头.jpg</p>
</blockquote>
<hr>
<h4 id="每个位置上质量值的分布">每个位置上质量值的分布</h4>
<p>其实在fastQC软件之中就对这个做了一个很好的诠释，这里我用<code>Perl</code>代码+<code>R</code>代码尝试实现这种每个位置上的碱基质量分布：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 先声明一个质量值转换的子程序</span></span><br><span class="line"><span class="string">    sub convert_quality_to_score{</span></span><br><span class="line"><span class="string">      my $ascll = shift;</span></span><br><span class="line"><span class="string">      # 这里我默认使用Phred+33</span></span><br><span class="line"><span class="string">      return ord($ascll) - 33;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 只需要每个单位的第四行</span></span><br><span class="line"><span class="string">  if($. % 4 == 0){</span></span><br><span class="line"><span class="string">    s/\r?\n//;</span></span><br><span class="line"><span class="string">    my $n = 0;</span></span><br><span class="line"><span class="string">    while($_){</span></span><br><span class="line"><span class="string">      $n++;</span></span><br><span class="line"><span class="string">      my $quality_score = substr($_,0,1,"");</span></span><br><span class="line"><span class="string">      # 将碱基推到对应的位置的哈西中</span></span><br><span class="line"><span class="string">      push @{$hash{$n}},convert_quality_to_score($quality_score);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    my @list;</span></span><br><span class="line"><span class="string">    # 设置列表内插之后打印元素的分隔符</span></span><br><span class="line"><span class="string">    $" = ",";</span></span><br><span class="line"><span class="string">    for my $base_site (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      # 按照R语言的方式写入信息</span></span><br><span class="line"><span class="string">      print "c_${base_site} &lt;- c(@{$hash{$base_site}})\n";</span></span><br><span class="line"><span class="string">      push @list,"c_${base_site}";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 写入执行箱线图的boxplot</span></span><br><span class="line"><span class="string">    print "boxplot(@list)\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> &gt; statistic_base_quality.R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开命令行的R</span></span><br><span class="line"><span class="comment"># 这一步windows需要安装一下R，并且设置环境变量</span></span><br><span class="line">R</span><br><span class="line"><span class="comment"># 执行R脚本</span></span><br><span class="line"><span class="built_in">source</span>(<span class="string">"statistic_base_quality.R"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>就会得到如下的类似的箱线图，比较简陋啊，但是也算是有一种实现方式了，但是fastQC内部的实现机制是什么我现在还不知道。不过我感觉按照我这么写测序文件小可以用，大了估计不一定好使。</p>
<p><img src="/posts/67fa7a61/%E7%A2%B1%E5%9F%BA%E8%B4%A8%E9%87%8F%E7%9A%84%E7%AE%B1%E7%BA%BF%E5%9B%BE.jpg" alt="碱基质量的箱线图"></p>
<p>刚才在服务器上试了一下，发现这个运行的时间有点长…到时候运行估计会把R给卡死。算了！就当我这个例子没有举过v_v。</p>
<h4 id="n值的统计">N值的统计</h4>
<p>其实这个统计与之前的统计序列长度类似：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  s/\r?\n$//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $n = 0;</span></span><br><span class="line"><span class="string">  while($word = substr($_,0,1,"")){</span></span><br><span class="line"><span class="string">    $n++;</span></span><br><span class="line"><span class="string">    $hash{$n}++ if uc($word) eq "N";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  END{</span></span><br><span class="line"><span class="string">    # 打印出不同长度以及为此长度的序列的条数</span></span><br><span class="line"><span class="string">    print "site\tcount\n";</span></span><br><span class="line"><span class="string">    for my $site (sort {$a &lt;=&gt; $b} keys %hash){</span></span><br><span class="line"><span class="string">      print "$site\t$hash{$site}\n";</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个文件也可以重定向生成tsv文件，之后可以用R语言读取画图</p>
<h2 id="格式转换">格式转换</h2>
<h3 id="1-fastq转换为fasta">1. fastq转换为fasta</h3>
<p>网上一般使用的是<code>perl</code>的<code>Bio::Perl</code>模块来进行处理，其实这里不使用模块也可以进行转换。</p>
<h4 id="普通转换">普通转换</h4>
<p>将第一行作为titie，第二行作为序列组成fasta文件，如果想要将序列分割，那么请看我之前的文章<code>perl 命令行实战1 - fasta文件的相关操作</code>，只需要用一个管道操作符将不同perl的小的单行程序连起来就可以了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==1{print};NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $title =~ tr/@: /&gt;_-/;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="也可以把质量值保留下来">也可以把质量值保留下来</h4>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4!=3{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $title =~ tr/@: /&gt;_-/;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">  # 将质量值信息追加到文件中</span></span><br><span class="line"><span class="string">  open FILE,"&gt;&gt;","123.fasta.quality" or die $!;</span></span><br><span class="line"><span class="string">  print FILE "$title\n$quality\n";</span></span><br><span class="line"><span class="string">  close FILE;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>而这个fasta序列你可以用重定向的方式输出到文件中去或者进入管道继续处理</p>
<h4 id="特殊转换">特殊转换</h4>
<p>有的时候有些软件需要fasta的文件名比较特殊，比如<code>&gt;infile_0/1/0_1234</code>，这样的之类的，<br>
一般后面的1234是按照当前顺序第几条序列。这样其实也好办</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我就不保存质量值了。</span></span><br><span class="line"><span class="comment"># title可以直接不要</span></span><br><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  $n++;</span></span><br><span class="line"><span class="string">  # 变量内插一下就完事儿了</span></span><br><span class="line"><span class="string">  my $title = "&gt;infile_0/1/0_$n";</span></span><br><span class="line"><span class="string">  (my $sequence = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="质量编码标准的转换">质量编码标准的转换</h2>
<h3 id="0-首先要确定质量值编码方式">0. 首先要确定质量值编码方式</h3>
<p>如果不知道质量值的编码方式胡乱的转可能会出问题！或者要么写一个脚本先自动判断质量值类型，然后再转换。</p>
<p>可以先按照<code>2.2 质量值的类型</code>这一步进行测试，或者已知质量值，然后再进行转换。</p>
<p>现在手头上没有相应的文件，只能说在这里写一下代码吧</p>
<h3 id="1-phred-64转换为phred-33">1. Phred+64转换为Phred+33</h3>
<p><strong>思路</strong>：+64变成+33，怎么办呢？减去32？试一下</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    sub convert_64_to_33 {</span></span><br><span class="line"><span class="string">      my $word = shift;</span></span><br><span class="line"><span class="string">      return chr(ord($word) - 32);</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print $_;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $title2   = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $quality_new;</span></span><br><span class="line"><span class="string">  while($word = chop($quality)){</span></span><br><span class="line"><span class="string">    $quality_new = convert_64_to_33($word) . $quality_new;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print "$sequence\n";</span></span><br><span class="line"><span class="string">  print "$title2\n";</span></span><br><span class="line"><span class="string">  print "$quality_new\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>你也可以把<code>chr(ord($word) - 32);</code>这一句话改为<code>chr(ord($word) + 32);</code>，你觉得应该变成什么功能呢？</p>
<h3 id="2-solexa-64转换为phred-33">2. Solexa+64转换为Phred+33</h3>
<p><strong>思路</strong>：由于Solexa的质量值计算方式与Phred方式不同，所以需要对质量值计算标准做一个转换。这里参考了<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fclub.topsage.com%2Fthread-2229946-1-1.html">Perl中FastQ与FastA格式的相互转换</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 下面的算法参考自博文《Perl中FastQ与FastA格式的相互转换》，在这里还是说明一下</span></span><br><span class="line"><span class="string">    my @conv_table;</span></span><br><span class="line"><span class="string">    for (-64..64) {</span></span><br><span class="line"><span class="string">      $conv_table[$_+64] = chr(int(33 + 10*log(1+10**($_/10.0))/log(10)+0.499));</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub convert_Solexa64_to_Phred33{</span></span><br><span class="line"><span class="string">      my $word = shift;</span></span><br><span class="line"><span class="string">      return $conv_table[ord($word)];</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print $_;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $title2   = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  my $quality_new;</span></span><br><span class="line"><span class="string">  while($word = chop($quality)){</span></span><br><span class="line"><span class="string">    $quality_new = convert_Solexa64_to_Phred33($word) . $quality_new;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  print "$sequence\n";</span></span><br><span class="line"><span class="string">  print "$title2\n";</span></span><br><span class="line"><span class="string">  print "$quality_new\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="筛选fastq文件的序列">筛选fastq文件的序列</h2>
<h3 id="1-按照长度进行筛选">1. 按照长度进行筛选</h3>
<p>长度筛选类似于fasta文件的长度筛选，而且还简单一些</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上限</span></span><br><span class="line"><span class="built_in">export</span> upper_limit=89</span><br><span class="line"><span class="comment"># 下限</span></span><br><span class="line"><span class="built_in">export</span> lower_limit=89</span><br><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  # 将每一行末尾的回车符换行符去掉</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # %ENV是用来存周围环境中的变量</span></span><br><span class="line"><span class="string">  if(length($sequence)&gt;=$ENV{lower_limit} &amp;&amp; length($sequence)&lt;=$ENV{upper_limit}){</span></span><br><span class="line"><span class="string">    print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出为</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATC</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9??FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-按照gc含量进行筛选">2. 按照GC含量进行筛选</h3>
<p>按照GC含量的筛选可以按照之前的fasta文件的筛选形式来，而且这个更加简单</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">      # 首先可以定义一个求序列GC含量的子程序</span></span><br><span class="line"><span class="string">      # 这个子程序在之前的fasta文件操作中就已经写过一次了</span></span><br><span class="line"><span class="string">      sub statistic_GC_base{ # 统计序列的GC含量和数量</span></span><br><span class="line"><span class="string">          my $sequence = shift;</span></span><br><span class="line"><span class="string">          my $len      = length($sequence);</span></span><br><span class="line"><span class="string">          my $num      = ($sequence =~ tr/GCgc/GCgc/);</span></span><br><span class="line"><span class="string">          my $GC       = sprintf("%.2f",$num * 100 / $len); # 返回的是百分数（不带百分号）</span></span><br><span class="line"><span class="string">          return $GC;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      # 先定义一个GC含量的限制</span></span><br><span class="line"><span class="string">      $GC_upper_limit = 50;</span></span><br><span class="line"><span class="string">      $GC_lower_limit = 40;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # 比如我这里限制GC含量为50%，小于这个值才能通过</span></span><br><span class="line"><span class="string">  my $GC_percent = statistic_GC_base($sequence);</span></span><br><span class="line"><span class="string">  if($GC_percent &lt;=  $GC_upper_limit and $GC_percent &gt;= $GC_lower_limit){</span></span><br><span class="line"><span class="string">      print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> </span><br></pre></td></tr></tbody></table></figure>
<p>说实话可能对于fastq文件进行GC含量的筛选可能意义不大，因为本来序列准确度不一定。有些看起来含量在合适的范围内但是很可能因为测序错误导致的，这里只是说提供了一种思路。</p>
<h3 id="3-按照质量值筛选">3. 按照质量值筛选</h3>
<h4 id="截断">截断</h4>
<p>把read的两端的序列按照一定原则进行截断得到质量高的序列</p>
<h5 id="截断两端一定的长度">截断两端一定的长度</h5>
<p>我觉得这种截取的方式太过于笼统，容易丢失一些信息，然后也可能容纳一些错误信息。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> left_len=10</span><br><span class="line"><span class="built_in">export</span> right_len=20</span><br><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  substr($sequence,0,$ENV{left_len},"");</span></span><br><span class="line"><span class="string">  substr($quality,0,$ENV{left_len},"");</span></span><br><span class="line"><span class="string">  substr($sequence,0-$ENV{right_len},$ENV{right_len},"");</span></span><br><span class="line"><span class="string">  substr($quality,0-$ENV{right_len},$ENV{right_len},"");</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>再加上上面的长度分布统计的代码之后</p>
<p>输出为：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length  count</span><br><span class="line">59      1</span><br><span class="line">60      18</span><br><span class="line">61      1</span><br></pre></td></tr></tbody></table></figure>
<h5 id="根据质量值进行截断">根据质量值进行截断</h5>
<p>如果从右往左边数，碱基错误率低于20，那么截断它，即使在错误与错误之间有单个质量值高的碱基：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">test_line=80</span><br><span class="line">zcat 123.fastq.gz | <span class="built_in">head</span> -n <span class="variable">$test_line</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 新建一个子程序来判断质量值</span></span><br><span class="line"><span class="string">    sub whether_bloew_20 {</span></span><br><span class="line"><span class="string">      my $word =shift;</span></span><br><span class="line"><span class="string">      # 这里我默认是Phred+33的模式</span></span><br><span class="line"><span class="string">      if(ord($word)-33&lt;20){</span></span><br><span class="line"><span class="string">        return undef;</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    # 新建检查两端需要截断长度的子程序</span></span><br><span class="line"><span class="string">    sub side_cut_off {</span></span><br><span class="line"><span class="string">      my $sequence = shift;</span></span><br><span class="line"><span class="string">      my $direction = shift; # 查看的方向</span></span><br><span class="line"><span class="string">      my $increase_num;</span></span><br><span class="line"><span class="string">      if($direction eq "left"){</span></span><br><span class="line"><span class="string">        $increase_num = 1;</span></span><br><span class="line"><span class="string">      }else{</span></span><br><span class="line"><span class="string">        $increase_num = -1;</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      my $num = int(- 0.5 + $increase_num); # 记录目前查看碱基的位置</span></span><br><span class="line"><span class="string">      my $error_base; # 统计不达标碱基的数量</span></span><br><span class="line"><span class="string">      my $right_base; # 统计达标碱基的数量</span></span><br><span class="line"><span class="string">      my $word;</span></span><br><span class="line"><span class="string">      while($word = substr($sequence,$num,1)){</span></span><br><span class="line"><span class="string">        # 如果达标的碱基连续达到5个，那么就结束检测</span></span><br><span class="line"><span class="string">        if($right_base &gt;= 5){</span></span><br><span class="line"><span class="string">          return $num;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        $num += $increase_num;</span></span><br><span class="line"><span class="string">        if(whether_bloew_20($word)){</span></span><br><span class="line"><span class="string">          $right_base++;</span></span><br><span class="line"><span class="string">        }else{</span></span><br><span class="line"><span class="string">          $right_base = 0;</span></span><br><span class="line"><span class="string">          $error_base++;</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">      }</span></span><br><span class="line"><span class="string">      # 说明这条read没救了</span></span><br><span class="line"><span class="string">      return undef;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  # 检查左边</span></span><br><span class="line"><span class="string">  my $left_trim = side_cut_off($sequence,"left");</span></span><br><span class="line"><span class="string">  # 然后检查右边</span></span><br><span class="line"><span class="string">  my $right_trim = abs(side_cut_off($sequence,"right") + 1);</span></span><br><span class="line"><span class="string">  # 如果序列没救了就直接跳过</span></span><br><span class="line"><span class="string">  unless($left_trim){</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  # 去掉低质量</span></span><br><span class="line"><span class="string">  substr($sequence,-$right_trim,$right_trim,"");</span></span><br><span class="line"><span class="string">  substr($quality,-$right_trim,$right_trim,"");</span></span><br><span class="line"><span class="string">  substr($sequence,0,$left_trim,"");</span></span><br><span class="line"><span class="string">  substr($quality,0,$left_trim,"");</span></span><br><span class="line"><span class="string">  print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">'</span> </span><br></pre></td></tr></tbody></table></figure>
<p>性能怎么样现在还不知道，只是说这里提供了一种思路。</p>
<h4 id="直接丢弃">直接丢弃</h4>
<p>如果read的质量值或者长度不符合条件那么直接将其舍弃。</p>
<p>参考<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.drive5.com%2Fusearch%2Fmanual%2Fexp_errs.html">Expected errors predicted by Phred (Q) scores</a></p>
<p>也就说这里我们用E值来对read进行筛选：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  BEGIN{</span></span><br><span class="line"><span class="string">    # 将Q值转换为P值</span></span><br><span class="line"><span class="string">    sub Q_to_P {</span></span><br><span class="line"><span class="string">      my $q_value = shift;</span></span><br><span class="line"><span class="string">      my $p_value = 1/(10**($q_value/10));</span></span><br><span class="line"><span class="string">      return $p_value;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    sub convert_quality_to_score{</span></span><br><span class="line"><span class="string">      my $ascll = shift;</span></span><br><span class="line"><span class="string">      # 这里我默认使用Phred+33</span></span><br><span class="line"><span class="string">      return ord($ascll) - 33;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  my $total = 0;</span></span><br><span class="line"><span class="string">  my $site = 0;</span></span><br><span class="line"><span class="string">  my $word;</span></span><br><span class="line"><span class="string">  while($word = substr($quality,$site,1)){</span></span><br><span class="line"><span class="string">    $site++;</span></span><br><span class="line"><span class="string">    $total += Q_to_P(convert_quality_to_score($word));</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">  $total = int($total);</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  # 如果有10以上的碱基可能错误，那么就丢弃这个read</span></span><br><span class="line"><span class="string">  if($total &lt;= 10){</span></span><br><span class="line"><span class="string">    print "$title\n$sequence\n$comment\n$quality\n";</span></span><br><span class="line"><span class="string">  }else{</span></span><br><span class="line"><span class="string">    next;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-按照相关性筛选">4. 按照相关性筛选</h3>
<h4 id="含有某段特定的序列">含有某段特定的序列</h4>
<p>这里可以使用<code>grep</code>或者<code>perl</code>的正则表达式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | grep <span class="string">"ATGG"</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个是简单的写法，也可以利用正则表达式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/ATG\w+T(AA|AG|GA)/){</span></span><br><span class="line"><span class="string">    print;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以着色：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | awk <span class="string">'NR%4==2{print}'</span> | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  if(m/ATG\w+T(AA|AG|GA)/){</span></span><br><span class="line"><span class="string">    print;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">'</span> | grep <span class="string">'ATG'</span> --color=always</span><br></pre></td></tr></tbody></table></figure>
<h4 id="与某些序列能比对上的">与某些序列能比对上的</h4>
<p>这里实际上不能只使用perl语言，还需要搭配其他工具，这里先不写，占个位。以后补起来。</p>
<p>其实除了筛选这些序列以及质量值之外，还有第一行有很多信息也可供筛选，比如将哪些tail的序列筛选出来，去除哪个tail中的对应位置的序列等等。</p>
<h2 id="检查">检查</h2>
<h3 id="1-检查fastq文件">1. 检查fastq文件</h3>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pigz -d -c 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">    chomp(my $title = $_);</span></span><br><span class="line"><span class="string">    chomp(my $seq = &lt;&gt;);</span></span><br><span class="line"><span class="string">    &lt;&gt;;</span></span><br><span class="line"><span class="string">    chomp(my $quality = &lt;&gt;);</span></span><br><span class="line"><span class="string">    if(length($seq) != length($quality)){</span></span><br><span class="line"><span class="string">        print $. - 3 . "lines &lt;$title&gt; is error.\n";</span></span><br><span class="line"><span class="string">        print "You can use\n\n    cat *.fastq | head -n " . $. - 4 . "\n\n get the available reads!";</span></span><br><span class="line"><span class="string">        exit;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-修复">2. 修复</h3>
<p>后续添加进来</p>
<h2 id="组合起来">组合起来！</h2>
<p>上面的每一步单独的步骤前后用管道连接起来就可以连续完成多个工作啦！</p>
<p>例如</p>
<ul>
<li>想得到一部分质量稍高的几条read</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> | 按照长度筛选 | 按照质量值筛选 | 将序列转换为fasta序列</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>大致统计一下20000条read的长度分布</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> -n 80000 | 将序列转换为fasta序列 | 统计每一条序列的长度</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>统计20000条质量稍高的read的GC含量</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取fastq文件 | <span class="built_in">head</span> -n 80000 | 按照质量值筛选 | 将序列转换为fasta序列 | 统计GC含量分布</span><br></pre></td></tr></tbody></table></figure>
<p>除此之外还有别的组合，按照自己的需要来，上面的步骤中部分用到了之前的fasta文件的相关操作。</p>
<h2 id="有意思的">有意思的</h2>
<p>参考自<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnblogs.com%2Fyahengwang%2Fp%2F8973948.html">青蛙快飞</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zcat 123.fastq.gz | perl -n -e <span class="string">'</span></span><br><span class="line"><span class="string">  (my $title    = $_) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $sequence = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $comment  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  (my $quality  = &lt;&gt;) =~ s/\r?\n//;</span></span><br><span class="line"><span class="string">  $quality =~ tr{!"#$%&amp;'</span>()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKL}{▁▁▁▁▁▁▁▁▂▂▂▂▂▃▃▃▃▃▄▄▄▄▄▅▅▅▅▅▆▆▆▆▆▇▇▇▇▇██████};</span><br><span class="line">  <span class="built_in">print</span> <span class="string">"<span class="variable">$title</span>\n<span class="variable">$sequence</span>\n<span class="variable">$comment</span>\n<span class="variable">$quality</span>\n"</span>;</span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="测试数据">测试数据</h2>
<p>因为数据量太大，对于本次的实战演练耗时较长，所以我取了80行的fastq的信息来作为测试用。</p>
<ol>
<li>
<p>新建文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在windows下新建方法，<code>右键</code> - <code>新建</code> - <code>文本文档</code> - 改名为<code>123.fastq</code></li>
<li>在linux、mac等命令行中新建的方法，打开<code>shell</code> - 输入<code>echo -n 123.fastq</code></li>
</ul>
</li>
<li>
<p>加入数据，将下面的测序数据拷贝到</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq</span><br></pre></td></tr></tbody></table></figure>
<p>文件中</p>
<ul>
<li>在windows下，用<code>记事本</code>打开，拷贝下面的数据然后保存。</li>
<li>在命令行中，那就先<code>vim 123.fastq</code>，打开文件，然后按<code>a</code>进入编辑模式，将下面的数据拷贝到里面。然后按下<code>Esc</code>，输入<code>:wq</code>，按下<code>Enter</code>保存。</li>
</ul>
</li>
<li>
<p>压缩为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.fastq.gz</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>打开<code>git for windows</code>或者<code>shell</code>，输入<code>gzip 123.fastq</code>。</li>
</ul>
</li>
</ol>
<p>将下面的数据拷贝到<br>
数据：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@SRR2177462.1 FCC600JACXX:2:1101:1489:2045/1</span><br><span class="line">NGGCAAAAGGAAGCACATATTCGCATATAGAACCAGGATTTATAAGGTACAACAANTAGACTTATCCTCCACTCTCATGTTCATGAATC</span><br><span class="line">+</span><br><span class="line">#1=ABDD?FH?HFG&gt;DGHBHIFFHGCGGCHGCGHGII)?FG@DBAEH9??FGAB#-5@(@=EEHECAAH@EE;BCEEFA@ADDCCA;AC</span><br><span class="line">@SRR2177462.2 FCC600JACXX:2:1101:1661:2085/1</span><br><span class="line">NAATGAAATTAAAGATAGCTGATCTATATTTCTCAAGTGACTAAGTATTAATATTATGCGTACTCTGTATTTCTCTAGTTGGTGGTTTAG</span><br><span class="line">+</span><br><span class="line">#4=DDFFFHHFHFIGIHIIIJEGHIGIAHIJFIEHHHIIIIIEIHIIIJCFIHJIHIIAHIFFGIIJHFHIIJIJF@FEHGIDHHA?B@C</span><br><span class="line">@SRR2177462.3 FCC600JACXX:2:1101:1683:2113/1</span><br><span class="line">GCGACCTCGCGGGCGAAGCCCATCTCGTGGGTGACGCAGATCATCGTCATGCCCTCGGCGGCGAGGCCTTTCCTGACGGCGGGGACCTCC</span><br><span class="line">+</span><br><span class="line">@@@BDDDDFHDDA:DDBHH@F6=DCEHHHFE6&gt;;;?86?BC:ACCC@98?########################################</span><br><span class="line">@SRR2177462.4 FCC600JACXX:2:1101:1730:2127/1</span><br><span class="line">TTTGTCCACTTCCTCCACTTCGTCAACTTCGTCCACTTCGTCCACTTCCTCAACTTCGTCAACTTCGTCCACTTCGTCAACTTCGTCCAC</span><br><span class="line">+</span><br><span class="line">BBCFFFFFHHHHHHJJJJIJIIJJEIHHHGIJHIJJIIGGIGGIJGHDFHC4BBCGC@G;(;CEGEEH??@DCFD?CC=&gt;CDDDDDD??D</span><br><span class="line">@SRR2177462.5 FCC600JACXX:2:1101:1663:2160/1</span><br><span class="line">ACAAAAAGCACAGAGAAGCATTGAGAATGGGGGATTTTGGAGAGCTCCAGGGGGACCTTCATCTTCACTGGATCATCATCCATTGCCAAG</span><br><span class="line">+</span><br><span class="line">@BCFFFFFFHHFHGHIJJHGHIIFHGCHIJJJJBHGIJHGHGGGIHFHFHCGIHBCDECCCDDDDCDCCDBCDCB&gt;CC@CCDDEDDCCDD</span><br><span class="line">@SRR2177462.6 FCC600JACXX:2:1101:1555:2174/1</span><br><span class="line">CACAATTGGTGAGTTCTAACGTTAGCATTATTGGTTTGAAAGTATATATGGAACACTTATACCTAGAACTATCGTTTTTGTCATTATTAA</span><br><span class="line">+</span><br><span class="line">@@@FFFFDHAFFFFBEGGIIIFHDGHEDHIII&gt;FFHHIGGGGBFHGIIIGHECBGDGHGGCAG@G==FCF=FAC=@ACE/6?BEFDCCB@</span><br><span class="line">@SRR2177462.7 FCC600JACXX:2:1101:1561:2201/1</span><br><span class="line">TCTCCTTTAGCATCAAACCCTCCGTTGGAATAACCCAACAACCATACATACATTCATAGAGAAAACCCAACACAAATATTACATAAACCT</span><br><span class="line">+</span><br><span class="line">@@@BDDDA&lt;?ADF@DHGGCD9:A@AGE??EC?9:???BFHI)8BFEFIIG8=CHG)=FA@4@GEGII;AABDEB;;@CDC&gt;CCDCCCC5?</span><br><span class="line">@SRR2177462.8 FCC600JACXX:2:1101:1676:2217/1</span><br><span class="line">GCTAGTTCCTAACAGAACTCGAGGTAACAGTCCAAGGGATTGAAAAAACACAAGCTGATGTTCGTCGAAGTAATACAACAAGAAGGAGAC</span><br><span class="line">+</span><br><span class="line">@CCFFFFFFHHDDBHIIGI?E@GHCGHGGGHIB&gt;DECEBBFCABEDGGEECHIGGGACHG;@AEE?DBBB5&gt;CADA&gt;(;99&lt;CCCB9?A@</span><br><span class="line">@SRR2177462.9 FCC600JACXX:2:1101:1700:2228/1</span><br><span class="line">CAAAACACTTCAATAGCATGTTCTAAAAGGACTGCTTTAAAAATCTTCTACAAATCTCACATGTTTCAAACTAGATTTTGAAGCAATAAA</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHFFIIJIIGIIIDHJJJIHJEHIIHIIIFHHIEHIIIIJGGHEHFGIJIIJIJHIJJBFHJIJJIHIJJJEEEEFFFFFF</span><br><span class="line">@SRR2177462.10 FCC600JACXX:2:1101:1962:2055/1</span><br><span class="line">NTTATGTGATGTGAATGATTATGTATAATTGTATGAAACTTAGTAAATTAATATATGATTAATCTTGTTTAAACTAGCTTATCCTATTGT</span><br><span class="line">+</span><br><span class="line">#4=BDFDFFHHHHGIIJHJJGJJJIIIHHJJIIIIHIJJIJGHHGIJIJHIJJJIJJJJJIIIJJJJIJJHHGIIJIJJJIIGJJHJJJJ</span><br><span class="line">@SRR2177462.11 FCC600JACXX:2:1101:1774:2118/1</span><br><span class="line">CACCAAGACGCTACCTAAGGATAGATTTTTTGAGCTTAGAAGAGAGTTAGGAGTATTAGACATGTCTTAGGATCAACGATTATGAAAATTT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIGIGGGHEHEHHIJJJJJJ?GGHIGIIJGGIHIGIIJDFH7@EHIIGHHGHAHHFDEFFCEE&gt;CC=ABDDDCDDDDCD</span><br><span class="line">@SRR2177462.12 FCC600JACXX:2:1101:1931:2123/1</span><br><span class="line">CAGCTTTTTGTGGTTTGCAAGGAAACTGAGCAGAAATATGAACCACATGTGACAACAAAAAAATTAGGAAGCTGTCTGTGAATTATTATT</span><br><span class="line">+</span><br><span class="line">@@@DFFFFHHFFHGIJIGGEHIBGHIJIDHHJJFIEIIJJJGHIIGIIFGHGIIJJIIJIJIHFDF=D&gt;CEDEECCACCC&gt;AFDDEACDD</span><br><span class="line">@SRR2177462.13 FCC600JACXX:2:1101:1759:2210/1</span><br><span class="line">AATAAATGTGAAAATGGCAATAATAACAAACCTGCTGCAATTATACTTGTTATCTTTATCCAAGATTTCAGGTGCAGTAAATTGTCCCAG</span><br><span class="line">+</span><br><span class="line">@CCFFFFFHHGGHIJJJJJJJIEIJJIIJJJJJJJJJJIJJJJJJJJJJIIIIIJJJIJJGJIJIJJIJGJJHIJHIIJIGHHHHHGEEF</span><br><span class="line">@SRR2177462.14 FCC600JACXX:2:1101:1922:2245/1</span><br><span class="line">TATCATTAAACAAACATGCACATTGCTTAAGAAACATAAAACTTCCACTGAAACAATTTATAAGATTGCACCAGATTTATTCCTTTTTGT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHGHIJJJJJJJJJJJJJJIIJJJJJJJJJJJJIIJHIJIJHJIJJJJJJGIJJJJJJJJIJIJJADHIHHHHHHHFFFFE</span><br><span class="line">@SRR2177462.15 FCC600JACXX:2:1101:2088:2085/1</span><br><span class="line">NATGACGTATATTAAGTGTTGAAGATGAAGACATATGTGGTTGGTTTGTTTATGTGTATTTCTCTCTCTGTGCTTCGTTTATGCTTCATT</span><br><span class="line">+</span><br><span class="line">#1=DDFFDHHHHHIIJGHJJJIIHIGIHGHHHIJIIIHIIFHIJ?GHIGHIBHGICBAHEIHIIJJIJJIJJIIJJHHFFFFFFFEDDEE</span><br><span class="line">@SRR2177462.16 FCC600JACXX:2:1101:2166:2127/1</span><br><span class="line">TGGAGGAAGTGGAGGAAGTGGAGGAAGTTGACGAAGTGGACGAAGTGGAGGAAGTGGACGAAGTGGAAGAAGTGGACGAAGTGGAGGAAG</span><br><span class="line">+</span><br><span class="line">@CCFFFDFHDFHHHJGGIEEHBHIIJJIAGGHIEHI8DHDHGGFH;CGAEE;DGECHC)99&gt;A###########################</span><br><span class="line">@SRR2177462.17 FCC600JACXX:2:1101:2243:2189/1</span><br><span class="line">CTTGTCAGAACCCATTCAAAACCACTAAAAACCCCTGCATAGTGGAAGCCAAATGTTAAGGAAGAGAGCTGGAAATCAGAGAGTGGAAAA</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIJJGIJJJIJJIJJJJJJJJIJJJJJJJJIJJDHHHIGIIIJIII@GIIJIJJIHFHHFFFF@EDEEEEDACD@@AC</span><br><span class="line">@SRR2177462.18 FCC600JACXX:2:1101:2145:2249/1</span><br><span class="line">AATATTTGATCAATAGATTTTATGATAAATATAAACATACAGTAGAATTTTAAAAAACAAGGAATTTAGCTACCAAAAACAAGCTATGAG</span><br><span class="line">+</span><br><span class="line">&lt;&lt;@AABDD&gt;HHFBFH@EHIHIADHIEGEHIHDAEHH&lt;FFGBFEGDFHIIHGA&gt;BGB@FFFEDCGGHIGIIEG@DECCHHGFDC?C@EEEE</span><br><span class="line">@SRR2177462.19 FCC600JACXX:2:1101:2366:2232/1</span><br><span class="line">TACTGAACTTCTTCAAGAATTTGATCAACCCAGGAACCTATTGCAATGTCTCAATCATAGGAACTTTAATCTCCAATTTCTTGAAGATTT</span><br><span class="line">+</span><br><span class="line">CCCFFFFFHHHHHIJJJJJJJJJJJJJJJJJJJJIJJJJJJJJJJGHJIJJJJHIJDHIJJGIJJJJIHIGIIIIGIGHGHHHEEFDFFF</span><br><span class="line">@SRR2177462.20 FCC600JACXX:2:1101:2455:2241/1</span><br><span class="line">CACGGATCTGCAGAATAGCACCAAAGCTGGAGCTATCACTTTACTTCGTCAACTTCGTCCACTTCCTCCATTTCTTCCACTTCCTCCACT</span><br><span class="line">+</span><br><span class="line">@@CFFDFFHHGGGIJJJJJJJJJJJJIJJJHIJIJJJJJIJJGJJJGGHIIJIIEEHGHEIIIJIHHHEEHFDEFBDBCE&gt;&gt;ACCDCCDC</span><br></pre></td></tr></tbody></table></figure>
<h2 id="后记">后记</h2>
<p>其实现在有很多软件可以处理fastq文件，比如<code>FASTX-Toolkit</code>、<code>seqkit</code>、<code>FaQCs</code>、<code>fastqc</code>、<code>fastp</code>、<code>Reseqtools</code>等等，也不需要perl写几行脚本来处理。那这个还有什么意思呢？</p>
<p>你要是读了之后，你会发现在文中我提到了有关代码重用的问题，实际上在处理这类文件的时候有些东西是相通的，你可以在这个文本里面中会看到之前我在操作fasta文件的时候用到的代码。而把这些代码拿到这里来用照样可以达到目的。这个过程就有点像搭积木，积木的基本形状也就那几种，什么正方体、长方体、直角等腰三角形、圆柱等灯，可是不同的搭配、不同布局搭起来的东西就不一样了。当我们把这种单一的，完成某种独立功能的代码组合起来之后就会由一块一块的积木搭建起整个城堡，迎接你的公主！</p>
<p>除了代码之外，在文中也说明了有关质量值编码的问题，话说现在都是采用的Phred+33的编码方式了，那还提那些陈年旧事有什么意思了？有的时候我也在想在课本中提到的那些年代久远的故事究竟有什么作用呢？比如生化书上面的那些经典的比如三羧酸循环，那些都是几十年前就已经搞很清楚的事情为什么还要提呢？ 我觉得仁者见仁智者见智吧！可能我有点怀旧吧！</p>
<h2 id="参考">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fyahengwang%2Fp%2F8973948.html">FASTQ文件格式</a> - 说明fastq的格式</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fluo617%2Farticle%2Fdetails%2F81220829">fastq fasta 序列数快速统计</a> - pigz的使用</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.biotrainee.com%2Fthread-2072-1-1.html">一行脚本判断你的fastq测序数据的质量编码方式-ydchen</a> - 质量值的类型判断</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.sciencenet.cn%2Fblog-630246-813262.html">Fastq 格式说明 &amp; (Phred33 or Phred64) - 揭文才</a> - 编码类型的说明</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav23077195%3Ffrom%3Dsearch%26seid%3D15283415322892062157">陈巍学基因 - Hiseq测序仪工作原理</a> - 测序原理与质量值</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPhred_base_calling">Phred base calling</a> - phred</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.phrap.com%2Fphred%2F">phred</a> - phred</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ebiotrade.com%2Fnewsf%2F2015-11%2F2015116173109897.htm">新一代测序十年记：Solexa闪亮登场</a> - Solexa与Illumina</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fnot.farbox.com%2Fpost%2Fphred_p1%23toc_1">质量值体系 Phred33 和 Phred 64 的由来 及其在质量控制中的实际影响 - Part 1</a> - Phred33 和 Phred 64 的由来</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fjasonjwilliamsny.github.io%2Fwrangling-genomics%2F00-readQC.html">QC of Read Data</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fcolyfu.com%2FQC%2Ffastq-phred-trans.html">判断fastq文件质量编码格式及Phred64转Phred33方法</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.bio-info-trainee.com%2F1850.html">终于碰到color space的测序数据啦！</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.biostars.org%2Fp%2F43855%2F">Tutorial: Transforming And Manipulating Color Space Reads</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fclub.topsage.com%2Fthread-2229946-1-1.html">Perl中FastQ与FastA格式的相互转换</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.biostack.org%2F%3Fp%3D558">NGS数据质量过滤：Usearch fastq-filter、seqtk trimfq和seqtk_filter</a> - read的筛选原则</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.drive5.com%2Fusearch%2Fmanual%2Fexp_errs.html">Expected errors predicted by Phred (Q) scores</a> - 序列的质量值的E值</li>
</ul>
<h2 id="链接">链接</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/63e2abb1b788">perl One-Liners | perl命令行学习3 -a和-F参数</a> - 介绍<code>BEGIN{}</code>块 和 <code>END{}</code>块</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10da73890ef0">perl 命令行实战1 - fasta文件的相关操作</a> - 介绍fasta文件的操作</li>
</ul>
<h2 id="引用">引用</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.qingting.fm%2Fchannels%2F207522">重阳的世界观-第1期：狂点科技树（1）</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Ftieba.baidu.com%2Fp%2F2709117638%3Fred_tag%3D1385790551">百度贴吧-秦国吧-秦国特有的三棱箭头</a></li>
</ul>
<script src="https://giscus.app/client.js" data-repo="eternal-bug/giscus" data-repo-id="R_kgDOMHOH6Q" data-category="Announcements" data-category-id="DIC_kwDOMHOH6c4Cf-m4" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
</script>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://eternal-bug.github.io">eternal-bug</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://eternal-bug.github.io/posts/67fa7a61.html">https://eternal-bug.github.io/posts/67fa7a61.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://eternal-bug.github.io" target="_blank">eternal-bug的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Perl/">Perl</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin_reward.png" target="_blank"><img class="post-qr-code-img" src="/img/weixin_reward.png" alt="微信打赏"/></a><div class="post-qr-code-desc">微信打赏</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f2633fba.html" title="生物画图大作战之基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">生物画图大作战之基础篇</div></div></a></div><div class="next-post pull-right"><a href="/posts/8aac1538.html" title="Perl 命令行实战1 - fasta文件的相关操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Perl 命令行实战1 - fasta文件的相关操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1d803e51.html" title="Perl One-Liners之前期准备"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之前期准备</div></div></a></div><div><a href="/posts/d4df8203.html" title="Perl One-Liners之参数-a和-F"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之参数-a和-F</div></div></a></div><div><a href="/posts/2916cf.html" title="Perl One-Liners之参数-e"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之参数-e</div></div></a></div><div><a href="/posts/340e5adf.html" title="Perl One-Liners之参数-M和-I"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之参数-M和-I</div></div></a></div><div><a href="/posts/29e0fbc7.html" title="Perl One-Liners之参数-p和-n"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之参数-p和-n</div></div></a></div><div><a href="/posts/5b7308bf.html" title="Perl One-Liners之特殊变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">Perl One-Liners之特殊变量</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">eternal-bug</div><div class="author-info__description">一个喜欢牵着骆驼、带着闪亮R形状戒指的白菜哥。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/eternal-bug"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#fastq%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">fastq文件的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">前期准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.</span> <span class="toc-text">注意!!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96fastq%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">获取fastq文件的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%8F%E5%88%97%E6%9D%A1%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1. 序列条数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2. 质量值的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">有关质量值的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E5%BA%8F%E7%9A%84%E9%94%99%E8%AF%AF%E6%9D%A5%E6%BA%90"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">测序的错误来源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">错误的评判标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E8%AE%B0%E5%BD%95%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">质量值的记录方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">质量值的编码方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">质量值的区别方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-fastqc%E7%9B%B8%E5%85%B3%E7%BB%9F%E8%AE%A1%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3. fastqc相关统计量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-number">4.3.1.</span> <span class="toc-text">序列长度的分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%8A%E8%B4%A8%E9%87%8F%E5%80%BC%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-number">4.3.2.</span> <span class="toc-text">每个位置上质量值的分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#n%E5%80%BC%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">4.3.3.</span> <span class="toc-text">N值的统计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">格式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-fastq%E8%BD%AC%E6%8D%A2%E4%B8%BAfasta"><span class="toc-number">5.1.</span> <span class="toc-text">1. fastq转换为fasta</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.1.</span> <span class="toc-text">普通转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8A%8A%E8%B4%A8%E9%87%8F%E5%80%BC%E4%BF%9D%E7%95%99%E4%B8%8B%E6%9D%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">也可以把质量值保留下来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.3.</span> <span class="toc-text">特殊转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">质量编码标准的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E9%A6%96%E5%85%88%E8%A6%81%E7%A1%AE%E5%AE%9A%E8%B4%A8%E9%87%8F%E5%80%BC%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">0. 首先要确定质量值编码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-phred-64%E8%BD%AC%E6%8D%A2%E4%B8%BAphred-33"><span class="toc-number">6.2.</span> <span class="toc-text">1. Phred+64转换为Phred+33</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-solexa-64%E8%BD%AC%E6%8D%A2%E4%B8%BAphred-33"><span class="toc-number">6.3.</span> <span class="toc-text">2. Solexa+64转换为Phred+33</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%9B%E9%80%89fastq%E6%96%87%E4%BB%B6%E7%9A%84%E5%BA%8F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">筛选fastq文件的序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%89%E7%85%A7%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89"><span class="toc-number">7.1.</span> <span class="toc-text">1. 按照长度进行筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%89%E7%85%A7gc%E5%90%AB%E9%87%8F%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89"><span class="toc-number">7.2.</span> <span class="toc-text">2. 按照GC含量进行筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%89%E7%85%A7%E8%B4%A8%E9%87%8F%E5%80%BC%E7%AD%9B%E9%80%89"><span class="toc-number">7.3.</span> <span class="toc-text">3. 按照质量值筛选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%96%AD"><span class="toc-number">7.3.1.</span> <span class="toc-text">截断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E4%B8%A4%E7%AB%AF%E4%B8%80%E5%AE%9A%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">截断两端一定的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%B4%A8%E9%87%8F%E5%80%BC%E8%BF%9B%E8%A1%8C%E6%88%AA%E6%96%AD"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">根据质量值进行截断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%A2%E5%BC%83"><span class="toc-number">7.3.2.</span> <span class="toc-text">直接丢弃</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%89%E7%85%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AD%9B%E9%80%89"><span class="toc-number">7.4.</span> <span class="toc-text">4. 按照相关性筛选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%9F%90%E6%AE%B5%E7%89%B9%E5%AE%9A%E7%9A%84%E5%BA%8F%E5%88%97"><span class="toc-number">7.4.1.</span> <span class="toc-text">含有某段特定的序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%9F%90%E4%BA%9B%E5%BA%8F%E5%88%97%E8%83%BD%E6%AF%94%E5%AF%B9%E4%B8%8A%E7%9A%84"><span class="toc-number">7.4.2.</span> <span class="toc-text">与某些序列能比对上的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5"><span class="toc-number">8.</span> <span class="toc-text">检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5fastq%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">1. 检查fastq文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%AE%E5%A4%8D"><span class="toc-number">8.2.</span> <span class="toc-text">2. 修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-number">9.</span> <span class="toc-text">组合起来！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84"><span class="toc-number">10.</span> <span class="toc-text">有意思的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">11.</span> <span class="toc-text">测试数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">12.</span> <span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">13.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">14.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d2eaa30e.html" title="bash脚本中conda环境的转换">bash脚本中conda环境的转换</a><time datetime="2024-07-17T12:32:19.576Z" title="发表于 2024-07-17 20:32:19">2024-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/25a848be.html" title="LangChain的拆解（一）利用符号重载实现基本Chain">LangChain的拆解（一）利用符号重载实现基本Chain</a><time datetime="2024-07-02T11:53:32.000Z" title="发表于 2024-07-02 19:53:32">2024-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/91e29fb3.html" title="LangChain + 本地ChatGLM3模型构建Agent（一）工具调用的底层逻辑和测试">LangChain + 本地ChatGLM3模型构建Agent（一）工具调用的底层逻辑和测试</a><time datetime="2024-06-25T13:06:07.000Z" title="发表于 2024-06-25 21:06:07">2024-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/67e74819.html" title="过度封装的LangChain？一个小白的吐槽">过度封装的LangChain？一个小白的吐槽</a><time datetime="2024-06-23T03:21:47.000Z" title="发表于 2024-06-23 11:21:47">2024-06-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/10f93d59.html" title="LangChain + 本地ChatGLM3模型构建RAG应用1：法律助手">LangChain + 本地ChatGLM3模型构建RAG应用1：法律助手</a><time datetime="2024-06-21T13:23:56.000Z" title="发表于 2024-06-21 21:23:56">2024-06-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/starbound.half.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By eternal-bug</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你好！欢迎来到<a href="https://eternal-bug.github.io">我的博客</a>。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>